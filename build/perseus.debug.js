/*! Perseus | http://github.com/Khan/perseus */
// commit 72ac7712ba61b4dc7b0e89ebc4635f4feb122b2a
;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function(Perseus) {

require("./widgets/categorization.jsx");
require("./widgets/dropdown.jsx");
require("./widgets/expression.jsx");
require("./widgets/input-number.jsx");
require("./widgets/interactive-graph.jsx");
require("./widgets/interactive-number-line.jsx");
require("./widgets/matcher.jsx");
require("./widgets/orderer.jsx");
require("./widgets/plotter.jsx");
require("./widgets/protractor.jsx");
require("./widgets/radio.jsx");
require("./widgets/sorter.jsx");
require("./widgets/table.jsx");
require("./widgets/transformer.jsx");

})(Perseus);


},{"./widgets/categorization.jsx":21,"./widgets/dropdown.jsx":22,"./widgets/expression.jsx":23,"./widgets/input-number.jsx":24,"./widgets/interactive-graph.jsx":25,"./widgets/interactive-number-line.jsx":26,"./widgets/matcher.jsx":27,"./widgets/orderer.jsx":28,"./widgets/plotter.jsx":29,"./widgets/protractor.jsx":30,"./widgets/radio.jsx":31,"./widgets/sorter.jsx":32,"./widgets/table.jsx":33,"./widgets/transformer.jsx":34}],2:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("./core.js");
require("./renderer.jsx");
require("./editor.jsx");
var Util = require("./util.js");

var InfoTip = require("./components/info-tip.jsx");
var Widgets = require("./widgets.js");
var Renderer = Perseus.Renderer;
var Editor = Perseus.Editor;

var AnswerAreaRenderer = Perseus.AnswerAreaRenderer = React.createClass({
    getInitialState: function() {
        // TODO(alpert): Move up to parent props?
        return {
            widget: {},
            cls: this.getClass(this.props.type)
        };
    },

    componentWillReceiveProps: function(nextProps) {
        this.setState({cls: this.getClass(nextProps.type)});
    },

    getClass: function(type) {
        if (type === "multiple") {
            return Renderer;
        } else {
            return Widgets.get(type);
        }
    },

    render: function(rootNode) {
        return this.state.cls(_.extend({
            ref: "widget",
            problemNum: this.props.problemNum,
            onChange: function(newProps, cb) {
                var widget = _.extend({}, this.state.widget, newProps);
                this.setState({widget: widget}, cb);
            }.bind(this)
        }, this.props.options, this.state.widget));
    },

    componentDidMount: function() {
        this.$examples = $("<div id='examples'></div>");
        this.update();
    },

    componentDidUpdate: function() {
        this.update();
    },

    update: function() {
        $("#calculator").toggle(this.props.calculator);

        $("#examples-show").hide();
        if ($("#examples-show").data("qtip")) {
            $("#examples-show").qtip("destroy", /* immediate */ true);
        }

        var widget = this.refs.widget;
        var examples = widget.examples ? widget.examples() : null;

        if (examples && $("#examples-show").length) {
            $("#examples-show").append(this.$examples);

            var content = _.map(examples, function(example) {
                return "- " + example;
            }).join("\n");

            React.renderComponent(
                Renderer({content: content}),
                this.$examples[0]);

            $("#examples-show").qtip({
                content: {
                    text: this.$examples.remove()
                },
                style: {classes: "qtip-light leaf-tooltip"},
                position: {
                    my: "center right",
                    at: "center left"
                },
                show: {
                    delay: 200,
                    effect: {
                        length: 0
                    }
                },
                hide: {delay: 0}
            });

            $("#examples-show").show();
        }
    },

    componentWillUnmount: function() {
        if (this.props.calculator) {
            $("#calculator").hide();
        }
        if (this.state.cls.examples && $("#examples-show").length) {
            $("#examples-show").hide();
            React.unmountComponentAtNode(
                    document.getElementById("examples"));
        }
    },

    focus: function() {
        this.refs.widget.focus();
    },

    guessAndScore: function() {
        // TODO(alpert): These should probably have the same signature...
        if (this.props.type === "multiple") {
            return this.refs.widget.guessAndScore();
        } else {
            var guess = this.refs.widget.toJSON();

            var score;
            if (this.props.graded == null || this.props.graded) {
                // props.graded is unset or true
                // TODO(alpert): Separate out the rubric
                score = this.refs.widget.simpleValidate(this.props.options);
            } else {
                score = Util.noScore;
            }

            return [guess, score];
        }
    }
});

var AnswerAreaEditor = Perseus.AnswerAreaEditor = React.createClass({
    getDefaultProps: function() {
        return {
            type: "input-number",
            options: {},
            calculator: false
        };
    },

    render: function() {
        var cls;
        if (this.props.type === "multiple") {
            cls = Editor;
        } else {
            cls = Widgets.get(this.props.type + "-editor");
        }

        var editor = cls(_.extend({
            ref: "editor",
            onChange: function(newProps, cb) {
                var options = _.extend({}, this.props.options, newProps);
                this.props.onChange({options: options}, cb);
            }.bind(this)
        }, this.props.options));

        return React.DOM.div( {className:"perseus-answer-editor"}, 
            React.DOM.div( {className:"perseus-answer-options"}, 
            React.DOM.div(null, React.DOM.label(null, 
                " Show calculator: ",
                React.DOM.input( {type:"checkbox", checked:this.props.calculator,
                    onChange:function(e) {
                        this.props.onChange({calculator: e.target.checked});
                    }.bind(this)} )
            ),
            InfoTip(null, 
                React.DOM.p(null, "Use the calculator when completing difficult calculations is "+
                "NOT the intent of the question. DON’T use the calculator when "+
                "testing the student’s ability to complete different types of "+
                "computations.")
            )
            ),
            React.DOM.div(null, React.DOM.label(null, 
                " Answer type: ",
                React.DOM.select( {value:this.props.type,
                        onChange:function(e) {
                            this.props.onChange({
                                type: e.target.value,
                                options: {}
                            }, function() {
                                this.refs.editor.focus();
                            }.bind(this));
                        }.bind(this)}, 
                    React.DOM.option( {value:"radio"}, "Multiple choice"),
                    React.DOM.option( {value:"table"}, "Table of values"),
                    React.DOM.option( {value:"input-number"}, "Text input (number)"),
                    React.DOM.option( {value:"expression"}, "Expression / Equation"),
                    React.DOM.option( {value:"multiple"}, "Custom format")
                )
            ),
            InfoTip(null, 
                React.DOM.p(null, "Use the custom format if the question is in the question "+
                "area, and tell the students how to complete the problem.")
            ))
            ),
            React.DOM.div( {className:cls !== Editor ? "perseus-answer-widget" : ""}, 
                editor
            )
        );
    },

    toJSON: function(skipValidation) {
        // Could be just _.pick(this.props, "type", "options"); but validation!
        return {
            type: this.props.type,
            options: this.refs.editor.toJSON(skipValidation),
            calculator: this.props.calculator
        };
    }
});

})(Perseus);

},{"./components/info-tip.jsx":6,"./core.js":11,"./editor.jsx":13,"./renderer.jsx":17,"./util.js":19,"./widgets.js":20}],3:[function(require,module,exports){
/** @jsx React.DOM */

/* You know when you want to propagate input to a parent...
 * but then that parent does something with the input...
 * then changing the props of the input...
 * on every keystroke...
 * so if some input is invalid or incomplete...
 * the input gets reset or otherwise effed...
 *
 * This is the solution.
 *
 * Enough melodrama. Its an imput that only sends changes to its parent on
 * blur.
 */
var BlurInput = React.createClass({displayName: 'BlurInput',
    propTypes: {
        value: React.PropTypes.string.isRequired,
        onChange: React.PropTypes.func.isRequired
    },
    getInitialState: function() {
        return { value: this.props.value };
    },
    render: function() {
        return React.DOM.input(
            {type:"text",
            value:this.state.value,
            onChange:this.handleChange,
            onBlur:this.handleBlur} );
    },
    componentWillReceiveProps: function(nextProps) {
        this.setState({ value: nextProps.value });
    },
    handleChange: function(e) {
        this.setState({ value: e.target.value });
    },
    handleBlur: function(e) {
        this.props.onChange(e.target.value);
    }
});

module.exports = BlurInput;

},{}],4:[function(require,module,exports){
/** @jsx React.DOM */

require("../core.js");
var Util = require("../util.js");

var InfoTip     = require("../components/info-tip.jsx");
var NumberInput = require("../components/number-input.jsx");

var defaultBoxSize = 400;
var defaultBackgroundImage = {
    url: null,
    scale: 1,
    bottom: 0,
    left: 0,
};

function numSteps(range, step) {
    return Math.floor((range[1] - range[0]) / step);
}

var GraphSettings = React.createClass({displayName: 'GraphSettings',
    getInitialState: function() {
        return {
            labelsTextbox: this.props.labels,
            gridStepTextbox: this.props.gridStep,
            snapStepTextbox: this.props.snapStep,
            stepTextbox: this.props.step,
            rangeTextbox: this.props.range
        };
    },

    getDefaultProps: function() {
        return {
            box: [340, 340],
            labels: ["x", "y"],
            range: [[-10, 10], [-10, 10]],
            step: [1, 1],
            gridStep: [1, 1],
            snapStep: Util.snapStepFromGridStep(
                this.props.gridStep || [1, 1]),
            valid: true,
            backgroundImage: defaultBackgroundImage,
            markings: "graph",
            showProtractor: false
        };
    },

    render: function() {
        return React.DOM.div(null, 
            React.DOM.div( {className:"graph-settings"}, 
                React.DOM.div(null, "x label: ",
                    React.DOM.input(  {type:"text",
                            ref:"labels-0",
                            onInput:_.bind(this.changeLabel, this, 0),
                            value:this.state.labelsTextbox[0]} )
                ),
                React.DOM.div(null, "y label: ",
                    React.DOM.input(  {type:"text",
                            ref:"labels-1",
                            onInput:_.bind(this.changeLabel, this, 1),
                            value:this.state.labelsTextbox[1]} )
                ),
                React.DOM.div(null, "x range: ",
                    React.DOM.input(  {type:"text",
                            ref:"range-0-0",
                            onInput:_.bind(this.changeRange, this, 0, 0),
                            value:this.state.rangeTextbox[0][0]} ),
                    React.DOM.input(  {type:"text",
                            ref:"range-0-1",
                            onInput:_.bind(this.changeRange, this, 0, 1),
                            value:this.state.rangeTextbox[0][1]} )
                ),
                React.DOM.div(null, 
                    " y range: ",
                    React.DOM.input(  {type:"text",
                            ref:"range-1-0",
                            onInput:_.bind(this.changeRange, this, 1, 0),
                            value:this.state.rangeTextbox[1][0]} ),
                    React.DOM.input(  {type:"text",
                            ref:"range-1-1",
                            onInput:_.bind(this.changeRange, this, 1, 1),
                            value:this.state.rangeTextbox[1][1]} )
                ),
                React.DOM.div(null, 
                    " Tick Step: ",
                    React.DOM.input(  {type:"text",
                            ref:"step-0",
                            onInput:_.bind(this.changeStep, this, 0),
                            value:this.state.stepTextbox[0]} ),
                    React.DOM.input(  {type:"text",
                            ref:"step-1",
                            onInput:_.bind(this.changeStep, this, 1),
                            value:this.state.stepTextbox[1]} )
                ),
                React.DOM.div(null, 
                    " Grid Step: ",
                    NumberInput(
                        {ref:"grid-step-0",
                        onChange:_.bind(this.changeGridStep, this, 0),
                        value:this.state.gridStepTextbox[0]} ),
                    NumberInput(
                        {ref:"grid-step-1",
                        onChange:_.bind(this.changeGridStep, this, 1),
                        value:this.state.gridStepTextbox[1]} )
                ),
                React.DOM.div(null, 
                    " Snap Step: ",
                    NumberInput(
                        {ref:"snap-step-0",
                        onChange:_.bind(this.changeSnapStep, this, 0),
                        value:this.state.snapStepTextbox[0]} ),
                    NumberInput(
                        {ref:"snap-step-1",
                        onChange:_.bind(this.changeSnapStep, this, 1),
                        value:this.state.snapStepTextbox[1]} )
                ),
                React.DOM.div(null, 
                    React.DOM.label(null, "Markings: ",
                        React.DOM.select( {value:this.props.markings,
                                onChange:this.changeMarkings}, 
                            React.DOM.option( {value:"graph"}, "Graph (axes + grid)"),
                            React.DOM.option( {value:"grid"}, "Grid only"),
                            React.DOM.option( {value:"none"}, "None")
                        )
                    )
                )
            ),
            React.DOM.div( {className:"image-settings"}, 
                React.DOM.div(null, "Background image:"),
                React.DOM.div(null, "Url: ",
                    React.DOM.input( {type:"text",
                            className:"graph-settings-background-url",
                            ref:"bg-url",
                            defaultValue:this.props.backgroundImage.url,
                            onKeyPress:this.changeBackgroundUrl,
                            onBlur:this.changeBackgroundUrl} ),
                    InfoTip(null, 
                        React.DOM.p(null, "Create an image in graphie, or use the \"Add image\" "+
                        "function to create a background.")
                    )
                ),
                this.props.backgroundImage.url && React.DOM.div(null, 
                    React.DOM.div(null, "Pixels from left: ",
                        React.DOM.input( {type:"text",
                                ref:"bg-left",
                                value:this.props.backgroundImage.left,
                                onInput:
                        _.partial(this.changeBackgroundSetting, "left")} )
                    ),
                    React.DOM.div(null, "Pixels from bottom: ",
                        React.DOM.input( {type:"text",
                                ref:"bg-bottom",
                                value:this.props.backgroundImage.bottom,
                                onInput:
                        _.partial(this.changeBackgroundSetting, "bottom")} )
                    ),
                    React.DOM.div(null, "Image scale: ",
                        React.DOM.input( {type:"text",
                                ref:"bg-scale",
                                value:this.props.backgroundImage.scale,
                                onInput:
                        _.partial(this.changeBackgroundSetting, "scale")} )
                    )
                )
            ),
            React.DOM.div( {className:"misc-settings"}, 
                React.DOM.label(null, 
                    " Show protractor: ",
                    React.DOM.input( {type:"checkbox",
                        checked:this.props.showProtractor,
                        onClick:this.toggleShowProtractor} )
                )
            )
        );
    },

    componentDidMount: function() {
        var changeGraph = this.changeGraph;
        this.changeGraph = _.debounce(_.bind(changeGraph, this), 300);
    },


    validRange: function(range) {
        var numbers = _.every(range, function(num) {
            return _.isFinite(num);
        });
        if (! numbers) {
            return "Range must be a valid number";
        }
        if (range[0] >= range[1]) {
            return "Range must have a higher number on the right";
        }
        return true;
    },

    validateStepValue: function(settings) {
        var step = settings.step;
        var range = settings.range;
        var name = settings.name;
        var minTicks = settings.minTicks;
        var maxTicks = settings.maxTicks;

        if (! _.isFinite(step)) {
            return name + " must be a valid number";
        }
        var nSteps = numSteps(range, step);
        if (nSteps < minTicks) {
            return name + " is too large, there must be at least " +
               minTicks + " ticks.";
        }
        if (nSteps > maxTicks) {
            return name + " is too small, there can be at most " +
               maxTicks + " ticks.";
        }
        return true;
    },

    validSnapStep: function(step, range) {
        return this.validateStepValue({
            step: step,
            range: range,
            name: "Snap step",
            minTicks: 5,
            maxTicks: 60
        });
    },

    validGridStep: function(step, range) {
        return this.validateStepValue({
            step: step,
            range: range,
            name: "Grid step",
            minTicks: 3,
            maxTicks: 60
        });
    },

    validStep: function(step, range) {
        return this.validateStepValue({
            step: step,
            range: range,
            name: "Step",
            minTicks: 3,
            maxTicks: 20
        });
    },

    validateGraphSettings: function(range, step, gridStep, snapStep) {
        var self = this;
        var msg;
        var goodRange = _.every(range, function(range) {
            msg = self.validRange(range);
            return msg === true;
        });
        if (!goodRange) {
            return msg;
        }
        var goodStep = _.every(step, function(step, i) {
            msg = self.validStep(step, range[i]);
            return msg === true;
        });
        if (!goodStep) {
            return msg;
        }
        var goodGridStep = _.every(gridStep, function(gridStep, i) {
            msg = self.validGridStep(gridStep, range[i]);
            return msg === true;
        });
        if (!goodGridStep) {
            return msg;
        }
        var goodSnapStep = _.every(snapStep, function(snapStep, i) {
            msg = self.validSnapStep(snapStep, range[i]);
            return msg === true;
        });
        if (!goodSnapStep) {
            return msg;
        }
        return true;
    },

    changeLabel: function(i, e) {
        var val = e.target.value;
        var labels = this.state.labelsTextbox.slice();
        labels[i] = val;
        this.setState({ labelsTextbox: labels }, this.changeGraph);
    },

    changeRange: function(i, j, e) {
        var val = this.refs["range-" + i + "-" + j].getDOMNode().value;
        var ranges = this.state.rangeTextbox.slice();
        var range = ranges[i] = ranges[i].slice();
        range[j] = val;
        var step = this.state.stepTextbox.slice();
        var gridStep = this.state.gridStepTextbox.slice();
        var snapStep = this.state.snapStepTextbox.slice();
        var scale = Util.scaleFromExtent(range, this.props.box[i]);
        if (this.validRange(range) === true) {
            step[i] = Util.tickStepFromExtent(
                    range, this.props.box[i]);
            gridStep[i] = Util.gridStepFromTickStep(step[i], scale);
            snapStep[i] = gridStep[i] / 2;
        }
        this.setState({
            stepTextbox: step,
            gridStepTextbox: gridStep,
            snapStepTextbox: snapStep,
            rangeTextbox: ranges
        }, this.changeGraph);
    },

    changeStep: function(i, e) {
        var val = this.refs["step-" + i].getDOMNode().value;
        var step = this.state.stepTextbox.slice();
        step[i] = val;
        this.setState({ stepTextbox: step }, this.changeGraph);
    },

    changeSnapStep: function(i, e) {
        var val = this.refs["snap-step-" + i].getValue();
        var snapStep = this.state.snapStepTextbox.slice();
        snapStep[i] = val;
        this.setState({ snapStepTextbox: snapStep },
                this.changeGraph);
    },

    changeGridStep: function(i, e) {
        var val = this.refs["grid-step-" + i].getValue();
        var gridStep = this.state.gridStepTextbox.slice();
        gridStep[i] = val;
        this.setState({
            gridStepTextbox: gridStep,
            snapStepTextbox: _.map(gridStep, function(step) {
                return step / 2;
            })
        }, this.changeGraph);
    },

    changeMarkings: function(e) {
        this.props.onChange({markings: e.target.value});
    },

    changeGraph: function() {
        var labels = this.state.labelsTextbox;
        var range = _.map(this.state.rangeTextbox, function(range) {
            return _.map(range, Number);
        });
        var step = _.map(this.state.stepTextbox, Number);
        var gridStep = this.state.gridStepTextbox;
        var snapStep = this.state.snapStepTextbox;
        var valid = this.validateGraphSettings(range, step, gridStep,
                                                   snapStep);
        if (valid === true) {
            this.props.onChange({
                valid: true,
                labels: labels,
                range: range,
                step: step,
                gridStep: gridStep,
                snapStep: snapStep
            });
        } else {
            this.props.onChange({
                valid: valid
            });
        }
    },

    changeBackgroundUrl: function(e) {
        var self = this;

        // Only continue on blur or "enter"
        if (e.type === "keypress" && e.keyCode !== 13) {
            return;
        }

        var url = self.refs["bg-url"].getDOMNode().value;
        var setUrl = function() {
            var image = _.clone(self.props.backgroundImage);
            image.url = url;
            image.width = img.width;
            image.height = img.height;
            self.props.onChange({
                backgroundImage: image,
                markings: url ? "none" : "graph"
            });
        };
        if (url) {
            var img = new Image();
            img.onload = setUrl;
            img.src = url;
        } else {
            var img = {
                url: url,
                width: 0,
                height: 0
            };
            setUrl();
        }
    },

    changeBackgroundSetting: function(type, e) {
        var image = _.clone(this.props.backgroundImage);
        image[type] = e.target.value;
        this.props.onChange({ backgroundImage: image });
    },

    toggleShowProtractor: function() {
        this.props.onChange({showProtractor: !this.props.showProtractor});
    }

});

module.exports = GraphSettings;


},{"../components/info-tip.jsx":6,"../components/number-input.jsx":7,"../core.js":11,"../util.js":19}],5:[function(require,module,exports){
/** @jsx React.DOM */

require("../core.js");
var Util = require("../util.js");

var defaultBoxSize = 400;
var defaultBackgroundImage = {
    url: null,
    scale: 1,
    bottom: 0,
    left: 0,
};

function numSteps(range, step) {
    return Math.floor((range[1] - range[0]) / step);
}

var Graph = React.createClass({displayName: 'Graph',
    propTypes: {
        box: React.PropTypes.array.isRequired
    },

    getDefaultProps: function() {
        return {
            box: [defaultBoxSize, defaultBoxSize],
            labels: ["x", "y"],
            range: [[-10, 10], [-10, 10]],
            step: [1, 1],
            gridStep: [1, 1],
            snapStep: [0.5, 0.5],
            markings: "graph",
            backgroundImage: defaultBackgroundImage,
            showProtractor: false,
            onNewGraphie: null,
            onClick: null
        };
    },

    render: function() {
        var image = this.props.backgroundImage;
        if (image.url) {
            var preScale = this.props.box[0] / defaultBoxSize;
            var scale = image.scale * preScale;
            var style = {
                bottom: (preScale * image.bottom) + "px",
                left: (preScale * image.left) + "px",
                width: (scale * image.width) + "px",
                height: (scale * image.height) + "px"
            };
            image = React.DOM.img( {style:style, src:image.url} );
        } else {
            image = null;
        }

        return React.DOM.div( {className:"graphie-container"}, 
            image,
            React.DOM.div( {className:"graphie", ref:"graphieDiv"} )
        );
    },

    componentDidMount: function() {
        this._setupGraphie();
    },

    componentDidUpdate: function() {
        // Only setupGraphie once per componentDidUpdate().
        // See explanation in setupGraphie().
        this._hasSetupGraphieThisUpdate = false;
        if (this._shouldSetupGraphie) {
            this._setupGraphie();
            this._shouldSetupGraphie = false;
        }
    },

    componentWillReceiveProps: function(nextProps) {
        var potentialChanges = ["labels", "range", "step", "markings",
            "showProtractor", "gridStep", "snapStep"];
        var self = this;
        _.each(potentialChanges, function(prop) {
            if (!_.isEqual(self.props[prop], nextProps[prop])) {
                self._shouldSetupGraphie = true;
            }
        });
    },

    /* Reset the graphie canvas to its initial state
     *
     * Use when re-rendering the parent component and you need a blank
     * graphie.
     */
    reset: function() {
        this._setupGraphie();
    },

    graphie: function() {
        return this._graphie;
    },

    pointsFromNormalized: function(coordsList, noSnap) {
        var self = this;
        return _.map(coordsList, function(coords) {
            return _.map(coords, function(coord, i) {
                var range = self.props.range[i];
                if (noSnap) {
                    return range[0] + (range[1] - range[0]) * coord;
                } else {
                    var step = self.props.step[i];
                    var nSteps = numSteps(range, step);
                    var tick = Math.round(coord * nSteps);
                    return range[0] + step * tick;
                }
            });
        });
    },

    _setupGraphie: function() {
        // Only setupGraphie once per componentDidUpdate().
        // This prevents this component from rendering graphie
        // and then immediately re-render graphie because its
        // parent component asked it to. This will happen when
        // props on the parent and props on this component both
        // require graphie to be re-rendered.
        if (this._hasSetupGraphieThisUpdate) {
            return;
        }

        var graphieDiv = this.refs.graphieDiv.getDOMNode();
        $(graphieDiv).empty();
        var labels = this.props.labels;
        var range = this.props.range;
        var graphie = this._graphie = KhanUtil.createGraphie(graphieDiv);

        var gridConfig = this._getGridConfig();
        graphie.snap = this.props.snapStep;

        if (this.props.markings === "graph") {
            graphie.graphInit({
                range: range,
                scale: _.pluck(gridConfig, "scale"),
                axisArrows: "<->",
                labelFormat: function(s) { return "\\small{" + s + "}"; },
                gridStep: this.props.gridStep,
                tickStep: _.pluck(gridConfig, "tickStep"),
                labelStep: 1,
                unityLabels: _.pluck(gridConfig, "unityLabel")
            });
            graphie.label([0, range[1][1]], labels[1], "above");
            graphie.label([range[0][1], 0], labels[0], "right");
        } else if (this.props.markings === "grid") {
            graphie.graphInit({
                range: range,
                scale: _.pluck(gridConfig, "scale"),
                gridStep: this.props.gridStep,
                axes: false,
                ticks: false,
                labels: false
            });
        } else if (this.props.markings === "none") {
            graphie.init({
                range: range,
                scale: _.pluck(gridConfig, "scale")
            });
        }

        graphie.addMouseLayer({
            onClick: this.props.onClick
        });

        this._updateProtractor();

        // We set this flag before jumping into our callback
        // to avoid recursing if our callback calls reset() itself
        this._hasSetupGraphieThisUpdate = true;
        if (this.props.onNewGraphie) {
            this.props.onNewGraphie(graphie);
        }
    },

    _getGridConfig: function() {
        var self = this;
        return _.map(self.props.step, function(step, i) {
            return Util.gridDimensionConfig(
                    step,
                    self.props.range[i],
                    self.props.box[i],
                    self.props.gridStep[i]);
        });
    },

    _updateProtractor: function() {
        if (this.protractor) {
            this.protractor.remove();
        }

        if (this.props.showProtractor) {
            var coord = this.pointsFromNormalized([[0.50, 0.05]])[0];
            this.protractor = this._graphie.protractor(coord);
        }
    },

    toJSON: function() {
        return _.pick(this.props, 'range', 'step', 'markings', 'labels',
                      'backgroundImage', 'showProtractor', 'gridStep',
                      'snapStep');
    }
});

module.exports = Graph;


},{"../core.js":11,"../util.js":19}],6:[function(require,module,exports){
/** @jsx React.DOM */

var InfoTip = React.createClass({displayName: 'InfoTip',
    getInitialState: function() {
        return {
            hover: false
        };
    },

    render: function() {
        return React.DOM.span( {className:"perseus-info-tip"}, 
            React.DOM.i( {className:"icon-question-sign",
                onMouseEnter:this.handleMouseEnter,
                onMouseLeave:this.handleMouseLeave} ),
            React.DOM.span( {className:"perseus-info-tip-container",
                    style:{display: this.state.hover ? 'block' : 'none'}}, 
                React.DOM.span( {className:"perseus-info-tip-triangle"}),
                React.DOM.span( {className:"perseus-info-tip-content-container " +
                        "vertical-shadow"}, 
                    this.props.children
                )
            )
        );
    },

    handleMouseEnter: function() {
        this.setState({hover: true});
    },

    handleMouseLeave: function() {
        this.setState({hover: false});
    }
});

module.exports = InfoTip;

},{}],7:[function(require,module,exports){
/** @jsx React.DOM */

require("../core.js");
var Util = require("../util.js");
var knumber = KhanUtil.knumber;

/* If str represents a valid number, return that number.
 * Otherwise, if str is empty and allowEmpty is true, return
 * null.
 * Otherwise, return defaultValue
 */
function numberFromString(str, defaultValue, allowEmpty) {
    if (str === "") {
        return allowEmpty ? null : defaultValue;
    } else {
        var result = Util.firstNumericalParse(str);
        return _.isFinite(result) ? result : defaultValue;
    }
}

var isNumericString = (function() {
    // Specify a result that could only be returned by
    // numberFromString if it was specified as the default
    // null and undefined are less nice because numberFromString
    // could return null if allowEmpty is true, and we want
    // that case to return true here.
    var defaultResult = {};
    return function isNumericString(str, allowEmpty) {
        var result = numberFromString(str, defaultResult, allowEmpty);
        return result !== defaultResult;
    };
})();

// TODO (jack): It would be nice if this did more of the inverse of
// numberFromString, handling fractions and such.
function stringFromNumber(num) {
    return num != null ? String(num) : "";
}

/* An input box that accepts only numbers
 *
 * Calls onChange when a valid number is entered.
 * Reverts to the current value onBlur or on [ENTER]
 * Optionally accepts empty input and sends it to
 * onChange as null
 */
var NumberInput = React.createClass({displayName: 'NumberInput',
    getDefaultProps: function() {
        return {
            allowEmpty: false,
            value: null,
            placeholder: null
        };
    },

    render: function() {
        return React.DOM.input(_.extend({}, this.props, {
            className: "number-input",
            type: "text",
            onChange: this._handleChange,
            onBlur: this._handleBlur,
            onKeyPress: this._handleBlur,
            defaultValue: stringFromNumber(this.props.value),
            value: undefined
        }));
    },

    componentDidUpdate: function(prevProps) {
        if (!knumber.equal(this.getValue(), this.props.value)) {
            this._setValue(this.props.value);
        }
    },

    /* Return true if the empty string is a valid value for our text input
     *
     * This is the case if props.allowEmpty is explicitly specified, or if
     * a placeholder value is specified (which will be returned instead of
     * null in the case of an empty text input)
     */
    _allowEmpty: function() {
        return this.props.allowEmpty || this.props.placeholder != null;
    },

    /* Return the current value of this input
     *
     * Takes into account whether props.allowEmpty is specified (allowing null
     * to be returned in the case of an empty string), and props.placeholder,
     * which will be returned in the case of an empty string otherwise.
     */
    getValue: function() {
        var text = this.getDOMNode().value;
        var num = numberFromString(text, this.props.value, true);
        if (num !== null) {
            return num;
        } else if (this.props.allowEmpty) {
            return null;
        } else if (this.props.placeholder != null) {
            return this.props.placeholder;
        } else {
            return this.props.value;
        }
    },

    /* Set text input focus to this input */
    focus: function() {
        this.getDOMNode().focus();
    },

    _handleChange: function(e) {
        var text = e.target.value;
        if (isNumericString(text, this._allowEmpty())) {
            this.props.onChange(this.getValue());
        }
    },

    // TODO (jack): This should revert to the last valid string
    // rather than the string of the number, to avoid situations
    // like "2/3a" turning into "0.66666666666..."
    _handleBlur: function(e) {
        // Only continue on blur or "enter"
        if (e.type === "keypress" && e.keyCode !== 13) {
            return;
        }

        var text = this.getDOMNode().value;
        if (!isNumericString(text, this._allowEmpty())) {
            this._setValue(this.props.value);
        }
    },

    _setValue: function(val) {
        $(this.getDOMNode()).val(stringFromNumber(val));
    }
});

module.exports = NumberInput;


},{"../core.js":11,"../util.js":19}],8:[function(require,module,exports){
/** @jsx React.DOM */

require("../core.js");

/* A checkbox that syncs its value to props using the
 * renderer's onChange method, and gets the prop name
 * dynamically from its props list
 */
var PropCheckBox = React.createClass({displayName: 'PropCheckBox',
    DEFAULT_PROPS: {
        label: null,
        onChange: null
    },

    getDefaultProps: function() {
        return this.DEFAULT_PROPS;
    },

    propName: function() {
        var propName = _.find(_.keys(this.props), function(localPropName) {
            return !_.has(this.DEFAULT_PROPS, localPropName);
        }, this);

        if (!propName) {
            throw new Error("Attempted to create a PropCheckBox with no " +
                    "prop!");
        }

        return propName;
    },

    render: function() {
        var propName = this.propName();
        return React.DOM.label(null, 
            this.props.label,
            React.DOM.input( {type:"checkbox",
                    checked:this.props[propName],
                    onClick:this.toggle} )
        );
    },

    toggle: function() {
        var propName = this.propName();
        var changes = {};
        changes[propName] = !this.props[propName];
        this.props.onChange(changes);
    }
});

module.exports = PropCheckBox;


},{"../core.js":11}],9:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
require("../renderer.jsx");

var Renderer = Perseus.Renderer;

var PREFIX = "perseus-sortable";


// A placeholder that appears in the sortable whenever an item is dragged.
var Placeholder = React.createClass({displayName: 'Placeholder',
    propTypes: {
        width: React.PropTypes.number.isRequired,
        height: React.PropTypes.number.isRequired
    },

    render: function() {
        var className = [PREFIX + "-card", PREFIX + "-placeholder"].join(" ");
        var style = {width: this.props.width, height: this.props.height};

        if (this.props.margin != null) {
            style.margin = this.props.margin;
        }

        return React.DOM.li( {className:className, style:style} );
    }
});


var STATIC = "static",
    DRAGGING = "dragging",
    ANIMATING = "animating",
    DISABLED = "disabled";

// A draggable item in the sortable. Can be in one of four states:
//     Static:    The item is not being interacted with.
//     Dragging:  The item is being dragged.
//     Animating: The item has been released, and is moving to its destination.
//     Disabled:  The item cannot be interacted with.
//
// Usual flow:      Static -> Dragging -> Animating -> Static
// [Dis|en]abling:  Static|Dragging|Animating -> Disabled -> Static
var Draggable = React.createClass({displayName: 'Draggable',
    propTypes: {
        type: React.PropTypes.oneOf([STATIC, DRAGGING, ANIMATING, DISABLED]),
        content: React.PropTypes.string.isRequired,
        endPosition: React.PropTypes.object.isRequired,
        onRender: React.PropTypes.func.isRequired,
        onMouseDown: React.PropTypes.func.isRequired,
        onMouseMove: React.PropTypes.func.isRequired,
        onMouseUp: React.PropTypes.func.isRequired,
        onAnimationEnd: React.PropTypes.func.isRequired
    },

    getDefaultProps: function() {
        return {
            type: STATIC
        };
    },

    getInitialState: function() {
        return {
            startPosition: {left: 0, top: 0},
            startMouse: {left: 0, top: 0},
            mouse: {left: 0, top: 0}
        };
    },

    getCurrentPosition: function() {
        return {
            left: this.state.startPosition.left +
                  this.state.mouse.left -
                  this.state.startMouse.left,
            top: this.state.startPosition.top +
                 this.state.mouse.top -
                 this.state.startMouse.top
        };
    },

    render: function() {
        var className = [
                PREFIX + "-card",
                PREFIX + "-draggable",
                PREFIX + "-" + this.props.type
            ].join(" ");

        var style = {
            position: "static"
        };

        if (this.props.type === DRAGGING || this.props.type === ANIMATING) {
            _.extend(style, {position: "absolute"}, this.getCurrentPosition());
        }

        if (this.props.width) {
            style.width = this.props.width + 1; // Fix for non-integer widths
        }
        if (this.props.height) {
            style.height = this.props.height;
        }
        if (this.props.margin != null) {
            style.margin = this.props.margin;
        }

        return React.DOM.li(
                    {className:className,
                    style:style,
                    onMouseDown:this.onMouseDown,
                    onTouchStart:this.onMouseDown} , 
            Renderer(
                {content:this.props.content,
                onRender:this.props.onRender} )
        );
    },

    componentDidUpdate: function(prevProps) {
        if (this.props.type === prevProps.type) {
            return;
        }

        if (this.props.type === ANIMATING) {
            // Start animating
            var current = this.getCurrentPosition();
            var duration = 15 * Math.sqrt(
                Math.sqrt(
                    Math.pow(this.props.endPosition.left - current.left, 2) +
                    Math.pow(this.props.endPosition.top - current.top, 2)
                )
            );

            $(this.getDOMNode()).animate(this.props.endPosition, {
                duration: Math.max(duration, 1),
                // Animating -> Static
                complete: this.props.onAnimationEnd
            });
        } else if (this.props.type === STATIC) {
            // Ensure that any animations are done
            $(this.getDOMNode()).finish();
        }
    },

    onMouseDown: function(event) {
        if (this.props.type !== STATIC) {
            return;
        }

        if (!(event.button === 0 ||
                (event.touches != null && event.touches.length === 1))) {
            return;
        }

        event.preventDefault();
        var normalizedEvent = event.touches != null ? event.touches[0] : event;
        var mouse = {
            left: normalizedEvent.pageX,
            top: normalizedEvent.pageY
        };

        this.setState({
            startPosition: $(this.getDOMNode()).position(),
            startMouse: mouse,
            mouse: mouse
        }, function() {
            $(document).on("vmousemove", this.onMouseMove);
            $(document).on("vmouseup", this.onMouseUp);

            // Static -> Dragging
            this.props.onMouseDown();
        });
    },

    onMouseMove: function(event) {
        if (this.props.type !== DRAGGING) {
            return;
        }

        event.preventDefault();
        this.setState({
            mouse: {
                left: event.pageX,
                top: event.pageY
            }
        }, this.props.onMouseMove);
    },

    onMouseUp: function(event) {
        if (this.props.type !== DRAGGING) {
            return;
        }

        event.preventDefault();
        $(document).off("vmousemove", this.onMouseMove);
        $(document).off("vmouseup", this.onMouseUp);

        // Dragging -> Animating
        this.props.onMouseUp();
    }
});


var HORIZONTAL = "horizontal",
    VERTICAL = "vertical";

// The main sortable component.
var Sortable = React.createClass({displayName: 'Sortable',
    propTypes: {
        options: React.PropTypes.array.isRequired,
        layout: React.PropTypes.oneOf([HORIZONTAL, VERTICAL]),
        padding: React.PropTypes.bool,
        disabled: React.PropTypes.bool,
        constraints: React.PropTypes.object,
        onMeasure: React.PropTypes.func,
        margin: React.PropTypes.number
    },

    getDefaultProps: function() {
        return {
            layout: HORIZONTAL,
            padding: true,
            disabled: false,
            constraints: {},
            onMeasure: function() {},
            margin: 5
        };
    },

    getInitialState: function() {
        return {
            items: this.itemsFromProps(this.props)
        };
    },

    componentWillReceiveProps: function(nextProps) {
        var prevProps = this.props;

        if (!_.isEqual(nextProps.options, prevProps.options)) {

            // Regenerate items
            this.setState({
                items: this.itemsFromProps(nextProps)
            });

        } else if (nextProps.layout !== prevProps.layout || 
                   nextProps.padding !== prevProps.padding ||
                   nextProps.disabled !== prevProps.disabled ||
                   !_.isEqual(nextProps.constraints, prevProps.constraints)) {

            // Clear item measurements
            this.setState({
                items: this.clearItemMeasurements(this.state.items)
            });
        }
    },

    componentDidUpdate: function(prevProps) {
        // Measure items if their dimensions have been reset
        if (this.state.items.length && !this.state.items[0].width) {
            this.measureItems();
        }
    },

    itemsFromProps: function(props) {
        var type = props.disabled ? DISABLED : STATIC;
        return _.map(props.options, function(option, i) {
            return {
                option: option,
                key: i,
                type: type,
                endPosition: {},
                width: 0,
                height: 0
            };
        });
    },

    clearItemMeasurements: function(items) {
        return _.map(items, function(item) {
            return _.extend(item, {
                width: 0,
                height: 0
            });
        });
    },

    measureItems: function() {
        // Measure all items and cache what their dimensions should be, taking
        // into account constraints and the current layout. This allows syncing
        // widths and heights for pretty rows/columns. Note that dimensions are
        // explictly set on Draggables - this prevents them from changing size
        // or shape while being dragged.

        var items = _.clone(this.state.items);
        var $items = _.map(items, function(item) {
            return $(this.refs[item.key].getDOMNode());
        }, this);

        var widths = _.invoke($items, "outerWidth");
        var heights = _.invoke($items, "outerHeight");

        var constraints = this.props.constraints;
        var layout = this.props.layout;

        var syncWidth;
        if (constraints.width) {
            // Items must be at least as wide as the specified constraint
            syncWidth = _.max(widths.concat(constraints.width));
        } else if (layout === VERTICAL) {
            // Sync widths to get a clean column
            syncWidth = _.max(widths);
        }

        var syncHeight;
        if (constraints.height) {
            // Items must be at least as high as the specified constraint
            syncHeight = _.max(heights.concat(constraints.height));
        } else if (layout === HORIZONTAL) {
            // Sync widths to get a clean row
            syncHeight = _.max(heights);
        }

        items = _.map(items, function(item, i) {
            item.width = syncWidth || widths[i];
            item.height = syncHeight || heights[i];
            return item;
        });

        this.setState({items: items}, function() {
            this.props.onMeasure({widths: widths, heights: heights});
        }.bind(this));
    },

    remeasureItems: _.debounce(function() {
        this.setState({
            // Clear item measurements
            items: this.clearItemMeasurements(this.state.items)
        }, this.measureItems);
    }, 20),

    render: function() {
        var className = [PREFIX, "layout-" + this.props.layout].join(" ");
        var cards = [];

        className += this.props.padding ? "" : " unpadded";

        _.each(this.state.items, function(item, i, items) {
            var isLast = (i === items.length - 1);
            var isStatic = (item.type === STATIC || item.type === DISABLED);
            var margin;

            if (this.props.layout === HORIZONTAL) {
                margin = "0 " + this.props.margin + "px 0 0"; // right
            } else if (this.props.layout === VERTICAL) {
                margin = "0 0 " + this.props.margin + "px 0"; // bottom
            }

            cards.push(
                Draggable(
                    {content:item.option,
                    key:item.key,
                    type:item.type,
                    ref:item.key,
                    width:item.width,
                    height:item.height,
                    margin:isLast && isStatic ? 0 : margin,
                    endPosition:item.endPosition,
                    onRender:this.remeasureItems,
                    onMouseDown:_.bind(this.onMouseDown, this, item.key),
                    onMouseMove:_.bind(this.onMouseMove, this, item.key),
                    onMouseUp:_.bind(this.onMouseUp, this, item.key),
                    onAnimationEnd:_.bind(this.onAnimationEnd, this, 
                        item.key)} )
            );

            if (item.type === DRAGGING || item.type === ANIMATING) {
                cards.push(
                    Placeholder(
                        {key:"placeholder_" + item.key,
                        ref:"placeholder_" + item.key,
                        width:item.width,
                        height:item.height,
                        margin:isLast ? 0 : margin} )
                );
            }
        }, this);

        return React.DOM.ul( {className:className}, 
            cards
        );
    },

    onMouseDown: function(key) {
        // Static -> Dragging
        var items = _.map(this.state.items, function(item) {
            if (item.key === key) {
                item.type = DRAGGING;
            }
            return item;
        });

        this.setState({items: items});
     },

    onMouseMove: function(key) {
        // Dragging: Rearrange items based on draggable's position
        var $draggable = $(this.refs[key].getDOMNode());
        var $sortable = $(this.getDOMNode());
        var items = _.clone(this.state.items);
        var item = _.findWhere(this.state.items, {key: key});
        var margin = this.props.margin;
        var currentIndex = _.indexOf(items, item);
        var newIndex = 0;

        items.splice(currentIndex, 1);

        if (this.props.layout === HORIZONTAL) {
            var midWidth = $draggable.offset().left - $sortable.offset().left;
            var sumWidth = 0;
            var cardWidth;

            _.each(items, function(item) {
                cardWidth = item.width;
                if (midWidth > sumWidth + cardWidth / 2) {
                    newIndex += 1;
                }
                sumWidth += cardWidth + margin;
            });

        } else {
            var midHeight = $draggable.offset().top - $sortable.offset().top;
            var sumHeight = 0;
            var cardHeight;

            _.each(items, function(item) {
                cardHeight = item.height;
                if (midHeight > sumHeight + cardHeight / 2) {
                    newIndex += 1;
                }
                sumHeight += cardHeight + margin;
            });
        }

        if (newIndex !== currentIndex) {
            items.splice(newIndex, 0, item);
            this.setState({items: items});
        }
    },

    onMouseUp: function(key) {
        // Dragging -> Animating
        var items = _.map(this.state.items, function(item) {
            if (item.key === key) {
                item.type = ANIMATING;
                item.endPosition = $(this.refs["placeholder_" + key]
                                    .getDOMNode()).position();
            }
            return item;
        }, this);

        this.setState({items: items});
    },

    onAnimationEnd: function(key) {
        // Animating -> Static
        var items = _.map(this.state.items, function(item) {
            if (item.key === key) {
                item.type = STATIC;
            }
            return item;
        });

        this.setState({items: items});
    },

    getOptions: function() {
        return _.pluck(this.state.items, "option");
    }
});

module.exports = Sortable;

})(Perseus);

},{"../core.js":11,"../renderer.jsx":17}],10:[function(require,module,exports){
/** @jsx React.DOM */

var textWidthCache = {};
function getTextWidth(text) {
    if (!textWidthCache[text]) {
        // Hacky way to guess the width of an input box
        var $test = $("<span>").text(text).appendTo("body");
        textWidthCache[text] = $test.width() + 5;
        $test.remove();
    }
    return textWidthCache[text];
}


var TextListEditor = React.createClass({displayName: 'TextListEditor',
    propTypes: {
        options: React.PropTypes.array,
        layout: React.PropTypes.string,
        onChange: React.PropTypes.func.isRequired
    },

    getDefaultProps: function() {
        return {
            options: [],
            layout: "horizontal"
        };
    },

    getInitialState: function() {
        return {
            items: this.props.options.concat("")
        };
    },

    render: function() {
        var className = [
            "perseus-text-list-editor",
            "ui-helper-clearfix",
            "layout-" + this.props.layout
        ].join(" ");

        var inputs = _.map(this.state.items, function(item, i) {
            return React.DOM.li( {key:i}, 
                React.DOM.input(
                    {ref:"input_" + i,
                    type:"text",
                    value:item,
                    onChange:this.onChange.bind(this, i),
                    onKeyDown:this.onKeyDown.bind(this, i),
                    style:{width: getTextWidth(item)}} )
            );
        }, this);

        return React.DOM.ul( {className:className}, inputs);
    },

    onChange: function(index, event) {
        var items = _.clone(this.state.items);
        items[index] = event.target.value;

        if (index === items.length - 1) {
            items = items.concat("");
        }

        this.setState({items: items});
        this.props.onChange(_.compact(items));
    },

    onKeyDown: function(index, event) {
        var which = event.nativeEvent.keyCode;

        // Backspace deletes an empty input...
        if (which === 8 /* backspace */ && this.state.items[index] === "") {
            event.preventDefault();

            var items = _.clone(this.state.items);
            var focusIndex = (index === 0) ? 0 : index - 1;

            if (index === items.length - 1 &&
                    (index === 0 || items[focusIndex] !== "")) {
                // ...except for the last one, iff it is the only empty
                // input at the end.
                this.refs["input_" + focusIndex].getDOMNode().focus();
            } else {
                items.splice(index, 1);
                this.setState({items: items}, function() {
                    this.refs["input_" + focusIndex].getDOMNode().focus();
                });                
            }

        // Deleting the last character in the second-to-last input removes it
        } else if (which === 8 /* backspace */ &&
                this.state.items[index].length === 1 &&
                index === this.state.items.length - 2) {
            event.preventDefault();

            var items = _.clone(this.state.items);
            items.splice(index, 1);
            this.setState({items: items});
            this.props.onChange(_.compact(items));

        // Enter adds an option below the current one...
        } else if (which === 13 /* enter */) {
            event.preventDefault();

            var items = _.clone(this.state.items);
            var focusIndex = index + 1;

            if (index === items.length - 2) {
                // ...unless the empty input is just below.
                this.refs["input_" + focusIndex].getDOMNode().focus();
            } else {
                items.splice(focusIndex, 0, "");
                this.setState({items: items}, function() {
                    this.refs["input_" + focusIndex].getDOMNode().focus();
                });
            }
        }
    }
});

module.exports = TextListEditor;

},{}],11:[function(require,module,exports){
(function(undefined) {

var Util = require("./util.js");

var Perseus = window.Perseus = {
    Util: Util
};

Perseus.init = function(options) {
    _.defaults(options, {
        // Pass skipMathJax: true if MathJax is already loaded and configured.
        skipMathJax: false,
        // A function which takes a file object (guaranteed to be an image) and
        // a callback, then calls the callback with the url where the image
        // will be hosted. Image drag and drop is disabled when imageUploader
        // is null.
        imageUploader: null
    });

    var deferred = $.Deferred();

    markedReact.setOptions({
        sanitize: true
    });

    if (options.skipMathJax) {
        deferred.resolve();
    } else {
        MathJax.Hub.Config({
            messageStyle: "none",
            skipStartupTypeset: "none",
            "HTML-CSS": {
                availableFonts: ["TeX"],
                imageFont: null,
                scale: 100,
                showMathMenu: false
            }
        });

        MathJax.Hub.Configured();
        MathJax.Hub.Queue(deferred.resolve);
    }

    Perseus.imageUploader = options.imageUploader;

    return deferred;
};

})();

},{"./util.js":19}],12:[function(require,module,exports){
/** @jsx React.DOM */

require("./core.js");
require("./item-editor.jsx");
require("./item-renderer.jsx");
require("./hint-editor.jsx");

var BlurInput = require("./components/blur-input.jsx");
var PropCheckBox = require("./components/prop-check-box.jsx");

var ItemEditor = Perseus.ItemEditor;
var ItemRenderer = Perseus.ItemRenderer;
var CombinedHintsEditor = Perseus.CombinedHintsEditor;

var JsonEditor = React.createClass({displayName: 'JsonEditor',

    getInitialState: function() {
        return {
            currentValue: JSON.stringify(this.props.value, null, 4),
            valid: true
        };
    },

    componentWillReceiveProps: function(nextProps) {
        var shouldReplaceContent = !this.state.valid ||
            !_.isEqual(
                nextProps.value,
                JSON.parse(this.state.currentValue)
            );

        if (shouldReplaceContent) {
            this.setState(this.getInitialState());
        }
    },

    render: function() {
        var classes = "perseus-json-editor " +
            (this.state.valid ? "valid" : "invalid");

        return React.DOM.textarea(
            {className:classes,
            value:this.state.currentValue,
            onChange:this.handleChange,
            onBlur:this.handleBlur} );
    },

    handleChange: function(e) {
        var nextString = e.target.value;
        try {
            var json = JSON.parse(nextString);
            // Some extra handling to allow copy-pasting from /api/vi
            if (_.isString(json)) {
                json = JSON.parse(json);
            }
            // This callback unfortunately causes multiple renders,
            // but seems to be necessary to avoid componentWillReceiveProps
            // being called before setState has gone through
            this.setState({
                currentValue: nextString,
                valid: true
            }, function() {
                this.props.onChange(json);
            });
        } catch (ex) {
            this.setState({
                currentValue: nextString,
                valid: false
            });
        }
    },

    handleBlur: function(e) {
        var nextString = e.target.value;
        try {
            var json = JSON.parse(nextString);
            // Some extra handling to allow copy-pasting from /api/vi
            if (_.isString(json)) {
                json = JSON.parse(json);
            }
            // This callback unfortunately causes multiple renders,
            // but seems to be necessary to avoid componentWillReceiveProps
            // being called before setState has gone through
            this.setState({
                currentValue: JSON.stringify(json, null, 4),
                valid: true
            }, function() {
                this.props.onChange(json);
            });
        } catch (ex) {
            this.setState({
                currentValue: JSON.stringify(this.props.value, null, 4),
                valid: true
            });
        }
    }
});

Perseus.EditorPage = React.createClass({
    getDefaultProps: function() {
        return {
            developerMode: false,
            jsonMode: false
        };
    },

    getInitialState: function() {
        return {
            json: {
                question: this.props.question,
                answer: this.props.answerArea,
                hints: this.props.hints
            }
        };
    },

    render: function() {

        return React.DOM.div( {id:"perseus", className:"framework-perseus"}, 
            this.props.developerMode &&
                React.DOM.div(null, 
                    React.DOM.label(null, 
                        " Developer JSON Mode: ",
                        React.DOM.input( {type:"checkbox",
                            checked:this.props.jsonMode,
                            onClick:this.toggleJsonMode} )
                    )
                ),
            

            this.props.developerMode && this.props.jsonMode &&
                React.DOM.div(null, 
                    JsonEditor(
                        {multiLine:true,
                        value:this.state.json,
                        onChange:this.changeJSON} )
                ),
            

            (!this.props.developerMode || !this.props.jsonMode) &&
                ItemEditor(
                    {ref:"itemEditor",
                    rendererOnly:this.props.jsonMode,
                    question:this.props.question,
                    answerArea:this.props.answerArea,
                    onChange:this.handleChange} ),
            

            (!this.props.developerMode || !this.props.jsonMode) &&
                CombinedHintsEditor(
                    {ref:"hintsEditor",
                    hints:this.props.hints,
                    onChange:this.handleChange} )
            
        );

    },

    toggleJsonMode: function() {
        this.setState({
            json: this.toJSON(true)
        }, function() {
            this.props.onChange({
                jsonMode: !this.props.jsonMode
            });
        });
    },

    componentDidMount: function() {
        this.rendererMountNode = document.createElement("div");
        this.updateRenderer();
    },

    componentDidUpdate: function() {
        this.updateRenderer();
    },

    updateRenderer: function(cb) {
        if (this.props.jsonMode) {
            return;
        }
        var rendererConfig = _({
            item: this.toJSON(true),
            initialHintsVisible: 0  /* none; to be displayed below */
        }).extend(
            _(this.props).pick("workAreaSelector",
                               "solutionAreaSelector",
                               "hintsAreaSelector",
                               "problemNum")
        );

        this.renderer = React.renderComponent(
            Perseus.ItemRenderer(rendererConfig),
            this.rendererMountNode,
            cb);
    },

    handleChange: function(toChange, cb) {
        var newProps = _(this.props).pick("question", "hints", "answerArea");
        _(newProps).extend(toChange);
        this.props.onChange(newProps, cb);
    },

    changeJSON: function(newJson) {
        this.setState({
            json: newJson,
        });
        this.props.onChange(newJson);
    },

    scorePreview: function() {
        if (this.renderer) {
            return this.renderer.scoreInput();
        } else {
            return null;
        }
    },

    toJSON: function(skipValidation) {
        if (this.props.jsonMode) {
            return this.state.json;
        } else {
            return _.extend(this.refs.itemEditor.toJSON(skipValidation), {
                hints: this.refs.hintsEditor.toJSON()
            });
        }
    }

});

/* Renders an EditorPage as a non-controlled component.
 *
 * Normally the parent of EditorPage must pass it an onChange callback and then
 * respond to any changes by modifying the EditorPage props to reflect those
 * changes. With StatefulEditorPage changes are stored in state so you can
 * query them with toJSON.
 */
Perseus.StatefulEditorPage = React.createClass({
    render: function() {
        return Perseus.EditorPage(this.state);
    },
    getInitialState: function() {
        return _({}).extend(this.props, {
            onChange: this.handleChange,
            ref: "editor"
        });
    },
    // getInitialState isn't called if the react component is re-rendered
    // in-place on the dom, in which case this is called instead, so we
    // need to update the state here.
    // (This component is currently re-rendered by the "Add image" button.)
    componentWillReceiveProps: function(nextProps) {
        this.setState(nextProps);
    },
    toJSON: function() {
        return this.refs.editor.toJSON();
    },
    handleChange: function(newState, cb) {
        this.setState(newState, cb);
    },
    scorePreview: function() {
        return this.refs.editor.scorePreview();
    }
});



},{"./components/blur-input.jsx":3,"./components/prop-check-box.jsx":8,"./core.js":11,"./hint-editor.jsx":14,"./item-editor.jsx":15,"./item-renderer.jsx":16}],13:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("./core.js");
var Util = require("./util.js");

var Widgets = require("./widgets.js");
var PropCheckBox = require("./components/prop-check-box.jsx");

// like [[snowman input-number 1]]
var rWidgetSplit = /(\[\[\u2603 [a-z-]+ [0-9]+\]\])/g;

/* This component makes its children a drag target. Example:
 *
 *     <DragTarget onDrop={this.handleDrop}>Drag to me</DragTarget>
 *
 *     ...
 *
 *     handleDrop: function(e) {
 *         this.addImages(e.nativeEvent.dataTransfer.files);
 *     }
 *
 * Now "Drag to me" will be a drag target - when something is dragged over it,
 * the element will become partially transparent as a visual indicator that
 * it's a target.
 */
// TODO(joel) - indicate before the hover is over the target that it's possible
// to drag into the target. This would (I think) require a high level handler -
// like on Perseus itself, waiting for onDragEnter, then passing down the
// event. Sounds like a pain. Possible workaround - create a div covering the
// entire page...
//
// Other extensions:
// * custom styles for global drag and dragOver
// * only respond to certain types of drags (only images for instance)!
var DragTarget = React.createClass({displayName: 'DragTarget',
    propTypes: {
        onDrop: React.PropTypes.func.isRequired,
        component: React.PropTypes.func
    },
    render: function() {
        // This is the only property of the returned component we need to
        // calculate here because it will be overwritten by transferPropsTo.
        var opacity = this.state.dragHover ? { "opacity": 0.3 } : {};
        var style = _(opacity).extend(this.props.style);

        var component = this.props.component;
        return this.transferPropsTo(
            component( {style:style,
                       onDrop:this.handleDrop,
                       onDragEnd:this.handleDragEnd,
                       onDragOver:this.handleDragOver,
                       onDragEnter:this.handleDragEnter,
                       onDragLeave:this.handleDragLeave}, 
                this.props.children
            )
        );
    },
    getInitialState: function() {
        return { dragHover: false };
    },
    getDefaultProps: function() {
        return { component: React.DOM.div };
    },
    handleDrop: function(e) {
        e.stopPropagation();
        e.preventDefault();
        this.setState({ dragHover: false });
        this.props.onDrop(e);
    },
    handleDragEnd: function() {
        this.setState({ dragHover: false });
    },
    handleDragOver: function(e) {
        e.preventDefault();
    },
    handleDragLeave: function() {
        this.setState({ dragHover: false });
    },
    handleDragEnter: function() {
        this.setState({ dragHover: true });
    }
});


var WidgetEditor = React.createClass({displayName: 'WidgetEditor',
    getDefaultProps: function() {
        return {
            graded: true
        };
    },

    render: function() {
        var cls = Widgets.get(this.props.type + "-editor");

        var isUngradedEnabled = (this.props.type === "transformer");

        return React.DOM.div(null, 
            React.DOM.div(null, 
                React.DOM.strong(null, this.props.id)
            ),
            React.DOM.div(null, 
                isUngradedEnabled &&
                    PropCheckBox(
                        {label:"Graded:",
                        graded:this.props.graded,
                        onChange:this.props.onChange} )
                
            ),
            cls(_.extend({
                ref: "widget",
                onChange: this._handleWidgetChange
            }, this.props.options))
        );
    },

    _handleWidgetChange: function(newProps, cb) {
        this.props.onChange({
            options: _.extend({}, this.props.options, newProps)
        }, cb);
    },

    toJSON: function(skipValidation) {
        return {
            type: this.props.type,
            graded: this.props.graded,
            options: this.refs.widget.toJSON(skipValidation)
        };
    }
});

var Editor = Perseus.Editor = React.createClass({
    getDefaultProps: function() {
        return {
            content: "",
            widgets: {},
            widgetEnabled: true,
            immutableWidgets: false
        };
    },

    componentDidUpdate: function(prevProps, prevState, rootNode) {
        // TODO(alpert): Maybe fix React so this isn't necessary
        var textarea = this.refs.textarea.getDOMNode();
        textarea.value = this.props.content;
    },

    getWidgetEditor: function(id, type) {
        if (!Widgets.get(type + "-editor")) {
            return;
        }
        return WidgetEditor(_.extend({
            ref: id,
            id: id,
            type: type,
            onChange: _.bind(this._handleWidgetEditorChange, this, id)
        }, this.props.widgets[id]));
    },

    _handleWidgetEditorChange: function(id, newProps, cb) {
        var widgets = _.clone(this.props.widgets);
        widgets[id] = _.extend({}, widgets[id], newProps);
        this.props.onChange({widgets: widgets}, cb);
    },

    render: function() {
        var pieces;
        var widgets;
        var underlayPieces;
        var widgetsDropDown;
        var templatesDropDown;
        var widgetsAndTemplates;

        if (this.props.widgetEnabled) {
            pieces = Util.split(this.props.content, rWidgetSplit);
            widgets = {};
            underlayPieces = [];

            for (var i = 0; i < pieces.length; i++) {
                var type = i % 2;
                if (type === 0) {
                    // Normal text
                    underlayPieces.push(pieces[i]);
                } else {
                    // Widget reference
                    var match = Util.rWidgetParts.exec(pieces[i]);
                    var id = match[1];
                    var type = match[2];

                    var selected = false;
                    // TODO(alpert):
                    // var selected = focused && selStart === selEnd &&
                    //         offset <= selStart &&
                    //         selStart < offset + text.length;
                    // if (selected) {
                    //     selectedWidget = id;
                    // }

                    var duplicate = id in widgets;

                    widgets[id] = this.getWidgetEditor(id, type);
                    var classes = (duplicate || !widgets[id] ? "error " : "") +
                            (selected ? "selected " : "");
                    underlayPieces.push(
                            React.DOM.b( {className:classes}, pieces[i]));
                }
            }

            // TODO(alpert): Move this to the content-change event handler
            // _.each(_.keys(this.props.widgets), function(id) {
            //     if (!(id in widgets)) {
            //         // It's strange if these preloaded options stick around
            //         // since it's inconsistent with how things work if you
            //         // don't have the serialize/deserialize step in the
            //         // middle
            //         // TODO(alpert): Save options in a consistent manner so
            //         // that you can undo the deletion of a widget
            //         delete this.props.widgets[id];
            //     }
            // }, this);

            this.widgetIds = _.keys(widgets);
            widgetsDropDown =  React.DOM.select( {onChange:this.addWidget}, 
                React.DOM.option( {value:""}, "Add a widget","\u2026"),
                React.DOM.option( {disabled:true}, "--"),
                React.DOM.option( {value:"input-number"}, 
                        " Text input (number)"),
                React.DOM.option( {value:"expression"}, 
                        " Expression / Equation"),
                React.DOM.option( {value:"radio"}, 
                        " Multiple choice"),
                React.DOM.option( {value:"interactive-graph"}, 
                        " Interactive graph"),
                React.DOM.option( {value:"interactive-number-line"}, 
                        " Interactive number line"),
                React.DOM.option( {value:"categorization"}, 
                        " Categorization"),
                React.DOM.option( {value:"plotter"}, 
                        " Plotter"),
                React.DOM.option( {value:"table"}, 
                        " Table of values"),
                React.DOM.option( {value:"dropdown"}, 
                        " Drop down"),
                React.DOM.option( {value:"orderer"}, 
                        " Orderer"),
                React.DOM.option( {value:"protractor"}, 
                        " Protractor"),
                React.DOM.option( {value:"transformer"}, 
                        " Transformer"),
                React.DOM.option( {value:"matcher"}, 
                        " Two column matcher"),
                React.DOM.option( {value:"sorter"}, 
                        " Sorter")
            );

            templatesDropDown = React.DOM.select( {onChange:this.addTemplate}, 
                React.DOM.option( {value:""}, "Insert template","\u2026"),
                React.DOM.option( {disabled:true}, "--"),
                React.DOM.option( {value:"table"}, "Table"),
                React.DOM.option( {value:"alignment"}, "Aligned equations"),
                React.DOM.option( {value:"piecewise"}, "Piecewise function")
            );

            if (!this.props.immutableWidgets) {
                widgetsAndTemplates = React.DOM.div( {className:"perseus-editor-widgets"}, 
                    React.DOM.div(null, 
                        widgetsDropDown,
                        templatesDropDown
                    ),
                    widgets
                );
            }
        } else {
            underlayPieces = [this.props.content];
        }

        // Without this, the underlay isn't the proper size when the text ends
        // with a newline.
        underlayPieces.push(React.DOM.br(null ));

        // If an image uploader was supplied in the config, make the editor a
        // drag target, otherwise it's just a div.
        var container = Perseus.imageUploader ? DragTarget : React.DOM.div;

        var completeTextarea = [
                React.DOM.div( {className:"perseus-textarea-underlay", ref:"underlay"}, 
                    underlayPieces
                ),
                React.DOM.textarea( {ref:"textarea",
                          onInput:this.handleInput,
                          value:this.props.content} )
            ];
        var textareaWrapper;
        if (Perseus.imageUploader) {
            textareaWrapper = DragTarget( {onDrop:this.handleDrop,
                                     className:"perseus-textarea-pair"}, 
                completeTextarea
            );
        } else {
            textareaWrapper = React.DOM.div( {className:"perseus-textarea-pair"}, 
                completeTextarea
            );
        }

        return React.DOM.div( {className:"perseus-single-editor " +
                (this.props.className || "")}, 
            textareaWrapper,
            widgetsAndTemplates
        );
    },

    handleDrop: function(e) {
        var files = e.nativeEvent.dataTransfer.files;
        var content = this.props.content;
        var self = this;

        /* For each file we make sure it's an image, then create a sentinel -
         * snowman + identifier to insert into the current text. The sentinel
         * only lives there temporarily until we get a response back from the
         * server that the image is now hosted on AWS, at which time we replace
         * the temporary sentinel with the permanent url for the image.
         *
         * There is an abuse of tap in the middle of the pipeline to make sure
         * everything is sequenced in the correct order. We want to modify the
         * content (given any number of images) at the same time, i.e. only
         * once, so we do that step with the tap. After the content has been
         * changed we send off the request for each image.
         *
         * Note that the snowman doesn't do anything special in this case -
         * it's effectively just part of a broken link. Perseus could be
         * extended to recognize this sentinel and highlight it like for
         * widgets.
         */
        _(files)
            .chain()
            .map(function(file) {
                if (!file.type.match('image.*')) {
                    return null;
                }

                var sentinel = "\u2603 " + _.uniqueId("image_");
                // TODO(joel) - figure out how to temporarily include the image
                // before the server returns.
                content += "\n\n![](" + sentinel + ")";

                return { file: file, sentinel: sentinel };
            })
            .reject(_.isNull)
            .tap(function() {
                self.props.onChange({ content: content });
            })
            .each(function(fileAndSentinel) {
                Perseus.imageUploader(fileAndSentinel.file, function(url) {
                    self.props.onChange({
                        content: self.props.content.replace(
                            fileAndSentinel.sentinel, url)
                    });
                });
            });
    },

    handleInput: function() {
        var textarea = this.refs.textarea.getDOMNode();
        this.props.onChange({content: textarea.value});
    },

    addWidget: function(e) {
        var widgetType = e.target.value;
        if (widgetType === "") {
            // TODO(alpert): Not sure if change will trigger here
            // but might as well be safe
            return;
        }
        e.target.value = "";

        var oldContent = this.props.content;

        // Add newlines before "big" widgets like graphs
        if (widgetType !== "input-number" && widgetType !== "dropdown") {
            oldContent = oldContent.replace(/\n*$/, "\n\n");
        }

        for (var i = 1; oldContent.indexOf("[[\u2603 " + widgetType + " " + i +
                "]]") > -1; i++) {
            // pass
        }

        var id = widgetType + " " + i;
        var newContent = oldContent + "[[\u2603 " + id + "]]";

        var widgets = _.clone(this.props.widgets);
        widgets[id] = {type: widgetType};
        this.props.onChange({
            content: newContent,
            widgets: widgets
        }, this.focusAndMoveToEnd);
    },

    addTemplate: function(e) {
        var templateType = e.target.value;
        if (templateType === "") {
            return;
        }
        e.target.value = "";

        var oldContent = this.props.content;

        // Force templates to have a blank line before them,
        // as they are usually used as block elements
        // (especially important for tables)
        oldContent = oldContent.replace(/\n*$/, "\n\n");

        var template;
        if (templateType === "table") {
            template = "header 1 | header 2 | header 3\n" +
                       "- | - | -\n" +
                       "data 1 | data 2 | data 3\n" +
                       "data 4 | data 5 | data 6\n" +
                       "data 7 | data 8 | data 9";
        } else if (templateType === "alignment") {
            template = "$\\begin{align} x+5 &= 30 \\\\\n" +
                       "x+5-5 &= 30-5 \\\\\n" +
                       "x &= 25 \\end{align}$";
        } else if (templateType === "piecewise") {
            template = "$f(x) = \\begin{cases}\n" +
                       "7 & \\text{if $x=1$} \\\\\n" +
                       "f(x-1)+5 & \\text{if $x > 1$}\n" +
                       "\\end{cases}$";
        } else {
            throw new Error("Invalid template type: " + templateType);
        }

        var newContent = oldContent + template;

        this.props.onChange({content: newContent}, this.focusAndMoveToEnd);
    },

    toJSON: function(skipValidation) {
        // Could be _.pick(this.props, "content", "widgets"); but validation!
        var widgets = {};
        var widgetIds = _.intersection(this.widgetIds, _.keys(this.refs));

        _.each(widgetIds, function(id) {
            widgets[id] = this.refs[id].toJSON(skipValidation);
        }, this);

        return {
            content: this.props.content,
            widgets: widgets
        };
    },

    focus: function() {
        this.refs.textarea.getDOMNode().focus();
    },

    focusAndMoveToEnd: function() {
        this.focus();
        var textarea = this.refs.textarea.getDOMNode();
        textarea.selectionStart = textarea.value.length;
        textarea.selectionEnd = textarea.value.length;
    }
});
})(Perseus);

},{"./components/prop-check-box.jsx":8,"./core.js":11,"./util.js":19,"./widgets.js":20}],14:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

/* Collection of classes for rendering the hint editor area,
 * hint editor boxes, and hint previews
 */

require("./core.js");
require("./renderer.jsx");
require("./editor.jsx");

var Renderer = Perseus.Renderer;
var Editor = Perseus.Editor;

/* Renders just a hint preview */
var HintRenderer = Perseus.HintRenderer = React.createClass({
    render: function() {
        var shouldBold = this.props.bold;
        var hint = this.props.hint;
        var classNames;
        if (shouldBold) {
            classNames = "perseus-hint-renderer last-hint";
        } else {
            classNames = "perseus-hint-renderer";
        }
        return React.DOM.div( {className:classNames}, 
            Renderer( {content:this.props.hint.content || ""} )
        );
    }
});

/* Renders a hint editor box
 *
 * This includes:
 *  ~ the textarea for the hint
 *  ~ the "remove this hint" box
 *  ~ the move hint up/down arrows
 */
var HintEditor = Perseus.HintEditor = React.createClass({
    getDefaultProps: function() {
        return {
            content: ""
        };
    },

    render: function() {
        return React.DOM.div( {className:"perseus-hint-editor perseus-editor-left-cell"}, 
            Editor( {ref:"editor", content:this.props.content,
                    onChange:this.props.onChange, widgetEnabled:false} ),

            React.DOM.div( {className:"hint-controls-container clearfix"}, 
                React.DOM.span( {className:"reorder-hints"}, 
                    React.DOM.a( {href:"#",
                        className:this.props.isLast && "hidden",
                        onClick:function() {
                            this.props.onMove(1);
                            return false;
                        }.bind(this)}, 
                        React.DOM.span( {className:"icon-circle-arrow-down"} )
                    ),
                    ' ',
                    React.DOM.a( {href:"#",
                        className:this.props.isFirst && "hidden",
                        onClick:function() {
                            this.props.onMove(-1);
                            return false;
                        }.bind(this)}, 
                        React.DOM.span( {className:"icon-circle-arrow-up"} )
                    )
                ),
                React.DOM.a( {href:"#", className:"remove-hint simple-button orange",
                        onClick:function() {
                            this.props.onRemove();
                            return false;
                        }.bind(this)}, 
                    React.DOM.span( {className:"icon-trash"} ), " Remove this hint "
                )
            )
        );
    },

    focus: function() {
        this.refs.editor.focus();
    },

    toJSON: function(skipValidation) {
        return this.refs.editor.toJSON(skipValidation);
    }
});


/* A single hint-row containing a hint editor and preview */
var CombinedHintEditor = React.createClass({displayName: 'CombinedHintEditor',
    render: function() {
        var shouldBold = this.props.isLast &&
                         !(/\*\*/).test(this.props.hint.content);
        return React.DOM.div( {className:"perseus-combined-hint-editor " +
                    "perseus-editor-row"}, 
            HintEditor(
                {ref:"editor",
                isFirst:this.props.isFirst,
                isLast:this.props.isLast,
                content:this.props.hint.content,
                onChange:this.props.onChange,
                onRemove:this.props.onRemove,
                onMove:this.props.onMove} ),

            React.DOM.div( {className:"perseus-editor-right-cell"}, 
                HintRenderer( {hint:this.props.hint, bold:shouldBold} )
            )
        );
    },

    toJSON: function(skipValidation) {
        return this.refs.editor.toJSON(skipValidation);
    },

    focus: function() {
        this.refs.editor.focus();
    }
});


/* A cell in the hints table with content appearing in the left column
 *
 * Simplifies having to set up the table rows and cells manually
 * Used for the "Hints:" prompt and "Add a hint" button
 */
var LeftColumnHintsTableCell = React.createClass({displayName: 'LeftColumnHintsTableCell',
    getDefaultProps: function() {
        return {
            className: ""
        };
    },

    render: function() {
        return React.DOM.div( {className:"perseus-editor-row"}, 
            React.DOM.div( {className:this.props.className +
                    " perseus-editor-left-cell"}, 
                this.props.children
            ),
            React.DOM.div( {className:"perseus-editor-right-cell"} )
        );
    }
});


/* The entire hints editing/preview area
 *
 * Includes:
 *  ~ The "Hints:" prompt
 *  ~ All the hint edit boxes, move and remove buttons
 *  ~ All the hint previews
 *  ~ The "add a hint" button
 */
var CombinedHintsEditor = Perseus.CombinedHintsEditor = React.createClass({
    getDefaultProps: function() {
        return {
            onChange: function() {},
            hints: []
        };
    },

    render: function() {
        var hints = this.props.hints;
        var hintElems = _.map(hints, function(hint, i) {
            return CombinedHintEditor(
                        {ref:"hintEditor" + i,
                        key:"hintEditor" + i,
                        isFirst:i === 0,
                        isLast:i + 1 === hints.length,
                        hint:hint,
                        onChange:this.handleHintChange.bind(this, i),
                        onRemove:this.handleHintRemove.bind(this, i),
                        onMove:this.handleHintMove.bind(this, i)} );
        }, this);

        return React.DOM.div( {className:"perseus-hints-container perseus-editor-table"}, 
            LeftColumnHintsTableCell( {className:"perseus-hints-title"}, 
                " Hints: "
            ),

            hintElems,

            LeftColumnHintsTableCell( {className:"add-hint-container"}, 
                React.DOM.a( {href:"#", className:"simple-button orange",
                        onClick:this.addHint}, 
                    React.DOM.span( {className:"icon-plus"} ),
                    " Add a hint "
                )
            )
        );
    },

    handleHintChange: function(i, newProps, cb) {
        var hints = _(this.props.hints).clone();
        _(hints[i]).extend(newProps);
        this.props.onChange({hints: hints}, cb);
    },

    handleHintRemove: function(i) {
        var hints = _(this.props.hints).clone();
        hints.splice(i, 1);
        this.props.onChange({hints: hints});
    },

    handleHintMove: function(i, dir) {
        var hints = _(this.props.hints).clone();
        var hint = hints.splice(i, 1)[0];
        hints.splice(i + dir, 0, hint);
        this.props.onChange({hints: hints}, function() {
            this.refs["hintEditor" + (i + dir)].focus();
        }.bind(this));
    },

    addHint: function() {
        var hints = _(this.props.hints).clone().concat([{ content: "" }]);
        this.props.onChange({hints: hints}, function() {
            var i = hints.length - 1;
            this.refs["hintEditor" + i].focus();
        }.bind(this));

        // TODO(joel) - is this doing anything?
        return false;
    },

    toJSON: function(skipValidation) {
        return this.props.hints.map(function(hint, i) {
            return this.refs["hintEditor" + i].toJSON(skipValidation);
        }, this);
    }
});

})(Perseus);

},{"./core.js":11,"./editor.jsx":13,"./renderer.jsx":17}],15:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("./core.js");
require("./editor.jsx");
require("./answer-area-editor.jsx");

var Editor = Perseus.Editor;

var AnswerAreaEditor = Perseus.AnswerAreaEditor;

var ItemEditor = Perseus.ItemEditor = React.createClass({
    getDefaultProps: function() {
        return {
            onChange: function() {},
            question: {},
            answerArea: {}
        };
    },

    // Notify the parent that the question or answer area has been updated.
    updateProps: function(newProps, cb) {
        var props = _(this.props).pick("question", "answerArea");
        this.props.onChange(_(props).extend(newProps), cb);
    },

    render: function() {
        return React.DOM.div( {className:"perseus-editor-table"}, 
            React.DOM.div( {className:"perseus-editor-row perseus-question-container"}, 
                React.DOM.div( {className:"perseus-editor-left-cell"}, 
                    Editor(_.extend({
                        ref: "questionEditor",
                        className: "perseus-question-editor",
                        onChange: function(newProps, cb) {
                            var question = _.extend({},
                                    this.props.question, newProps);
                            this.updateProps({question: question}, cb);
                        }.bind(this)
                    }, this.props.question))
                ),

                React.DOM.div( {className:"perseus-editor-right-cell"}, 
                    React.DOM.div( {id:"problemarea"}, 
                        React.DOM.div( {id:"workarea", className:"workarea"} ),
                        React.DOM.div( {id:"hintsarea",
                             className:"hintsarea",
                             style:{display: "none"}} )
                    )
                )
            ),

            React.DOM.div( {className:"perseus-editor-row perseus-answer-container"}, 
                React.DOM.div( {className:"perseus-editor-left-cell"}, 
                    AnswerAreaEditor(_.extend({
                        ref: "answerAreaEditor",
                        onChange: function(newProps, cb) {
                            var answerArea = _.extend({},
                                    this.props.answerArea, newProps);
                            this.updateProps({answerArea: answerArea}, cb);
                        }.bind(this)
                    }, this.props.answerArea))
                ),

                React.DOM.div( {className:"perseus-editor-right-cell"}, 
                    React.DOM.div( {id:"answer_area"}, 
                        React.DOM.span( {id:"examples-show", style:{display: "none"}}, 
                            " Acceptable formats "
                        ),
                        React.DOM.div( {id:"solutionarea", className:"solutionarea"} ),
                        React.DOM.div( {className:"answer-buttons"}, 
                            React.DOM.input(
                                {type:"button",
                                className:"simple-button disabled green",
                                value:"Check Answer"} )
                        )
                    )
                )
            )
        );
    },

    toJSON: function(skipValidation) {
        return {
            question: this.refs.questionEditor.toJSON(skipValidation),
            answerArea: this.refs.answerAreaEditor.toJSON(skipValidation)
        };
    },

    focus: function() {
        this.questionEditor.focus();
    }
});

})(Perseus);

},{"./answer-area-editor.jsx":2,"./core.js":11,"./editor.jsx":13}],16:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("./core.js");
require("./answer-area-editor.jsx");
require("./hint-editor.jsx");
require("./renderer.jsx");
require("./all-widgets.js");
var Util = require("./util.js");

var AnswerAreaRenderer = Perseus.AnswerAreaRenderer;

var HintRenderer = Perseus.HintRenderer;

var HintsRenderer = React.createClass({displayName: 'HintsRenderer',
    render: function() {
        var hintsVisible = this.props.hintsVisible;
        var hints = this.props.hints
            .slice(0, hintsVisible === -1 ? undefined : hintsVisible)
            .map(function(hint, i) {
                var shouldBold = i === this.props.hints.length - 1 &&
                                 !(/\*\*/).test(hint.content);
                return HintRenderer(
                            {bold:shouldBold,
                            hint:hint,
                            key:"hintRenderer" + i} );
            }, this);

        return React.DOM.div(null, hints);
    }
});

var ItemRenderer = Perseus.ItemRenderer = React.createClass({
    getDefaultProps: function() {
        return {
            initialHintsVisible: 0,

            // TODO(joel) - handle this differently. Pass around nodes or
            // something half reasonable.
            workAreaSelector: "#workarea",
            solutionAreaSelector: "#solutionarea",
            hintsAreaSelector: "#hintsarea"
        };
    },

    getInitialState: function() {
        return {
            hintsVisible: this.props.initialHintsVisible
        };
    },

    componentDidMount: function() {
        this.update();
    },

    componentDidUpdate: function() {
        this.update();
    },

    update: function() {
        // Since the item renderer works by rendering things into three divs
        // that have completely different places in the DOM, we have to do this
        // strangeness instead of relying on React's normal render() method.
        // TODO(alpert): Figure out how to clean this up somehow
        this.questionRenderer = React.renderComponent(
                Perseus.Renderer(_.extend({
                    problemNum: this.props.problemNum
                }, this.props.item.question)),
                document.querySelector(this.props.workAreaSelector));

        this.answerAreaRenderer = React.renderComponent(
                AnswerAreaRenderer({
                    type: this.props.item.answerArea.type,
                    options: this.props.item.answerArea.options,
                    calculator: this.props.item.answerArea.calculator || false,
                    problemNum: this.props.problemNum
                }),
                document.querySelector(this.props.solutionAreaSelector));

        this.hintsRenderer = React.renderComponent(
                HintsRenderer({
                    hints: this.props.item.hints,
                    hintsVisible: this.state.hintsVisible
                }),
                document.querySelector(this.props.hintsAreaSelector));

        if (Khan.scratchpad) {
            if (_.isEmpty(this.props.item.question.widgets)) {
                Khan.scratchpad.enable();
            } else {
                Khan.scratchpad.disable();
            }
        }
    },

    render: function() {
        return React.DOM.div(null );
    },

    focus: function() {
        return this.questionRenderer.focus() ||
                this.answerAreaRenderer.focus();
    },

    componentWillUnmount: function() {
        React.unmountComponentAtNode(
                document.querySelector(this.props.workAreaSelector));
        React.unmountComponentAtNode(
                document.querySelector(this.props.solutionAreaSelector));
        React.unmountComponentAtNode(
                document.querySelector(this.props.hintsAreaSelector));
    },

    showHint: function() {
        if (this.state.hintsVisible < this.getNumHints()) {
            this.setState({
                hintsVisible: this.state.hintsVisible + 1
            });
        }
    },

    getNumHints: function() {
        return this.props.item.hints.length;
    },

    scoreInput: function() {
        var qGuessAndScore = this.questionRenderer.guessAndScore();
        var aGuessAndScore = this.answerAreaRenderer.guessAndScore();

        var qGuess = qGuessAndScore[0], qScore = qGuessAndScore[1];
        var aGuess = aGuessAndScore[0], aScore = aGuessAndScore[1];

        var guess, score;
        if (qGuess.length === 0) {
            // No widgets in question. For compatability with old guess format,
            // leave it out here completely.
            guess = aGuess;
            score = aScore;
        } else {
            guess = [qGuess, aGuess];
            score = Util.combineScores(qScore, aScore);
        }

        if (score.type === "points") {
            return {
                empty: false,
                correct: score.earned >= score.total,
                message: score.message,
                guess: guess
            };
        } else if (score.type === "invalid") {
            return {
                empty: true,
                correct: false,
                message: score.message,
                guess: guess
            };
        }
    }
});

})(Perseus);

},{"./all-widgets.js":1,"./answer-area-editor.jsx":2,"./core.js":11,"./hint-editor.jsx":14,"./renderer.jsx":17,"./util.js":19}],17:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("./core.js");
var Util = require("./util.js");

var TeX = require("./tex.jsx");
var Widgets = require("./widgets.js");

var Renderer = Perseus.Renderer = React.createClass({

    componentWillReceiveProps: function(nextProps) {
        if (!_.isEqual(this.props, nextProps)) {
            // TODO(jack): Investigate why this is happening when
            // a hint is taken, and stop resetting the widgets in
            // that circumstance, either by making this check more
            // lenient, or by not modifying the answer area's
            // renderer props when that happens.
            this.setState({widgets: {}});
        }
    },

    getDefaultProps: function() {
        return {
            content: "",
            ignoreMissingWidgets: false,
            // onRender may be called multiple times per render, for example
            // if there are multiple images or TeX pieces within `content`.
            // It is a good idea to debounce any functions passed here.
            onRender: function() {}
        };
    },

    getInitialState: function() {
        // TODO(alpert): Move up to parent props?
        return {
            widgets: {}
        };
    },

    shouldComponentUpdate: function(nextProps, nextState) {
        var stateChanged = !_.isEqual(this.state, nextState);
        var propsChanged = !_.isEqual(this.props, nextProps);
        return propsChanged || stateChanged;
    },

    getPiece: function(saved, widgetIds) {
        if (saved.charAt(0) === "@") {
            // Just text
            return saved;
        } else if (saved.charAt(0) === "$") {
            // Math
            var tex = saved.slice(1, saved.length - 1);
            return TeX( {onRender:this.props.onRender}, tex);
        } else if (saved.charAt(0) === "[") {
            // Widget
            var match = Util.rWidgetParts.exec(saved);
            var id = match[1];
            var type = match[2];

            var widgetInfo = (this.props.widgets || {})[id];
            if (widgetInfo || this.props.ignoreMissingWidgets) {
                widgetIds.push(id);
                var cls = Widgets.get(type);

                return cls(_.extend({
                    ref: id,
                    onChange: function(newProps, cb) {
                        var widgets = _.clone(this.state.widgets);
                        widgets[id] = _.extend({}, widgets[id], newProps);
                        this.setState({widgets: widgets}, cb);
                    }.bind(this)
                }, (widgetInfo || {}).options, this.state.widgets[id],
                _.pick(this.props, "problemNum")));
            }
        }
    },

    render: function() {
        var self = this;
        var extracted = extractMathAndWidgets(this.props.content);
        var markdown = extracted[0];
        var savedMath = extracted[1];
        var widgetIds = this.widgetIds = [];

        // XXX(alpert): smartypants gets called on each text node before it's
        // added to the DOM tree, so we override it to insert the math and
        // widgets.
        var smartypants = markedReact.InlineLexer.prototype.smartypants;
        markedReact.InlineLexer.prototype.smartypants = function(text) {
            var pieces = Util.split(text, /@@(\d+)@@/g);
            for (var i = 0; i < pieces.length; i++) {
                var type = i % 2;
                if (type === 0) {
                    pieces[i] = smartypants.call(this, pieces[i]);
                } else if (type === 1) {
                    // A saved math-or-widget number
                    pieces[i] = self.getPiece(savedMath[pieces[i]], widgetIds);
                }
            }
            return pieces;
        };

        try {
            return React.DOM.div(null, markedReact(markdown));
        } catch (e) {
            // IE8 requires `catch` in order to use `finally`
            throw e;
        } finally {
            markedReact.InlineLexer.prototype.smartypants = smartypants;
        }
    },

    handleRender: function() {
        var onRender = this.props.onRender;

        // Fire callback on image load...
        $(this.getDOMNode()).find("img").on("load", onRender);

        // ...as well as right now (non-image, non-TeX or image from cache)
        onRender();
    },

    componentDidMount: function() {
        this.handleRender();
    },

    componentDidUpdate: function() {
        this.handleRender();
    },

    focus: function() {
        // Use _.some to break if any widget gets focused
        var focused = _.some(this.widgetIds, function(id) {
            var widget = this.refs[id];
            return widget.focus && widget.focus();
        }, this);

        if (focused) {
            return true;
        }
    },

    toJSON: function(skipValidation) {
        var state = {};
        _.each(this.props.widgets, function(props, id) {
            var widget = this.refs[id];
            var s = widget.toJSON(skipValidation);
            if (!_.isEmpty(s)) {
                state[id] = s;
            }
        }, this);
        return state;
    },

    guessAndScore: function() {
        var widgetProps = this.props.widgets;

        var totalGuess = _.map(this.widgetIds, function(id) {
            return this.refs[id].toJSON();
        }, this);

        var totalScore = _.chain(this.widgetIds)
                .filter(function(id) {
                    var props = widgetProps[id];
                    // props.graded is unset or true
                    return props.graded == null || props.graded;
                })
                .map(function(id) {
                    var props = widgetProps[id];
                    var widget = this.refs[id];
                    return widget.simpleValidate(props.options);
                }, this)
                .reduce(Util.combineScores, Util.noScore)
                .value();

        return [totalGuess, totalScore];
    },

    examples: function() {
        var widgets = _.values(this.refs);
        var examples = _.compact(_.map(widgets, function(widget) {
            return widget.examples ? widget.examples() : null;
        }));

        // no widgets with examples
        if (!examples.length) {
            return null;
        }

        var allEqual = _.all(examples, function(example) {
            return _.isEqual(examples[0], example);
        });

        // some widgets have different examples
        // TODO(alex): handle this better
        if (!allEqual) {
            return null;
        }

        return examples[0];
    }
});

var rInteresting =
        /(\$|[{}]|\\[\\${}]|\n{2,}|\[\[\u2603 [a-z-]+ [0-9]+\]\]|@@\d+@@)/g;

function extractMathAndWidgets(text) {
    // "$x$ is a cool number, just like $6 * 7$!" gives
    //     ["@@0@@ is a cool number, just like @@1@@!", ["$x$", "$6 * 7$"]]
    //
    // Inspired by http://stackoverflow.com/q/11231030.
    var savedMath = [];
    var blocks = Util.split(text, rInteresting);

    var mathPieces = [], l = blocks.length, block, braces;
    for (var i = 0; i < l; i++) {
        block = blocks[i];

        if (mathPieces.length) {
            // Looking for an end delimeter
            mathPieces.push(block);
            blocks[i] = "";

            if (block === "$" && braces <= 0) {
                blocks[i] = saveMath(mathPieces.join(""));
                mathPieces = [];
            } else if (block.slice(0, 2) === "\n\n" || i === l - 1) {
                // We're at the end of a line... just don't do anything
                // TODO(alpert): Error somehow?
                blocks[i] = mathPieces.join("");
                mathPieces = [];
            } else if (block === "{") {
                braces++;
            } else if (block === "}") {
                braces--;
            }
        } else if (i % 2 === 1) {
            // Looking for a start delimeter
            var two = block && block.slice(0, 2);
            if (two === "[[" || two === "@@") {
                // A widget or an @@n@@ thing (which we pull out so we don't
                // get confused later).
                blocks[i] = saveMath(block);
            } else if (block === "$") {
                // We got one! Save it for later and blank out its space.
                mathPieces.push(block);
                blocks[i] = "";
                braces = 0;
            }
            // Else, just normal text. Move along, move along.
        }
    }

    return [blocks.join(""), savedMath];

    function saveMath(math) {
        savedMath.push(math);
        return "@@" + (savedMath.length - 1) + "@@";
    }
}

Renderer.extractMathAndWidgets = extractMathAndWidgets;

})(Perseus);

},{"./core.js":11,"./tex.jsx":18,"./util.js":19,"./widgets.js":20}],18:[function(require,module,exports){
/** @jsx React.DOM */
/**
 * For math rendered using MathJax. Use me like <TeX>2x + 3</TeX>.
 */

require("./core.js");

// TODO(jack): Remove this closure now that this is in it's own file
var TeX = (function() {
    var pendingScripts = [];
    var needsProcess = false;
    var timeout = null;

    function process(script, callback) {
        pendingScripts.push(script);
        if (!needsProcess) {
            needsProcess = true;
            timeout = setTimeout(doProcess, 0, callback);
        }
    }

    function doProcess(callback) {
        MathJax.Hub.Queue(function() {
            var oldElementScripts = MathJax.Hub.elementScripts;
            MathJax.Hub.elementScripts = function(element) {
                var scripts = pendingScripts;
                pendingScripts = [];
                needsProcess = false;
                return scripts;
            };

            try {
                return MathJax.Hub.Process(null, callback);
            } catch (e) {
                // IE8 requires `catch` in order to use `finally`
                throw e;
            } finally {
                MathJax.Hub.elementScripts = oldElementScripts;
            }
        });
    }

    return React.createClass({
        getDefaultProps: function() {
            return {
                // Called after math is rendered or re-rendered
                onRender: function() {}
            };
        },

        render: function() {
            return React.DOM.span(null, 
                React.DOM.span( {ref:"mathjax"} ),
                React.DOM.span( {ref:"katex"} )
            );
        },

        componentDidMount: function(span) {
            var text = this.props.children;
            var onRender = this.props.onRender;

            if (typeof Exercises === "undefined" || Exercises.useKatex) {
                try {
                    var katexHolder = this.refs.katex.getDOMNode();
                    katex.process(text, katexHolder);
                    onRender();
                    return;
                } catch (e) {
                    /* jshint -W103 */
                    if (e.__proto__ !== katex.ParseError.prototype) {
                    /* jshint +W103 */
                        throw e;
                    }
                }
            }

            this.setScriptText(text);
            process(this.script, onRender);
        },

        componentDidUpdate: function(prevProps, prevState, span) {
            var oldText = prevProps.children;
            var newText = this.props.children;
            var onRender = this.props.onRender;

            if (oldText !== newText) {
                if (typeof Exercises === "undefined" || Exercises.useKatex) {
                    try {
                        var katexHolder = this.refs.katex.getDOMNode();
                        katex.process(newText, katexHolder);
                        if (this.script) {
                            var jax = MathJax.Hub.getJaxFor(this.script);
                            if (jax) {
                                jax.Remove();
                            }
                        }
                        onRender();
                        return;
                    } catch (e) {
                        /* jshint -W103 */
                        if (e.__proto__ !== katex.ParseError.prototype) {
                        /* jshint +W103 */
                            throw e;
                        }
                    }
                }

                $(this.refs.katex.getDOMNode()).empty();

                if (this.script) {
                    var component = this;
                    MathJax.Hub.Queue(function() {
                        var jax = MathJax.Hub.getJaxFor(component.script);
                        if (jax) {
                            return jax.Text(newText, onRender);
                        } else {
                            component.setScriptText(newText);
                            process(component.script, onRender);
                        }
                    });
                } else {
                    this.setScriptText(newText);
                    process(this.script, onRender);
                }
            }
        },

        setScriptText: function(text) {
            if (!this.script) {
                this.script = document.createElement("script");
                this.script.type = "math/tex";
                this.refs.mathjax.getDOMNode().appendChild(this.script);
            }
            if ("text" in this.script) {
                // IE8, etc
                this.script.text = text;
            } else {
                this.script.textContent = text;
            }
        },

        componentWillUnmount: function() {
            if (this.script) {
                var jax = MathJax.Hub.getJaxFor(this.script);
                if (jax) {
                    jax.Remove();
                }
            }
        }
    });
})();

module.exports = TeX;


},{"./core.js":11}],19:[function(require,module,exports){
var Util = {
    rWidgetParts: /^\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]$/,

    noScore: {
        type: "points",
        earned: 0,
        total: 0,
        message: null
    },

    seededRNG: function(seed) {
        var randomSeed = seed;

        return function() {
            // Robert Jenkins' 32 bit integer hash function.
            var seed = randomSeed;
            seed = ((seed + 0x7ed55d16) + (seed << 12)) & 0xffffffff;
            seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;
            seed = ((seed + 0x165667b1) + (seed << 5)) & 0xffffffff;
            seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff;
            seed = ((seed + 0xfd7046c5) + (seed << 3)) & 0xffffffff;
            seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;
            return (randomSeed = (seed & 0xfffffff)) / 0x10000000;
        };
    },

    // Shuffle an array using a given random seed or function.
    // If `ensurePermuted` is true, the input and ouput are guaranteed to be
    // distinct permutations.
    shuffle: function(array, randomSeed, ensurePermuted) {
        // Always return a copy of the input array
        var shuffled = _.clone(array);

        // Handle edge cases (input array is empty or uniform)
        if (!shuffled.length || _.all(shuffled, function(value) {
                                    return _.isEqual(value, shuffled[0]);
                                })) {
            return shuffled;
        }

        var random;
        if (_.isFunction(randomSeed)) {
            random = randomSeed;
        } else {
            random = Util.seededRNG(randomSeed);
        }

        do {
            // Fischer-Yates shuffle
            for (var top = shuffled.length; top > 0; top--) {
                var newEnd = Math.floor(random() * top),
                    temp = shuffled[newEnd];

                shuffled[newEnd] = shuffled[top - 1];
                shuffled[top - 1] = temp;
            }
        } while (ensurePermuted && _.isEqual(array, shuffled));

        return shuffled;
    },

    // In IE8, split doesn't work right. Implement it ourselves.
    split: "x".split(/(.)/g).length ?
        function(str, r) { return str.split(r); } :
        function(str, r) {
            // Based on Steven Levithan's MIT-licensed split, available at
            // http://blog.stevenlevithan.com/archives/cross-browser-split
            var output = [];
            var lastIndex = r.lastIndex = 0;
            var match;

            while ((match = r.exec(str))) {
                output.push(str.slice(lastIndex, match.index));
                output.push.apply(output, match.slice(1));
                lastIndex = match.index + match[0].length;
            }

            output.push(str.slice(lastIndex));
            return output;
        },

    /**
     * Given two score objects for two different widgets, combine them so that
     * if one is wrong, the total score is wrong, etc.
     */
    combineScores: function(scoreA, scoreB) {
        var message;

        if (scoreA.type === "points" && scoreB.type === "points") {
            if (scoreA.message && scoreB.message &&
                    scoreA.message !== scoreB.message) {
                // TODO(alpert): Figure out how to combine messages usefully
                message = null;
            } else {
                message = scoreA.message || scoreB.message;
            }

            return {
                type: "points",
                earned: scoreA.earned + scoreB.earned,
                total: scoreA.total + scoreB.total,
                message: message
            };

        } else if (scoreA.type === "points" && scoreB.type === "invalid") {
            return scoreB;

        } else if (scoreA.type === "invalid" && scoreB.type === "points") {
            return scoreA;

        } else if (scoreA.type === "invalid" && scoreB.type === "invalid") {
            if (scoreA.message && scoreB.message &&
                    scoreA.message !== scoreB.message) {
                // TODO(alpert): Figure out how to combine messages usefully
                message = null;
            } else {
                message = scoreA.message || scoreB.message;
            }

            return {
                type: "invalid",
                message: message
            };
        }
    },

    /**
     * Return the first valid interpretation of 'text' as a number, in the form
     * {value: 2.3, exact: true}.
     */
    firstNumericalParse: function(text) {
        // TODO(alpert): This is sort of hacky...
        var first;
        var val = Khan.answerTypes.predicate.createValidatorFunctional(
            function(ans) {
                first = ans;
                return true;  /* break */
            }, {
                simplify: "optional",
                inexact: true,
                forms: "integer, proper, improper, pi, log, mixed, decimal"
            });

        val(text);
        return first;
    },

    stringArrayOfSize: function(size) {
        return _(size).times(function() {
            return "";
        });
    },

    /**
     * For a graph's x or y dimension, given the tick step,
     * the ranges extent (e.g. [-10, 10]), the pixel dimension constraint,
     * and the grid step, return a bunch of configurations for that dimension.
     *
     * Example:
     *      gridDimensionConfig(10, [-50, 50], 400, 5)
     *
     * Returns: {
     *      scale: 4,
     *      snap: 2.5,
     *      tickStep: 2,
     *      unityLabel: true
     * };
     */
    gridDimensionConfig: function(absTickStep, extent, dimensionConstraint,
                                     gridStep) {
        var scale = Util.scaleFromExtent(extent, dimensionConstraint);
        var stepPx = absTickStep * scale;
        var unityLabel = stepPx > 30;
        return {
            scale: scale,
            tickStep: absTickStep / gridStep,
            unityLabel: unityLabel
        };
    },

    /**
     * Given the range, step, and boxSize, calculate the reasonable gridStep.
     * Used for when one was not given explicitly.
     *
     * Example:
     *      getGridStep([[-10, 10], [-10, 10]], [1, 1], 340)
     *
     * Returns: [1, 1]
     */
    getGridStep: function(range, step, boxSize) {
        return _(2).times(function(i) {
            var scale = Util.scaleFromExtent(range[i], boxSize);
            var gridStep = Util.gridStepFromTickStep(step[i], scale);
            return gridStep;
        });
    },

    snapStepFromGridStep: function(gridStep) {
        return _.map(gridStep, function(step) { return step / 2; });
    },

    /**
     * Given the range and a dimension, come up with the appropriate
     * scale.
     * Example:
     *      scaleFromExtent([-25, 25], 500) // returns 10
     */
    scaleFromExtent: function(extent, dimensionConstraint) {
        var span = extent[1] - extent[0];
        var scale = dimensionConstraint / span;
        return scale;
    },

    /**
     * Return a reasonable tick step given extent and dimension.
     * (extent is [begin, end] of the domain.)
     * Example:
     *      tickStepFromExtent([-10, 10], 300) // returns 2
     */
    tickStepFromExtent: function(extent, dimensionConstraint) {
        var span = extent[1] - extent[0];

        var tickFactor;
        // If single number digits
        if (15 < span && span <= 20) {
            tickFactor = 23;

        // triple digit or decimal
        } else if (span > 100 || span < 5) {
            tickFactor = 10;

        // double digit
        } else {
            tickFactor = 16;
        }
        var constraintFactor = dimensionConstraint / 500;
        var desiredNumTicks = tickFactor * constraintFactor;
        return Util.tickStepFromNumTicks(span, desiredNumTicks);
    },

    /**
     * Given the tickStep and the graph's scale, find a
     * grid step.
     * Example:
     *      gridStepFromTickStep(200, 0.2) // returns 100
     */
    gridStepFromTickStep: function(tickStep, scale) {
        var tickWidth = tickStep * scale;
        var x = tickStep;
        var y = Math.pow(10, Math.floor(Math.log(x) / Math.LN10));
        var leadingDigit = Math.floor(x / y);
        if (tickWidth < 25) {
            return tickStep;
        }
        if (tickWidth < 50) {
            if (leadingDigit === 5) {
                return tickStep;
            } else {
                return tickStep / 2;
            }
        }
        if (leadingDigit === 1) {
            return tickStep / 2;
        }
        if (leadingDigit === 2) {
            return tickStep / 4;
        }
        if (leadingDigit === 5) {
            return tickStep / 5;
        }
    },

    /**
     * Find a good tick step for the desired number of ticks in the range
     * Modified from d3.scale.linear: d3_scale_linearTickRange.
     * Thanks, mbostock!
     * Example:
     *      tickStepFromNumTicks(50, 6) // returns 10
     */
    tickStepFromNumTicks: function(span, numTicks) {
        var step = Math.pow(10, Math.floor(Math.log(span / numTicks) / Math.LN10));
        var err = numTicks / span * step;

        // Filter ticks to get closer to the desired count.
        if (err <= 0.15) {
            step *= 10;
        } else if (err <= 0.35) {
            step *= 5;
        } else if (err <= 0.75) {
            step *= 2;
        }

        // Round start and stop values to step interval.
        return step;
    },

    /**
     * Transparently update deprecated props so that the code to deal
     * with them only lives in one place: (Widget).deprecatedProps
     * 
     * For example, if a boolean `foo` was deprecated in favor of a
     * number 'bar':
     *      deprecatedProps: {
     *          foo: function(props) {
     *              return {bar: props.foo ? 1 : 0};
     *          }
     *      }
     */
    DeprecationMixin: {
        // This lifecycle stage is only called before first render
        componentWillMount: function() {
            var newProps = {};

            _.each(this.deprecatedProps, function(func, prop) {
                if (_.has(this.props, prop)) {
                    _.extend(newProps, func(this.props));
                }
            }, this);

            if (!_.isEmpty(newProps)) {
                // Set new props directly so that widget renders correctly
                // when it first mounts, even though these will be overwritten
                // almost immediately afterwards...
                _.extend(this.props, newProps);

                // ...when we propagate the new props upwards and they come
                // back down again.
                setTimeout(this.props.onChange, 0, newProps);    
            }
        }
    },

    /**
     * Approximate equality on numbers and primitives.
     */
    eq: function(x, y) {
        if (_.isNumber(x) && _.isNumber(y)) {
            return Math.abs(x - y) < 1e-9;
        } else {
            return x === y;
        }
    }, 

    /**
     * Deep approximate equality on primitives, numbers, arrays, and objects.
     */
    deepEq: function(x, y) {
        if (_.isArray(x) && _.isArray(y)) {
            if (x.length !== y.length) {
                return false;
            }
            for (var i = 0; i < x.length; i++) {
                if (!Util.deepEq(x[i], y[i])) {
                    return false;
                }
            }
            return true;
        } else if (_.isArray(x) || _.isArray(y)) {
            return false;
        } else if (_.isObject(x) && _.isObject(y)) {
            return _.all(x, function(value, key) {
                return Util.deepEq(y[key], value);
            }) && _.all(y, function(value, key) {
                return Util.deepEq(x[key], value);
            });
        } else if (_.isObject(x) || _.isObject(y)) {
            return false;
        } else {
            return Util.eq(x, y);
        }
    }
};

Util.random = Util.seededRNG(new Date().getTime() & 0xffffffff);

module.exports = Util;


},{}],20:[function(require,module,exports){
require("./core.js");

var widgetTypes = {};

var Widgets = Perseus.Widgets = {
    get: function(type) {
        return widgetTypes[type];
    },

    register: function(type, widgetClass) {
        widgetTypes[type] = widgetClass;
    }
};

module.exports = Widgets;


},{"./core.js":11}],21:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
require("../renderer.jsx");

var InfoTip = require("../components/info-tip.jsx");
var Widgets = require("../widgets.js");

var defaultNumCategories = 2;

function removeFromArray(array, item) {
    var index = _.indexOf(array, item);
    if (index >= 0) {
        array.splice(index, 1);
    }
}

function coordsRelativeTo(coords, div) {
    return _.map(offsetToCoords($(div).offset()), function(offset, i) {
        return coords[i] - offset;
    });
}

function offsetToCoords(offset) {
    return [offset.left, offset.top];
}

function getMouseCoords(e) {
    if (_.has(e, "nativeEvent")) {
        e = e.nativeEvent;
    }
    return [e.pageX, e.pageY];
}

function offsetCoordsBy(coords, offset) {
    return _.map(coords, function(coord, i) {
        return coord - offset[i];
    });
}

function getDimensions($ele) {
    return [$ele.outerWidth(), $ele.outerHeight()];
}

function findDimensionsFor(root, ele) {
    var $ele = $(ele);
    var offset = offsetToCoords($ele.offset());
    return getAllCoordTypes(offset, $ele, root);
}

function withinBox(box, middle) {
    return _.every(middle, function(coord, i) {
        var c = box.topLeft[i];
        return c <= coord && coord <= c + box.dimensions[i];
    });
}

function getAllCoordTypes(coords, $ele, root) {
    var topLeft = coordsRelativeTo(coords, root);
    var dimensions = getDimensions($ele);
    return {
        dimensions: dimensions,
        topLeft: topLeft,
        middle: _.map(dimensions, function(dim, i) {
            return topLeft[i] + dim / 2;
        })
    };
}

function cloneMatrix(matrix) {
    return _.map(matrix, function(row) {
        return row.slice();
    });
}

function blankItem(position) {
    return {
        content: "",
        location: {
            category: 0,
            position: position || 0
        }
    };
}

function getDefaultProps() {
    var item = blankItem();
    return {
        isEditor: false,
        items: [item],
        correctLocations: [item.location],
        categoryHeaders: [""]
    };
}

function isBank(category) {
    return category === 0;
}

function nextPosition(items) {
    var item = _.max(items, function (item) {
        return item.location.position;
    });
    return item.location.position + 1;
}

function nextPositionCorrectLocations(correctLocations) {
    return _.max(_.pluck(correctLocations, "position")) + 1;
}

// This is adapted from the calculation in orderer.
// It gives an animation time that is distance dependent,
// based on the square root of the distance.
function dragReturnAnimationTime(fromCoords, toCoords) {
    var squareDistance = _.reduce(fromCoords, function(squareD, coord, i) {
        var diff = toCoords[i] - coord;
        return squareD + diff * diff;
    }, 0);
    var distance = Math.sqrt(squareDistance);
    return Math.max(15 * Math.sqrt(distance), 1);
}

var Categorization = React.createClass({displayName: 'Categorization',
    getDefaultProps: getDefaultProps,

    getInitialState: function() {
        return {
            showDragHint: true,
            dragging: null
        };
    },

    getAllMouseCoordTypes: function(mouseCoords, $ele) {
        var offsetMouse = offsetCoordsBy(
                mouseCoords, this.state.dragging.offset);
        var c = getAllCoordTypes(offsetMouse, $ele, $(this.getDOMNode()));
        c.mouse = mouseCoords;
        return c;
    },

    getItems: function() {
        return _.map(this.props.items, function(item, index) {
            return _.extend({index: index}, item);
        });
    },

    startDrag: function(itemIndex, event) {
        var self = this;
        if (itemIndex == null || self.state.dragging) {
            return;
        }
        var items = self.getItems();
        var item = items[itemIndex];

        var cardDiv = $(event.target);
        while (!cardDiv.hasClass("card")) {
            cardDiv = cardDiv.parent();
        }
        var coords = getMouseCoords(event);
        var offset = coordsRelativeTo(coords, cardDiv);
        var root = $(self.getDOMNode());
        var categories = root.find(".categories .category");
        var findDims = _.partial(findDimensionsFor, root);
        self.categoryDimensions = _.map(categories, findDims);
        if (self.props.isEditor) {
            var deleteItem = root.find(".delete-item-area");
            self.deleteItemDimensions = findDimensionsFor(root, deleteItem);
        }

        self.setState({
            dragging: {
                itemIndex: itemIndex,
                offset: offset
            }
        }, _.bind(self.updateDrag, self, coords));

        $(document)
        .on("vmousemove.categorization", function(e) {
            self.updateDrag(getMouseCoords(e));
        })
        .on("vmouseup.categorization", function(e) {
            self.endDrag(getMouseCoords(e));
        });
    },

    findDrag: function() {
        return $(this.getDOMNode()).find(".card.dragging");
    },

    updateDrag: function(coords) {
        var self = this;
        var $drag = this.findDrag();

        var c = self.getAllMouseCoordTypes(coords, $drag);
        var middle = c.middle;
        $drag
            .css("left", c.topLeft[0])
            .css("top", c.topLeft[1]);
        var targetCategory = self.findTargetCategory(middle);
        self.setState({targetCategory: targetCategory});
    },

    findTargetCategory: function(middle) {
        var self = this;
        var categoryIndex;
        if (self.props.isEditor) {
            if (withinBox(self.deleteItemDimensions, middle)) {
                return "delete";
            }
        }
        var inCategory = _.find(self.categoryDimensions, function(col, index) {
            categoryIndex = index;
            return withinBox(col, middle);
        });

        // 0th category is bank
        if (!inCategory) {
            return 0;
        }

        // Therefore true categories get incremented indicies.
        return categoryIndex + 1;
    },

    endDrag: function(coords) {
        var self = this;
        var dragging = self.state.dragging;
        if (!dragging) {
            return;
        }
        var $drag = self.findDrag();
        var items = self.getItems();
        var itemIndex = dragging.itemIndex;
        var item = items[itemIndex];

        $(document)
            .off("vmousemove.categorization")
            .off("vmouseup.categorization");

        var c = self.getAllMouseCoordTypes(coords, $drag);
        var targetCategory = self.findTargetCategory(c.middle);

        if (targetCategory === "delete") {
            self.updateLocation(targetCategory);
            self.props.deleteItem(itemIndex);
            return;
        }

        var root = $(self.getDOMNode());
        var returnedToSame = false;
        if (_.isEqual(targetCategory, item.location.category)) {
            returnedToSame = true;
        }
        var slotClass;
        if (returnedToSame) {
            slotClass = ".card.placeholder";
        } else {
            slotClass = ".card-empty-slot";
        }
        var offsetTop = false;
        var slot = root.find(
                ".category-" + targetCategory + " " + slotClass);
        if (!returnedToSame) {
            if (!isBank(item.location.category) &&
                item.location.category < targetCategory) {
                offsetTop = true;
            }
        }
        var dims = findDimensionsFor(root, slot);
        var topLeft = {left: dims.topLeft[0], top: dims.topLeft[1]};
        if (offsetTop) {
            var placeholder = root.find(".category-" +
                    item.location.category + " .card.placeholder");
            var parentDims = getDimensions(placeholder.parent());
            topLeft.top -= parentDims[1];
        }
        var animationTime = dragReturnAnimationTime(
                c.topLeft, dims.topLeft);
        $drag.animate(topLeft, {
            duration: animationTime,
            complete: _.bind(self.updateLocation, self, targetCategory)
        });
    },

    updateLocation: function(targetCategory) {
        var self = this;
        var items = self.getItems();
        var itemIndex = self.state.dragging.itemIndex;
        var item = items[itemIndex];

        var change = {
            targetCategory: null,
            dragging: null
        };
        if (item.location.category !== targetCategory) {
            var position = nextPosition(items);
            item.location = {
                category: targetCategory,
                position: position
            };
            change.showDragHint = false;
            self.props.onChange({
                items: items
            });
        }
        self.setState(change);
    },

    render: function() {
        var self = this;
        var items = self.getItems();
        var targetCategory = self.state.targetCategory;
        var dragging = self.state.dragging;
        var isEditor = self.props.isEditor;

        var dragItem;
        if (dragging) {
            dragItem = CategoryItem({
                isDragItem: true,
                item: dragging ? items[dragging.itemIndex] : null,
                isEditor: this.props.isEditor
            });
        }

        // bank
        var bank = React.DOM.div( {className:"bank"}, 
            Category(
                {ref:"bank",
                category:0,
                items:items,
                isEditor:isEditor,
                targetCategory:targetCategory,
                dragging:dragging,
                onChangeContent:self.props.onChangeContent,
                startDrag:self.startDrag}
                )
        );

        var deleteItem;
        if (isEditor) {
            var deleteItemClass = "delete-item-area";
            if (targetCategory === "delete") {
                deleteItemClass += " target";
            }
            deleteItem = React.DOM.div( {className:deleteItemClass}, 
                React.DOM.span( {className:"icon-trash"})
            );
        }

        // categories
        var categories = React.DOM.div( {className:"categories clearfix"}, 
            _.map(self.props.categoryHeaders, function(header, c) {
                var category = c + 1;
                return Category(
                            {ref:"category-" + category,
                            category:category,
                            key:category,
                            categoryHeader:header,
                            isEditor:isEditor,
                            items:items,
                            isTarget:targetCategory === category,
                            dragging:dragging,
                            showDragHint:self.state.showDragHint,
                            onChangeContent:self.props.onChangeContent,
                            onChangeHeader:self.props.onChangeHeader,
                            removeCategory:self.props.removeCategory,
                            startDrag:self.startDrag}
                            );
            })
        );

        // container
        var containerName = "draggy-boxy-thing categorization-container" +
                            " clearfix";
        if (isEditor) {
            containerName += " categorization-container-editor";
        }
        if (dragging) {
            containerName += " currently-dragging";
        }

        return React.DOM.div( {className:containerName}, 
            dragItem,
            bank,
            categories,
            deleteItem
        );
    },

    toJSON: function() {
        var items = _.map(this.props.items, function (item) {
            return _.pick(item, "location");
        });
        return {items: items};
    },

    simpleValidate: function(rubric) {
        return Categorization.validate(this.toJSON(), rubric);
    },

    focusAddedItem: function() {
        this.refs.bank.focusAddedItem();
    },

    focusAddedCategory: function() {
        var category = this.props.categoryHeaders.length;
        this.refs["category-" + category].focus();
    },
});

_.extend(Categorization, {
    validate: function(state, rubric) {
        var started = false;
        var allCorrect = true;
        _.each(state.items, function(item, i) {
            var correctLocation = rubric.correctLocations[i];
            var loc = item.location;
            if (!isBank(loc.category)) {
                started = true;
            }
            if (loc.category !== correctLocation.category) {
                allCorrect = false;
            }
        });
        if (!started) {
            return {
                type: "invalid",
                message: "At least one item must be categorized."
            };
        }
        return {
            type: "points",
            earned: allCorrect ? 1 : 0,
            total: 1,
            message: null
        };
    }
});

var Category = React.createClass({displayName: 'Category',

    renderCategoryItem: function(item, options) {
        var dragging = this.props.dragging;
        if (dragging && dragging.itemIndex === item.index) {
            return PlaceholderItem( {item:item} );
        }
        var key = "category-item-" + item.index;
        return CategoryItem({
            ref: key,
            key: key,
            item: item,
            isEditor: this.props.isEditor,
            onMouseDown: _.partial(this.props.startDrag, item.index),
            onChange: _.partial(this.props.onChangeContent, item.index)
        });
    },

    getDefaultProps: function() {
        return {
            isEditor: false,
            showDragHint: false,
            categoryHeader: null
        };
    },

    categoryItems: function() {
        var self = this;
        var colItems = _.filter(self.props.items, function(item) {
            return item.location.category === self.props.category;
        });
        return _.sortBy(colItems, function(item) {
            return item.location.position;
        });
    },

    render: function(categoryHeader, c) {
        var self = this;
        var category = self.props.category;
        var items = self.categoryItems();

        var cardList = React.DOM.ul( {className:"clearfix"}, 
            _.map(items, self.renderCategoryItem, self),
            self.props.showDragHint ? DragHintItem(null ) : InvisibleItem(null )
        );

        var header = self.renderHeader();

        // container class
        var className = "category clearfix category-" + category;
        if (self.props.isTarget) {
            className += " target";
        } else if (self.props.dragging) {
            className += " non-target";
        }

        var listClass = "cards-list";
        if (!isBank(category)) {
            listClass += " cards-area";
        }

        return React.DOM.div( {className:className}, 
            React.DOM.div( {className:listClass}, 
                header,
                cardList
            )
        );
    },

    renderHeader: function() {
        var self = this;
        if (isBank(self.props.category)) {
            return null;
        }
        var header;
        if (self.props.isEditor) {
            var onChangeHeader = function(e) {
                var header = self.refs.header;
                var value = header.getDOMNode().value;
                self.props.onChangeHeader(self.props.category, value);
            };
            var removeCategory = _.partial(
                    self.props.removeCategory, self.props.category);

            header = React.DOM.div(null, 
                React.DOM.div(
                        {className:"remove",
                        onClick:removeCategory}, 
                    React.DOM.span( {className:"icon-remove"})
                ),
                React.DOM.input(
                        {ref:"header",
                        type:"text",
                        onInput:onChangeHeader,
                        value:self.props.categoryHeader}
                        )
            );
        } else {
            header = Perseus.Renderer({
                content: self.props.categoryHeader
            });
        }
        return React.DOM.div( {className:"header"}, header);
    },

    focus: function() {
        this.refs.header.getDOMNode().focus();
    },

    focusAddedItem: function() {
        var length = this.props.items.length;
        if (length) {
            var item = this.props.items[length - 1];
            var ref = this.refs["category-item-" + item.index];
            if (ref) {
                ref.focus();
            }
        }
    },
});

var PlaceholderItem = React.createClass({displayName: 'PlaceholderItem',
    render: function() {
        return React.DOM.li( {className:"card-container"}, 
            React.DOM.div( {className:"card placeholder"}, 
                Perseus.Renderer({content: this.props.item.content})
            )
        );
    }
});

var DragHintItem = React.createClass({displayName: 'DragHintItem',
    render: function() {
        return React.DOM.li( {className:"card-container"}, 
            React.DOM.div( {className:"card card-empty-slot drag-hint"})
        );
    }
});

var InvisibleItem = React.createClass({displayName: 'InvisibleItem',
    render: function() {
        return React.DOM.li( {className:"card-container"}, 
            React.DOM.div( {className:"card card-empty-slot card-hidden"})
        );
    }
});

var CategoryItem = React.createClass({displayName: 'CategoryItem',
    getDefaultProps: function() {
        return {
            onChange: function() {},
            onMouseDown: function() {},
            isEditor: false
        };
    },

    render: function() {
        var self = this;
        var item = self.props.item;
        var content = item.content;
        var isEditor = self.props.isEditor;
        var onChange = function(e) {
            self.props.onChange(self.refs.editor.getDOMNode().value);
        };
        var onMouseDown = function(e) {
            if (isEditor) {
                if (e.target.tagName === "TEXTAREA") {
                    return;
                }
            }
            self.props.onMouseDown(e);
            e.preventDefault();
        };

        var className = "card";
        if (self.props.isDragItem) {
            className += " dragging";
        }

        var inner;
        if (isEditor) {
            var mouseDownEditor = function(e) {
                e.stopPropagation();
            };
            inner = React.DOM.div(
                    {className:className + " card-editor",
                    onMouseDown:onMouseDown}, 
                React.DOM.div( {className:"drag-bar"}, 
                    React.DOM.span( {className:"icon-reorder"})
                ),
                React.DOM.input(
                        {ref:"editor",
                        type:"text",
                        onInput:onChange,
                        onMouseDown:mouseDownEditor,
                        value:content}
                        )
            );
        } else {
            inner = React.DOM.div(
                {className:className,
                onMouseDown:onMouseDown,
                onTouchStart:onMouseDown}
            , Perseus.Renderer({content: content}));
        }

        if (self.props.isDragItem) {
            return inner;
        }
        return React.DOM.li( {className:"card-container"}, 
            inner
        );
    },

    focus: function() {
        this.refs.editor.getDOMNode().focus();
    },
});

var CategorizationEditor = React.createClass({displayName: 'CategorizationEditor',
    getDefaultProps: getDefaultProps,

    render: function() {
        var self = this;
        var correctLocations = self.props.correctLocations;
        var items = _.map(self.props.items, function(item, index) {
            return {
                content: item.content,
                location: correctLocations[index]
            };
        });
        return React.DOM.div(null, 
            InfoTip(null, 
              React.DOM.p(null, "The number of cards and categories is unlimited, but we "+
              "recommend a max of five cards and three categories to prevent the "+
              "question from running off the screen."),

              React.DOM.p(null, "For the correct answer, move the cards into the correct "+
              "categories in the question area on the left side of the "+
              "screen.")
            ),
            React.DOM.div( {className:"categorization-editor-area"}, 
                React.DOM.div( {className:"add-item"}, 
                    React.DOM.button( {onClick:self.addItem}, 
                        " Add an item "
                    )
                ),
                React.DOM.div( {className:"add-category"}, 
                    React.DOM.button( {onClick:self.onAddCategory}, 
                        " Add a category "
                    )
                )
            ),
            Categorization(
                {ref:"categorization",
                items:items,
                categoryHeaders:self.props.categoryHeaders,
                isEditor:true,
                removeCategory:self.removeCategory,
                onChangeHeader:self.onChangeHeader,
                onChangeContent:self.onChangeContent,
                deleteItem:self.deleteItem,
                onChange:function(rawNewProps) {
                    var newProps = _.clone(rawNewProps);
                    if (rawNewProps.items) {
                        newProps.correctLocations = _.pluck(
                                newProps.items, "location");
                    }
                    self.props.onChange(newProps);
                }}
                )
        );
    },

    onAddCategory: function(e) {
        var headers = this.props.categoryHeaders.slice();
        headers.push("");
        this.props.onChange({
            categoryHeaders: headers
        }, this.refs.categorization.focusAddedCategory);
    },

    removeCategory: function(category) {
        var correctLocations = this.props.correctLocations;
        var headers = this.props.categoryHeaders.slice();
        var position = nextPositionCorrectLocations(correctLocations);
        correctLocations = _.map(correctLocations, function(loc) {
            if (loc.category === category) {
                position += 1;
                return {category: 0, position: position};
            } else if (loc.category > category) {
                loc = _.clone(loc);
                loc.category = loc.category - 1;
                return loc;
            } else {
                return loc;
            }
        });
        headers.splice(category - 1, 1);
        this.props.onChange({
            categoryHeaders: headers,
            correctLocations: correctLocations
        });
    },

    addItem: function() {
        var items = this.props.items.slice();
        var correctLocations = this.props.correctLocations.slice();
        var position = nextPositionCorrectLocations(correctLocations);
        var item = blankItem(position);
        items.push(item);
        correctLocations.push(item.location);
        this.props.onChange({
            items: items,
            correctLocations: correctLocations
        }, this.refs.categorization.focusAddedItem);
    },

    deleteItem: function(removeIndex) {
        var items = this.props.items.slice();
        var correctLocations = this.props.correctLocations.slice();
        items.splice(removeIndex, 1);
        correctLocations.splice(removeIndex, 1);
        this.props.onChange({
            items: items,
            correctLocations: correctLocations
        });
    },

    onChangeContent: function(itemIndex, content) {
        if (itemIndex == null) {
            return;
        }
        var items = this.props.items.slice();
        items[itemIndex] = _.extend({}, items[itemIndex], {content: content});
        this.props.onChange({items: items});
    },

    onChangeHeader: function(category, content) {
        var headers = this.props.categoryHeaders.slice();
        headers[category - 1] = content;
        this.props.onChange({categoryHeaders: headers});
    },

    focus: function() {
        this.refs.categorization.focusAddedItem();
    },

    toJSON: function() {
        var json = _.pick(this.props, "items", "correctLocations",
                          "categoryHeaders");
        json.items = _.map(json.items, function(item, index) {
            item = _.clone(item);
            delete item.index;
            item.location = {category: 0, position: index};
            return item;
        });
        return json;
    }
});

Widgets.register("categorization", Categorization);
Widgets.register("categorization-editor", CategorizationEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../core.js":11,"../renderer.jsx":17,"../widgets.js":20}],22:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");

var InfoTip = require("../components/info-tip.jsx");
var Widgets = require("../widgets.js");

var Dropdown = React.createClass({displayName: 'Dropdown',
    getDefaultProps: function() {
        return {
            choices: [{}],
            selected: 0
        };
    },

    render: function() {
        var choices = this.props.choices.slice();
        choices.unshift({
            content: ""
        });

        // TODO(jack): This should base the selected
        // item on its props
        return React.DOM.select(
                    {onChange:this.onChange,
                    className:"perseus-widget-dropdown"}, 
            choices.map(function(choice, i) {
                return React.DOM.option(
                        {key:"" + i,
                        value:i}, 
                    choice.content
                );
            }, this)
        );
    },

    focus: function() {
        this.getDOMNode().focus();
        return true;
    },

    onChange: function(e) {
        var selected = this.getDOMNode().selectedIndex;
        this.props.onChange({selected: selected});
    },

    toJSON: function(skipValidation) {
        return {value: this.getDOMNode().selectedIndex};
    },

    simpleValidate: function(rubric) {
        return Dropdown.validate(this.toJSON(), rubric);
    },
});

_.extend(Dropdown, {
    validate: function(state, rubric) {
        var selected = state.value;
        if (selected === 0) {
            return {
                type: "invalid",
                message: null
            };
        } else {
            var correct = rubric.choices[selected - 1].correct;
            return {
                type: "points",
                earned: correct ? 1 : 0,
                total: 1,
                message: null
            };
        }
    }
});

var DropdownEditor = React.createClass({displayName: 'DropdownEditor',
    getDefaultProps: function() {
        return {
            choices: [{
                content: "",
                correct: true
            }]
        };
    },

    render: function() {
        var dropdownGroupName = _.uniqueId("perseus_dropdown_");
        return React.DOM.div( {className:"perseus-widget-dropdown"}, 
            InfoTip(null, 
                React.DOM.p(null, "The drop down is useful for making inequalities in a custom "+
                "format. We normally use the symbols ", "<",", ", ">",", ≤, ≥ (in "+
                "that order) which you can copy into the choices.  When "+
                "possible, use the \"multiple choice\" answer type "+
                "instead.")
            ),
            React.DOM.ul(null, 
                this.props.choices.map(function(choice, i) {
                    return React.DOM.li( {key:"" + i}, 
                        React.DOM.div(null, 
                            React.DOM.input(
                                {ref:"radio" + i,
                                type:"radio",
                                name:dropdownGroupName,
                                checked:choice.correct ? "checked" : "",
                                onChange:this.onCorrectChange.bind(this, i),
                                value:i} ),
                            React.DOM.input(
                                {type:"text",
                                ref:"editor" + i,
                                onInput:this.onContentChange.bind(this, i),
                                value:choice.content} )
                        )
                    );
                }, this)
            ),

            React.DOM.div( {className:"add-choice-container"}, 
                React.DOM.a( {href:"#", className:"simple-button orange",
                        onClick:this.addChoice}, 
                    React.DOM.span( {className:"icon-plus"} ),
                    " Add a choice "
                )
            )
        );
    },

    onCorrectChange: function(choiceIndex) {
        var choices = _.map(this.props.choices, function (choice, i) {
            return _.extend({}, choice, {
                correct: i === choiceIndex
            });
        });
        this.props.onChange({choices: choices});
    },

    onContentChange: function(choiceIndex, e) {
        var choices = this.props.choices.slice();
        var choice = _.clone(choices[choiceIndex]);
        choice.content = e.target.value;
        choices[choiceIndex] = choice;
        this.props.onChange({choices: choices});
    },

    addChoice: function(e) {
        e.preventDefault();

        var choices = this.props.choices;
        var blankChoice = {content: "", correct: false};
        this.props.onChange({
            choices: choices.concat([blankChoice])
        }, this.focus.bind(this, choices.length));
    },

    focus: function(i) {
        this.refs["editor" + i].getDOMNode().focus();
        return true;
    },

    toJSON: function(skipValidation) {
        return _.pick(this.props, 'choices');
    }
});

Widgets.register("dropdown", Dropdown);
Widgets.register("dropdown-editor", DropdownEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../core.js":11,"../widgets.js":20}],23:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");

var InfoTip = require("../components/info-tip.jsx");
var TeX     = require("../tex.jsx");  // KaTeX and/or MathJax
var Widgets = require("../widgets.js");

var Expression = React.createClass({displayName: 'Expression',
    getDefaultProps: function() {
        return {
            currentValue: "",
            times: false,
            functions: []
        };
    },

    getInitialState: function() {
        return {
            lastParsedTex: ""
        };
    },

    parse: function(value, props) {
        // TODO(jack): Disable icu for content creators here, or
        // make it so that solution answers with ','s or '.'s work
        var options = _.pick(props || this.props, "functions");
        if (icu && icu.getDecimalFormatSymbols) {
            _.extend(options, icu.getDecimalFormatSymbols());
        }
        return KAS.parse(value, options);
    },

    componentWillMount: function() {
        this.updateParsedTex(this.props.currentValue);
    },

    componentWillReceiveProps: function(nextProps) {
        this.updateParsedTex(nextProps.currentValue, nextProps);
    },

    render: function() {
        var result = this.parse(this.props.currentValue);

        return React.DOM.span( {className:"perseus-widget-expression"}, 
            React.DOM.input( {ref:"input", type:"text",
                value:this.props.currentValue,
                onKeyDown:this.handleKeyDown,
                onKeyPress:this.handleKeyPress,
                onChange:this.handleChange} ),
            React.DOM.span( {className:"output"}, 
                React.DOM.span( {className:"tex",
                        style:{opacity: result.parsed ? 1.0 : 0.5}}, 
                    TeX(null, this.state.lastParsedTex)
                ),
                React.DOM.span( {className:"placeholder"}, 
                    React.DOM.span( {ref:"error", className:"error",
                            style:{display: "none"}}, 
                        React.DOM.span( {className:"buddy"} ),
                        React.DOM.span( {className:"message"}, React.DOM.span(null, 
                            "Sorry, I don't understand that!"
                        ))
                    )
                )
            )
        );
    },

    errorTimeout: null,

    componentDidMount: function() {
        this.componentDidUpdate();
    },

    componentDidUpdate: function() {
        clearTimeout(this.errorTimeout);
        if (this.parse(this.props.currentValue).parsed) {
            this.hideError();
        } else {
            this.errorTimeout = setTimeout(this.showError, 2000);
        }
    },

    componentWillUnmount: function() {
        clearTimeout(this.errorTimeout);
    },

    showError: function() {
        var $error = $(this.refs.error.getDOMNode());
        if (!$error.is(":visible")) {
            $error.css({ top: 50, opacity: 0.1 }).show()
                .animate({ top: 0, opacity: 1.0 }, 300);
        }
    },

    hideError: function() {
        var $error = $(this.refs.error.getDOMNode());
        if ($error.is(":visible")) {
            $error.animate({ top: 50, opacity: 0.1 }, 300, function() {
                $(this).hide();
            });
        }
    },

    /**
     * The keydown handler handles clearing the error timeout, telling
     * props.currentValue to update, and intercepting the backspace key when
     * appropriate...
     */
    handleKeyDown: function(event) {
        var input = this.refs.input.getDOMNode();
        var text = input.value;

        var start = input.selectionStart;
        var end = input.selectionEnd;
        var supported = start !== undefined;

        var which = event.nativeEvent.keyCode;

        if (supported && which === 8 /* backspace */) {
            if (start === end && text.slice(start - 1, start + 1) === "()") {
                event.preventDefault();
                var val = text.slice(0, start - 1) + text.slice(start + 1);

                // this.props.onChange will update the value for us, but
                // asynchronously, making it harder to set the selection
                // usefully, so we just set .value directly here as well.
                input.value = val;
                input.selectionStart = start - 1;
                input.selectionEnd = end - 1;
                this.props.onChange({currentValue: val});
            }
        }
    },

    /**
     * ...whereas the keypress handler handles the parentheses because keyCode
     * is more useful for actual character insertions (keypress gives 40 for an
     * open paren '(' instead of keydown which gives 57, the code for '9').
     */
    handleKeyPress: function(event) {
        var input = this.refs.input.getDOMNode();
        var text = input.value;

        var start = input.selectionStart;
        var end = input.selectionEnd;
        var supported = start !== undefined;

        var which = event.nativeEvent.charCode;

        if (supported && which === 40 /* left paren */) {
            event.preventDefault();

            var val;
            if (start === end) {
                var insertMatched = _.any([" ", ")", ""], function(val) {
                    return text.charAt(start) === val;
                });

                val = text.slice(0, start) +
                        (insertMatched ? "()" : "(") + text.slice(end);
            } else {
                val = text.slice(0, start) +
                        "(" + text.slice(start, end) + ")" + text.slice(end);
            }

            input.value = val;
            input.selectionStart = start + 1;
            input.selectionEnd = end + 1;
            this.props.onChange({currentValue: val});

        } else if (supported && which === 41 /* right paren */) {
            if (start === end && text.charAt(start) === ")") {
                event.preventDefault();
                input.selectionStart = start + 1;
                input.selectionEnd = end + 1;
            }
        }
    },

    handleChange: function(event) {
        this.props.onChange({currentValue: event.target.value});
    },

    focus: function() {
        this.refs.input.getDOMNode().focus();
        return true;
    },

    toJSON: function(skipValidation) {
        return {currentValue: this.props.currentValue};
    },

    updateParsedTex: function(value, props) {
        var result = this.parse(value, props);
        var options = _.pick(this.props, "times");
        if (result.parsed) {
            this.setState({lastParsedTex: result.expr.asTex(options)});
        }
    },

    simpleValidate: function(rubric) {
        return Expression.validate(this.toJSON(), rubric);
    },

    examples: function() {
        var mult = $._("For $2\\cdot2$, enter **2*2**");
        if (this.props.times) {
            mult = mult.replace(/\\cdot/g, "\\times");
        }

        return [
            mult,
            $._("For $3y$, enter **3y** or **3*y**"),
            $._("For $\\dfrac{1}{x}$, enter **1/x**"),
            $._("For $x^{y}$, enter **x^y**"),
            $._("For $\\sqrt{x}$, enter **sqrt(x)**"),
            $._("For $\\pi$, enter **pi**"),
            $._("For $\\sin \\theta$, enter **sin(theta)**"),
            $._("For $\\le$ or $\\ge$, enter **<=** or **>=**"),
            $._("For $\\neq$, enter **=/=**")
        ];
    }
});

_.extend(Expression, {
    validate: function(state, rubric) {
        var options = _.clone(rubric);
        if (icu && icu.getDecimalFormatSymbols) {
            _.extend(options, icu.getDecimalFormatSymbols());
        }
        // We don't give options to KAS.parse here because that is parsing
        // the solution answer, not the student answer, and we don't
        // want a solution to work if the student is using a different
        // language but not in english.
        var val = Khan.answerTypes.expression.createValidatorFunctional(
            KAS.parse(rubric.value, rubric).expr, options);

        var result = val(state.currentValue);

        // TODO(eater): Seems silly to translate result to this invalid/points
        // thing and immediately translate it back in ItemRenderer.scoreInput()
        if (result.empty) {
            return {
                type: "invalid",
                message: result.message
            };
        } else {
            return {
                type: "points",
                earned: result.correct ? 1 : 0,
                total: 1,
                message: result.message
            };
        }
    }
});

var ExpressionEditor = React.createClass({displayName: 'ExpressionEditor',
    getDefaultProps: function() {
        return {
            form: false,
            simplify: false,
            times: false,
            functions: ["f", "g", "h"]
        };
    },

    optionLabels: {
        form: {
            labelText: "Answer expression must have the same form.",
            infoTip: "The student's answer must be in the same form. " +
                    "Commutativity and excess negative signs are ignored."
        },
        simplify: {
            labelText: "Answer expression must be fully expanded and " +
                "simplified.",
            infoTip: "The student's answer must be fully expanded and " +
                " simplified. Answering this equation (x^2+2x+1) with this " +
                " factored equation (x+1)^2 will render this response " +
                "\"Your answer is not fully expanded and simplified.\""
        },
        times: {
            labelText: "Use \u00d7 for rendering multiplication instead of " +
                "a center dot.",
            infoTip: "For pre-algebra problems this option displays " +
                "multiplication as \\times instead of \\cdot in both the " +
                "rendered output and the acceptable formats examples."
        }
    },

    render: function() {
        var simplifyWarning = null;
        var shouldTryToParse = this.props.simplify && this.props.value !== "";
        if (shouldTryToParse) {
            var expression = KAS.parse(this.props.value);
            if (expression.parsed && !expression.expr.isSimplified()) {
                simplifyWarning = React.DOM.p( {className:"warning"}, React.DOM.b(null, "Warning"),": You "+
                    "specified that the answer should be simplified but did not "+
                    "provide a simplified answer. Are you sure you want to "+
                    "require simplification?");
            }
        }

        return React.DOM.div(null, 
            React.DOM.div(null, React.DOM.label(null, 
                " Correct answer: ",
                Expression( {ref:"expression",
                    currentValue:this.props.value,
                    times:this.props.times,
                    functions:this.props.functions,
                    onChange:function(newProps) {
                        if ("currentValue" in newProps) {
                            newProps.value = newProps.currentValue;
                            delete newProps.currentValue;
                        }
                        this.props.onChange(newProps);
                    }.bind(this)} )
            )),

            simplifyWarning,

            _.map(this.optionLabels, function(optionData, optionName) {
                return React.DOM.div(null, React.DOM.label( {key:optionName}, 
                    React.DOM.input( {type:"checkbox", name:optionName,
                        checked:this.props[optionName],
                        onChange:this.handleCheck} ),
                    optionData.labelText
                ),
                InfoTip(null, React.DOM.p(null, 
                    optionData.infoTip
                ))
                );
            }, this),
            React.DOM.div(null, 
                React.DOM.label(null, 
                "Function variables: ",
                React.DOM.input( {type:"text",
                    defaultValue:this.props.functions.join(" "),
                    onChange:this.handleFunctions} )
                ),
                InfoTip(null, React.DOM.p(null, 
                    " Single-letter variables listed here will be interpreted as "+
                    "functions. This let us know that f(x) means \"f of x\" and "+
                    "not \"f times x\". "
                ))
            )
        );
    },

    handleCheck: function(e) {
        var newProps = {};
        newProps[e.target.name] = e.target.checked;
        this.props.onChange(newProps);
    },

    handleFunctions: function(e) {
        var newProps = {};
        newProps.functions = _.compact(e.target.value.split(/[ ,]+/));
        this.props.onChange(newProps);
    },

    focus: function() {
        this.refs.expression.focus();
        return true;
    },

    toJSON: function(skipValidation) {
        var value = this.props.value;

        if (!skipValidation) {
            if (value === "") {
                alert("Warning: No expression has been entered.");
            } else if (!this.refs.expression.parse(value).parsed) {
                alert("Warning: Entered expression didn't parse.");
            }
        }

        return _.pick(this.props, "value", "form", "simplify",
            "times", "functions");
    }
});

Widgets.register("expression", Expression);
Widgets.register("expression-editor", ExpressionEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../core.js":11,"../tex.jsx":18,"../util.js":19,"../widgets.js":20}],24:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");

var InfoTip = require("../components/info-tip.jsx");
var Widgets = require("../widgets.js");
var BlurInput = require("../components/blur-input.jsx");

var answerTypes = {
    number: {
        name: "Numbers",
        forms: "integer, decimal, proper, improper, mixed"
    },
    decimal: {
        name: "Decimals",
        forms: "decimal"
    },
    integer: {
        name: "Integers",
        forms: "integer"
    },
    rational: {
        name: "Fractions and mixed numbers",
        forms: "integer, proper, improper, mixed"
    },
    improper: {
        name: "Improper numbers (no mixed)",
        forms: "integer, proper, improper"
    },
    mixed: {
        name: "Mixed numbers (no improper)",
        forms: "integer, proper, mixed"
    },
    percent: {
        name: "Numbers or percents",
        forms: "integer, decimal, proper, improper, mixed, percent"
    },
    pi: {
        name: "Numbers with pi", forms: "pi"
    }
};

var formExamples = {
    "integer": function(options) { return $._("an integer, like $6$"); },
    "proper": function(options) {
        if (options.simplify === "optional") {
            return $._("a *proper* fraction, like $1/2$ or $6/10$");
        } else {
            return $._("a *simplified proper* fraction, like $3/5$");
        }
    },
    "improper": function(options) {
        if (options.simplify === "optional") {
            return $._("an *improper* fraction, like $10/7$ or $14/8$");
        } else {
            return $._("a *simplified improper* fraction, like $7/4$");
        }
    },
    "mixed": function(options) {
        return $._("a mixed number, like $1\\ 3/4$");
    },
    "decimal": function(options) {
        return $._("an *exact* decimal, like $0.75$");
    },
    "percent": function(options) {
        return $._("a percent, like $12.34\\%$");
    },
    "pi": function(options) {
        return $._("a multiple of pi, like $12\\ \\text{pi}$ or " +
                "$2/3\\ \\text{pi}$");
    }
};

var InputNumber = React.createClass({displayName: 'InputNumber',
    render: function() {
        // TODO(jack): Probably make this sync up with its props
        return React.DOM.input( {type:"text", className:
            "perseus-input-size-" + (this.props.size || "normal")} );
    },

    focus: function() {
        this.getDOMNode().focus();
        return true;
    },

    toJSON: function(skipValidation) {
        return {
            value: this.getDOMNode().value
        };
    },

    simpleValidate: function(rubric) {
        return InputNumber.validate(this.toJSON(), rubric);
    },

    examples: function() {
        var type = this.props.answerType || "number";
        var forms = answerTypes[type].forms.split(/\s*,\s*/);

        var examples = _.map(forms, function(form) {
            return formExamples[form](this.props);
        }, this);

        return examples;
    }
});

_.extend(InputNumber, {
    validate: function(state, rubric) {
        if (rubric.answerType == null) {
            rubric.answerType = "number";
        }
        var val = Khan.answerTypes.number.createValidatorFunctional(
            rubric.value, {
                simplify: rubric.simplify,
                inexact: rubric.inexact || undefined,
                maxError: rubric.maxError,
                forms: answerTypes[rubric.answerType].forms
            });

        var result = val(state.value);

        // TODO(eater): Seems silly to translate result to this invalid/points
        // thing and immediately translate it back in ItemRenderer.scoreInput()
        if (result.empty) {
            return {
                type: "invalid",
                message: result.message
            };
        } else {
            return {
                type: "points",
                earned: result.correct ? 1 : 0,
                total: 1,
                message: result.message
            };
        }
    }
});

var InputNumberEditor = React.createClass({displayName: 'InputNumberEditor',
    getDefaultProps: function() {
        return {
            value: "0",
            simplify: "required",
            size: "normal",
            inexact: false,
            maxError: 0.1,
            answerType: "number"
        };
    },

    handleAnswerChange: function(str) {
        var value = Util.firstNumericalParse(str) || 0;
        this.props.onChange({value: value});
    },

    render: function() {
        var answerTypeOptions = _.map(answerTypes, function(v, k) {
            return React.DOM.option( {value:k}, v.name);
        }, this);

        return React.DOM.div(null, 
            React.DOM.div(null, React.DOM.label(null, 
                " Correct answer: ",
                BlurInput( {value:"" + this.props.value,
                           onChange:this.handleAnswerChange,
                           ref:"input"} )
            )),

            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Unsimplified answers ",
                    React.DOM.select( {value:this.props.simplify,
                            onChange:function(e) {
                                this.props.onChange({simplify:
                                e.target.value});
                            }.bind(this)}, 
                        React.DOM.option( {value:"required"}, "will not be graded"),
                        React.DOM.option( {value:"optional"}, "will be accepted"),
                        React.DOM.option( {value:"enforced"}, "will be marked wrong")
                    )
                ),
                InfoTip(null, 
                    React.DOM.p(null, "Normally select \"will not be graded\". This will give the "+
                    "user a message saying the answer is correct but not "+
                    "simplified. The user will then have to simplify it and "+
                    "re-enter, but will not be penalized. (5th grade and "+
                    "anything after)"),
                    React.DOM.p(null, "Select \"will be accepted\" only if the user is not "+
                    "expected to know how to simplify fractions yet. (Anything "+
                    "prior to 5th grade)"),
                    React.DOM.p(null, "Select \"will be marked wrong\" only if we are "+
                    "specifically assessing the ability to simplify.")
                )
            ),

            React.DOM.div(null, React.DOM.label(null, 
                React.DOM.input( {type:"checkbox",
                    checked:this.props.inexact,
                    onChange:function(e) {
                        this.props.onChange({inexact: e.target.checked});
                    }.bind(this)} ),
                " Allow inexact answers "
            ),

            React.DOM.label(null, 
            React.DOM.input( /* TODO(emily): don't use a hidden checkbox for alignment */
                {type:"checkbox", style:{visibility: "hidden"}} ),
            " Max error: ",
            React.DOM.input( {type:"text", disabled:!this.props.inexact,
                defaultValue:this.props.maxError,
                onBlur:function(e) {
                    var ans = "" + (Util.firstNumericalParse(
                            e.target.value) || 0);
                    e.target.value = ans;
                    this.props.onChange({maxError: ans});
                }.bind(this)} )
            )),

            React.DOM.div(null, 
            " Answer type: ",
            React.DOM.select(
                {value:this.props.answerType,
                onChange:function(e) {
                    this.props.onChange({answerType: e.target.value});
                }.bind(this)}, 
                answerTypeOptions
            ),
            InfoTip(null, 
                React.DOM.p(null, "Use the default \"Numbers\" unless the answer must be in a "+
                "specific form (e.g., question is about converting decimals to "+
                "fractions).")
            )
            ),

            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Width ",
                    React.DOM.select( {value:this.props.size,
                            onChange:function(e) {
                                this.props.onChange({size: e.target.value});
                            }.bind(this)}, 
                        React.DOM.option( {value:"normal"}, "Normal (80px)"),
                        React.DOM.option( {value:"small"}, "Small (40px)")
                    )
                ),
                InfoTip(null, 
                    React.DOM.p(null, "Use size \"Normal\" for all text boxes, unless there are "+
                    "multiple text boxes in one line and the answer area is too "+
                    "narrow to fit them.")
                )
            )
        );
    },

    focus: function() {
        this.refs.input.getDOMNode().focus();
        return true;
    },

    toJSON: function() {
        return _.pick(this.props,
                "value", "simplify", "size", "inexact", "maxError",
                "answerType");
    }
});

Widgets.register("input-number", InputNumber);
Widgets.register("input-number-editor", InputNumberEditor);

})(Perseus);

},{"../components/blur-input.jsx":3,"../components/info-tip.jsx":6,"../core.js":11,"../util.js":19,"../widgets.js":20}],25:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");

var Graph         = require("../components/graph.jsx");
var GraphSettings = require("../components/graph-settings.jsx");
var InfoTip       = require("../components/info-tip.jsx");
var NumberInput   = require("../components/number-input.jsx");
var Widgets       = require("../widgets.js");
var kpoint        = KhanUtil.kpoint;

var DeprecationMixin = Util.DeprecationMixin;

var knumber = KhanUtil.knumber;

var TRASH_ICON_URI = 'https://ka-perseus-graphie.s3.amazonaws.com/b1452c0d79fd0f7ff4c3af9488474a0a0decb361.png';

var defaultBoxSize = 400;
var defaultEditorBoxSize = 340;
var defaultBackgroundImage = {
    url: null,
    scale: 1,
    bottom: 0,
    left: 0,
};

var eq = Util.eq;
var deepEq = Util.deepEq;

var UNLIMITED = "unlimited";

// Sample background image:
// https://ka-perseus-graphie.s3.amazonaws.com/29c1b0fcd17fe63df0f148fe357044d5d5c7d0bb.png

function ccw(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
}

function collinear(a, b, c) {
    return eq(ccw(a, b, c), 0);
}

function sign(val) {
    if (eq(val, 0)) {
        return 0;
    } else {
        return val > 0 ? 1 : -1;
    }    
}

// default to defaultValue if actual is null or undefined
function defaultVal(actual, defaultValue) {
    return (actual == null) ? defaultValue : actual;
}

// Given rect bounding points A and B, whether point C is inside the rect
function pointInRect(a, b, c) {
    return (c[0] <= Math.max(a[0], b[0]) && c[0] >= Math.min(a[0], b[0]) &&
            c[1] <= Math.max(a[1], b[1]) && c[1] >= Math.min(a[1], b[1]));
}

// Whether line segment AB intersects line segment CD
// http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
function intersects(ab, cd) {
    var triplets = [
        [ab[0], ab[1], cd[0]],
        [ab[0], ab[1], cd[1]],
        [cd[0], cd[1], ab[0]],
        [cd[0], cd[1], ab[1]],
    ];

    var orientations = _.map(triplets, function(triplet) {
        return sign(ccw.apply(null, triplet));
    });

    if (orientations[0] !== orientations[1] &&
        orientations[2] !== orientations[3]) {
        return true;
    }

    for (var i = 0; i < 4; i++) {
        if (orientations[i] === 0 && pointInRect.apply(null, triplets[i])) {
            return true;
        }
    }

    return false;
}

function vector(a, b) {
    return _.map(_.zip(a, b), function(pair) {
        return pair[0] - pair[1];
    });
}

function magnitude(v) {
    return Math.sqrt(_.reduce(v, function(memo, el) {
        return memo + Math.pow(el, 2);
    }, 0));
}

function dotProduct(a, b) {
    return _.reduce(_.zip(a, b), function(memo, pair) {
        return memo + pair[0] * pair[1];
    }, 0);
}

function sideLengths(coords) {
    var segments = _.zip(coords, rotate(coords));
    return _.map(segments, function(segment) {
        return magnitude(vector.apply(null, segment));
    });
}

// Based on http://math.stackexchange.com/a/151149
function angleMeasures(coords) {
    var triplets = _.zip(rotate(coords, -1), coords, rotate(coords, 1));

    var offsets = _.map(triplets, function(triplet) {
        var p = vector(triplet[1], triplet[0]);
        var q = vector(triplet[2], triplet[1]);
        var raw = Math.acos(dotProduct(p, q) / (magnitude(p) * magnitude(q)));
        return sign(ccw.apply(null, triplet)) > 0 ? raw : -raw;
    });

    var sum = _.reduce(offsets, function(memo, arg) { return memo + arg; }, 0);

    return _.map(offsets, function(offset) {
        return sum > 0 ? Math.PI - offset : Math.PI + offset;
    });
}

// Whether two polygons are similar (or if specified, congruent)
function similar(coords1, coords2, tolerance) {
    if (coords1.length !== coords2.length) {
        return false;
    }

    var n = coords1.length;

    var angles1 = angleMeasures(coords1);
    var angles2 = angleMeasures(coords2);

    var sides1 = sideLengths(coords1);
    var sides2 = sideLengths(coords2);

    for (var i = 0; i < 2 * n; i++) {
        var angles = angles2.slice();
        var sides = sides2.slice();

        // Reverse angles and sides to allow matching reflected polygons
        if (i >= n) {
            angles.reverse();
            sides.reverse();
            // Since sides are calculated from two coordinates,
            // simply reversing results in an off by one error
            sides = rotate(sides, 1);
        }

        angles = rotate(angles, i);
        sides = rotate(sides, i);

        if (deepEq(angles1, angles)) {
            var sidePairs = _.zip(sides1, sides);

            var factors = _.map(sidePairs, function(pair) {
                return pair[0] / pair[1];
            });

            var same = _.all(factors, function(factor) {
                return eq(factors[0], factor);
            });

            var congruentEnough = _.all(sidePairs, function(pair) {
                return knumber.equal(pair[0], pair[1], tolerance);
            });

            if (same && congruentEnough) {
                return true;
            }
        }
    }

    return false;
}

// Less than or approximately equal
function leq(a, b) {
    return a < b || eq(a, b);
}

// Given triangle with sides ABC return angle opposite side C in degrees
function lawOfCosines(a, b, c) {
    return Math.acos((a * a + b * b - c * c) / (2 * a * b)) * 180 / Math.PI;
}

// e.g. rotate([1, 2, 3]) -> [2, 3, 1]
function rotate(array, n) {
    n = (typeof n === "undefined") ? 1 : (n % array.length);
    return array.slice(n).concat(array.slice(0, n));
}

function capitalize(str) {
    return str.replace(/(?:^|-)(.)/g, function(match, letter) {
        return letter.toUpperCase();
    });
}

function getLineEquation(first, second) {
    if (eq(first[0], second[0])) {
        return "x = " + first[0].toFixed(3);
    } else {
        var m = (second[1] - first[1]) /
                (second[0] - first[0]);
        var b = first[1] - m * first[0];
        return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
    }
}

// Stolen from the wikipedia article
// http://en.wikipedia.org/wiki/Line-line_intersection
function getLineIntersection(firstPoints, secondPoints) {
    var x1 = firstPoints[0][0],
        y1 = firstPoints[0][1],
        x2 = firstPoints[1][0],
        y2 = firstPoints[1][1],
        x3 = secondPoints[0][0],
        y3 = secondPoints[0][1],
        x4 = secondPoints[1][0],
        y4 = secondPoints[1][1];

    var determinant = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

    if (Math.abs(determinant) < 1e-9) {
        return "Lines are parallel";
    } else {
        var x = ((x1 * y2 - y1 * x2) * (x3 - x4) -
                 (x1 - x2) * (x3 * y4 - y3 * x4)) / determinant;
        var y = ((x1 * y2 - y1 * x2) * (y3 - y4) -
                 (y1 - y2) * (x3 * y4 - y3 * x4)) / determinant;
        return "Intersection: (" + x.toFixed(3) + ", " + y.toFixed(3) + ")";
    }
}

function numSteps(range, step) {
    return Math.floor((range[1] - range[0]) / step);
}

var deprecatedProps = {
    showGraph: function(props) {
        return {markings: props.showGraph ? "graph" : "none"};
    }
};


var InteractiveGraph = React.createClass({displayName: 'InteractiveGraph',
    getDefaultProps: function() {
        var range = this.props.range || [[-10, 10], [-10, 10]];
        var step = this.props.step || [1, 1];
        var gridStep = this.props.gridStep ||
                   Util.getGridStep(range, step, defaultBoxSize);
        var snapStep = this.props.snapStep ||
                   Util.snapStepFromGridStep(gridStep);
        return {
            labels: ["x", "y"],
            range: range,
            box: [defaultBoxSize, defaultBoxSize],
            step: step,
            gridStep: gridStep,
            snapStep: snapStep,
            backgroundImage: defaultBackgroundImage,
            markings: "graph",
            showProtractor: false,
            graph: {
                type: "linear"
            }
        };
    },

    mixins: [DeprecationMixin],
    deprecatedProps: deprecatedProps,

    componentDidUpdate: function(prevProps, prevState, rootNode) {
        var oldType = prevProps.graph.type;
        var newType = this.props.graph.type;
        if (oldType !== newType ||
                prevProps.graph.allowReflexAngles !==
                    this.props.graph.allowReflexAngles ||
                prevProps.graph.angleOffsetDeg !==
                    this.props.graph.angleOffsetDeg ||
                prevProps.graph.numPoints !== this.props.graph.numPoints ||
                prevProps.graph.numSides !== this.props.graph.numSides ||
                prevProps.graph.numSegments !== this.props.graph.numSegments ||
                prevProps.graph.showAngles !== this.props.graph.showAngles ||
                prevProps.graph.showSides !== this.props.graph.showSides ||
                prevProps.graph.snapTo !== this.props.graph.snapTo ||
                prevProps.graph.snapDegrees !== this.props.graph.snapDegrees) {
            this["remove" + capitalize(oldType) + "Controls"]();
            this["add" + capitalize(newType) + "Controls"]();
        }
        if (this.shouldResetGraphie) {
            this.resetGraphie();
        }
    },

    pointsFromNormalized: function(coordsList, noSnap) {
        var self = this;
        return _.map(coordsList, function(coords) {
            return _.map(coords, function(coord, i) {
                var range = self.props.range[i];
                if (noSnap) {
                    return range[0] + (range[1] - range[0]) * coord;
                } else {
                    var step = self.props.step[i];
                    var nSteps = numSteps(range, step);
                    var tick = Math.round(coord * nSteps);
                    return range[0] + step * tick;
                }
            });
        });
    },

    render: function() {
        var typeSelect;
        var extraOptions;
        if (this.props.flexibleType) {
            typeSelect = React.DOM.select(
                    {value:this.props.graph.type,
                    onChange:function(e) {
                        var type = e.target.value;
                        this.props.onChange({
                            graph: {type: type}
                        });
                    }.bind(this)}, 
                React.DOM.option( {value:"linear"}, "Linear function"),
                React.DOM.option( {value:"quadratic"}, "Quadratic function"),
                React.DOM.option( {value:"circle"}, "Circle"),
                React.DOM.option( {value:"point"}, "Point(s)"),
                React.DOM.option( {value:"linear-system"}, "Linear System"),
                React.DOM.option( {value:"polygon"}, "Polygon"),
                React.DOM.option( {value:"segment"}, "Line Segment(s)"),
                React.DOM.option( {value:"ray"}, "Ray"),
                React.DOM.option( {value:"angle"}, "Angle")
            );

            if (this.props.graph.type === "point") {
                extraOptions = React.DOM.select(
                        {key:"point-select",
                        value:this.props.graph.numPoints || 1,
                        onChange:function(e) {
                            // Convert numbers, leave UNLIMITED intact:
                            var num = +e.target.value || e.target.value;
                            this.props.onChange({
                                graph: {
                                    type: "point",
                                    numPoints: num,
                                    coords: null
                                }
                            });
                        }.bind(this)}, 
                    _.map(_.range(1, 7), function(n) {
                        return React.DOM.option( {value:n}, 
                            n, " point",n > 1 && "s"
                        );
                    }),
                    React.DOM.option( {value:UNLIMITED}, "unlimited")
                );
            } else if (this.props.graph.type === "polygon") {
                extraOptions = React.DOM.div(null, 
                    React.DOM.div(null, 
                        React.DOM.select(
                            {key:"polygon-select",
                            value:this.props.graph.numSides || 3,
                            onChange:function(e) {
                                var num = +e.target.value;
                                var graph = _.extend({}, this.props.graph, {
                                    numSides: num,
                                    coords: null
                                });
                                this.props.onChange({graph: graph});
                            }.bind(this)}, 
                            _.map(_.range(3, 13), function(n) {
                                return React.DOM.option( {value:n}, n, " sides");
                            })
                        )
                    ),
                    React.DOM.div(null, 
                        React.DOM.label(null,  " Snap to ",
                            React.DOM.select(
                                {key:"polygon-snap",
                                value:this.props.graph.snapTo,
                                onChange:function(e) {
                                    var graph = _.extend({}, 
                                        this.props.graph,
                                        {
                                            snapTo: e.target.value,
                                            coords: null
                                        });
                                    this.props.onChange({graph: graph});
                                }.bind(this)}, 
                                React.DOM.option( {value:"grid"}, "grid"),
                                React.DOM.option( {value:"angles"}, "interior angles"),
                                React.DOM.option( {value:"sides"}, "side measures")
                            )
                        ),
                        InfoTip(null, 
                            React.DOM.p(null, "These options affect the movement of the vertex "+
                            "points. The grid option will guide the points to "+
                            "the nearest half step along the grid."),

                            React.DOM.p(null, "The interior angle and side measure options "+
                            "guide the points to the nearest whole angle or "+
                            "side"), " measure respectively. "
                        )
                    ),
                    React.DOM.div(null, 
                        React.DOM.label(null, "Show angle measures: ",
                            React.DOM.input( {type:"checkbox",
                                checked:this.props.graph.showAngles,
                                onClick:this.toggleShowAngles} )
                        ),
                        InfoTip(null, 
                            React.DOM.p(null, "Displays the interior angle measures.")
                        )
                    ),
                    React.DOM.div(null, 
                        React.DOM.label(null, "Show side measures: ",
                            React.DOM.input( {type:"checkbox",
                                checked:this.props.graph.showSides,
                                onClick:this.toggleShowSides} )
                        ),
                        InfoTip(null, 
                            React.DOM.p(null, "Displays the side lengths.")
                        )
                    )
                );
            } else if (this.props.graph.type === "segment") {
                extraOptions = React.DOM.select(
                        {key:"segment-select",
                        value:this.props.graph.numSegments || 1,
                        onChange:function(e) {
                            var num = +e.target.value;
                            this.props.onChange({
                                graph: {
                                    type: "segment",
                                    numSegments: num,
                                    coords: null
                                }
                            });
                        }.bind(this)}, 
                    _.map(_.range(1, 7), function(n) {
                        return React.DOM.option( {value:n}, 
                            n, " segment",n > 1 && "s"
                        );
                    })
                );
            } else if (this.props.graph.type === "angle") {
                var allowReflexAngles = defaultVal(
                    this.props.graph.allowReflexAngles,
                    true
                );
                extraOptions = React.DOM.div(null, 
                    React.DOM.div(null, 
                        React.DOM.label(null, "Show angle measure: ",
                            React.DOM.input( {type:"checkbox",
                                checked:this.props.graph.showAngles,
                                onClick:this.toggleShowAngles} )
                        )
                    ),
                    React.DOM.div(null, 
                        React.DOM.label(null, "Allow reflex angles: ",
                            React.DOM.input( {type:"checkbox",
                                checked:allowReflexAngles,
                                onClick:function(newVal) {
                                    this.props.onChange({
                                        graph: _.extend({}, this.props.graph, {
                                            allowReflexAngles:
                                                    !allowReflexAngles,
                                            coords: null
                                        })
                                    });
                                }.bind(this)} )
                        ),
                        InfoTip(null, 
                            React.DOM.p(null, 
                                " Reflex angles are angles with a measure "+
                                "greater than 180 degrees. "
                            ),
                            React.DOM.p(null, 
                                " By default, these should remain enabled. "
                            )
                        )
                    ),
                    React.DOM.div(null, 
                        React.DOM.label(null, "Snap to increments of ",
                            NumberInput(
                                {key:"degree-snap",
                                allowEmpty:false,
                                value:this.props.graph.snapDegrees || 1,
                                onChange:function(newVal) {
                                    this.props.onChange({
                                        graph: _.extend({}, this.props.graph, {
                                            snapDegrees: Math.abs(newVal),
                                            coords: null
                                        })
                                    });
                                }.bind(this)} ),
                            " degrees "
                        )
                    ),
                    React.DOM.div(null, 
                        React.DOM.label(null, 
                            " With an offset of ",
                            NumberInput(
                                {key:"angle-offset",
                                allowEmpty:false,
                                value:this.props.graph.angleOffsetDeg || 0,
                                onChange:function(newVal) {
                                    this.props.onChange({
                                        graph: _.extend({}, this.props.graph, {
                                            angleOffsetDeg: newVal,
                                            coords: null
                                        })
                                    });
                                }.bind(this)} ),
                            " degrees "
                        )
                    )
                );
            }
        }

        var box = this.props.box;

        var image = this.props.backgroundImage;
        if (image.url) {
            var preScale = box[0] / defaultBoxSize;
            var scale = image.scale * preScale;
            var style = {
                bottom: (preScale * image.bottom) + "px",
                left: (preScale * image.left) + "px",
                width: (scale * image.width) + "px",
                height: (scale * image.height) + "px"
            };
            image = React.DOM.img( {style:style, src:image.url} );
        } else {
            image = null;
        }

        var onClick = this.isClickToAddPoints() ?
            this.handleAddPointsClick :
            null;

        return React.DOM.div( {className:"perseus-widget " +
                    "perseus-widget-interactive-graph",
                    style:{
                        width: box[0],
                        height: this.props.flexibleType ? "auto" : box[1]
                    }}, 
            Graph(
                {ref:"graph",
                box:this.props.box,
                labels:this.props.labels,
                range:this.props.range,
                step:this.props.step,
                gridStep:this.props.gridStep,
                snapStep:this.props.snapStep,
                markings:this.props.markings,
                backgroundImage:this.props.backgroundImage,
                showProtractor:this.props.showProtractor,
                onClick:onClick,
                onNewGraphie:this.setGraphie} ),
            typeSelect,extraOptions
        );
    },

    setGraphie: function(newGraphie) {
        this.graphie = newGraphie;
        this.setupGraphie();
    },

    handleAddPointsClick: function(coord) {
        // This function should only be called when this.isClickToAddPoints()
        // is true
        if (!this.isClickToAddPoints()) {
            throw new Error("handleAddPointsClick should not be registered" +
                "when isClickToAddPoints() is false");
        }
        if (!this.isCoordInTrash(coord)) {
            this.points.push(
                this.createPointForPointsType(coord, this.points.length)
            );
            this.updateCoordsFromPoints();
        }
    },

    resetGraphie: function() {
        this.shouldResetGraphie = false;
        this.refs.graph.reset();
    },

    setupGraphie: function() {
        var graphie = this.graphie;

        if (this.isClickToAddPoints()) {
            var lowerLeft = graphie.unscalePoint([graphie.xpixels - 40,
                    graphie.ypixels]);
            var widthHeight = graphie.unscaleVector([40, 40]);
            graphie.raphael.image(TRASH_ICON_URI,
                graphie.xpixels - 40,
                graphie.ypixels - 40,
                40,
                40
            );

        }

        var type = this.props.graph.type;
        this["add" + capitalize(type) + "Controls"]();
    },

    componentWillReceiveProps: function(nextProps) {
        if (this.isClickToAddPoints() !== this.isClickToAddPoints(nextProps)) {
            this.shouldResetGraphie = true;
        }
    },

    isClickToAddPoints: function(props) {
        props = props || this.props;
        return props.graph.type === "point" &&
                props.graph.numPoints === UNLIMITED;
    },

    getEquationString: function() {
        var type = this.props.graph.type;
        return this["get" + capitalize(type) + "EquationString"]();
    },

    addLine: function(type) {
        var self = this;
        var graphie = self.graphie;
        var coords = InteractiveGraph.getLineCoords(self.props.graph, self);

        var pointA = self.pointA = graphie.addMovablePoint({
            coord: coords[0],
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            normalStyle: {
                stroke: KhanUtil.BLUE,
                fill: KhanUtil.BLUE
            }
        });

        var pointB = self.pointB = graphie.addMovablePoint({
            coord: coords[1],
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            normalStyle: {
                stroke: KhanUtil.BLUE,
                fill: KhanUtil.BLUE
            }
        });

        var lineConfig = {
            pointA: pointA,
            pointZ: pointB,
            fixed: true
        };

        if (type === "line") {
            lineConfig.extendLine = true;
        } else if (type === "ray") {
            lineConfig.extendRay = true;
        }

        var line = self.line = graphie.addMovableLineSegment(lineConfig);

        // A and B can't be in the same place
        pointA.onMove = function(x, y) {
            return !kpoint.equal([x, y], pointB.coord);
        };
        pointB.onMove = function(x, y) {
            return !kpoint.equal([x, y], pointA.coord);
        };

        $([pointA, pointB]).on("move", function() {
            var graph = _.extend({}, self.props.graph, {
                coords: [pointA.coord, pointB.coord]
            });
            self.props.onChange({graph: graph});
        });
    },

    removeLine: function() {
        this.pointA.remove();
        this.pointB.remove();
        this.line.remove();
    },

    addLinearControls: function() {
        this.addLine("line");
    },

    getLinearEquationString: function() {
        var coords = InteractiveGraph.getLineCoords(this.props.graph, this);
        if (eq(coords[0][0], coords[1][0])) {
            return "x = " + coords[0][0].toFixed(3);
        } else {
            var m = (coords[1][1] - coords[0][1]) /
                    (coords[1][0] - coords[0][0]);
            var b = coords[0][1] - m * coords[0][0];
            if (eq(m, 0)) {
                return "y = " + b.toFixed(3);
            } else {
                return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
            }
        }
    },

    removeLinearControls: function() {
        this.removeLine();
    },

    defaultQuadraticCoords: function() {
        var coords = [[0.25, 0.75], [0.5, 0.25], [0.75, 0.75]];
        return this.pointsFromNormalized(coords);
    },

    addQuadraticControls: function() {
        var graphie = this.graphie;
        var coords = this.props.graph.coords;
        if (!coords) {
            coords = this.defaultQuadraticCoords();
        }

        var pointA = this.pointA = graphie.addMovablePoint({
            coord: coords[0],
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            normalStyle: {
                stroke: KhanUtil.BLUE,
                fill: KhanUtil.BLUE
            }
        });

        var pointB = this.pointB = graphie.addMovablePoint({
            coord: coords[1],
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            normalStyle: {
                stroke: KhanUtil.BLUE,
                fill: KhanUtil.BLUE
            }
        });

        var pointC = this.pointC = graphie.addMovablePoint({
            coord: coords[2],
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            normalStyle: {
                stroke: KhanUtil.BLUE,
                fill: KhanUtil.BLUE
            }
        });

        // A, B, and C can't be in the same place
        pointA.onMove = function(x, y) {
            return x !== pointB.coord[0] && x !== pointC.coord[0];
        };
        pointB.onMove = function(x, y) {
            return x !== pointA.coord[0] && x !== pointC.coord[0];
        };
        pointC.onMove = function(x, y) {
            return x !== pointA.coord[0] && x !== pointB.coord[0];
        };

        this.updateQuadratic();

        $([pointA, pointB, pointC]).on("move", function() {
            var graph = _.extend({}, this.props.graph, {
                coords: [pointA.coord, pointB.coord, pointC.coord]
            });
            this.props.onChange({graph: graph});
            this.updateQuadratic();
        }.bind(this));
    },

    getQuadraticCoefficients: function() {
        // TODO(alpert): Don't duplicate
        var coords = this.props.graph.coords || this.defaultQuadraticCoords();
        return InteractiveGraph.getQuadraticCoefficients(coords);
    },

    getQuadraticEquationString: function() {
        var coeffs = this.getQuadraticCoefficients();
        return "y = " + coeffs[0].toFixed(3) + "x^2 + " +
                        coeffs[1].toFixed(3) + "x + " +
                        coeffs[2].toFixed(3);
    },

    updateQuadratic: function() {
        if (this.parabola) {
            this.parabola.remove();
        }

        var coeffs = this.getQuadraticCoefficients();
        if (!coeffs) {
            return;
        }

        var a = coeffs[0], b = coeffs[1], c = coeffs[2];
        this.parabola = this.graphie.plot(function(x) {
            return (a * x + b) * x + c;
        }, this.props.range[0]).attr({
            stroke: KhanUtil.BLUE
        });
        this.parabola.toBack();
    },

    removeQuadraticControls: function() {
        this.pointA.remove();
        this.pointB.remove();
        this.pointC.remove();
        if (this.parabola) {
            this.parabola.remove();
        }
    },

    addCircleControls: function() {
        var graphie = this.graphie;
        var minSnap = _.min(graphie.snap);

        var circle = this.circle = graphie.addCircleGraph({
            center: this.props.graph.center || [0, 0],
            radius: this.props.graph.radius || _.min(this.props.step),
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            minRadius: minSnap * 2,
            snapRadius: minSnap
        });

        $(circle).on("move", function() {
            var graph = _.extend({}, this.props.graph, {
                center: circle.center,
                radius: circle.radius
            });
            this.props.onChange({graph: graph});
        }.bind(this));
    },

    getCircleEquationString: function() {
        var graph = this.props.graph;
        // TODO(alpert): Don't duplicate
        var center = graph.center || [0, 0];
        var radius = graph.radius || 2;
        return "center (" + center[0] + ", " + center[1] + "), radius " +
                radius;
    },

    removeCircleControls: function() {
        this.circle.remove();
    },

    addLinearSystemControls: function() {
        var graphie = this.graphie;
        var coords = InteractiveGraph.getLinearSystemCoords(this.props.graph,
            this);

        var firstPoints = this.firstPoints = [
            graphie.addMovablePoint({
                coord: coords[0][0],
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    fill: KhanUtil.BLUE
                }
            }),
            graphie.addMovablePoint({
                coord: coords[0][1],
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    fill: KhanUtil.BLUE
                }
            })
        ];

        var secondPoints = this.secondPoints = [
            graphie.addMovablePoint({
                coord: coords[1][0],
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                normalStyle: {
                    stroke: KhanUtil.GREEN,
                    fill: KhanUtil.GREEN
                }
            }),
            graphie.addMovablePoint({
                coord: coords[1][1],
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                normalStyle: {
                    stroke: KhanUtil.GREEN,
                    fill: KhanUtil.GREEN
                }
            })
        ];

        var firstLine = this.firstLine = graphie.addMovableLineSegment({
            pointA: firstPoints[0],
            pointZ: firstPoints[1],
            fixed: true,
            extendLine: true,
            normalStyle: {
                stroke: KhanUtil.BLUE,
                "stroke-width": 2
            }
        });

        var secondLine = this.secondLine = graphie.addMovableLineSegment({
            pointA: secondPoints[0],
            pointZ: secondPoints[1],
            fixed: true,
            extendLine: true,
            normalStyle: {
                stroke: KhanUtil.GREEN,
                "stroke-width": 2
            }
        });

        _.each([firstPoints, secondPoints], function(points) {
            points[0].onMove = function(x, y) {
                return !_.isEqual([x, y], points[1].coord);
            };

            points[1].onMove = function(x, y) {
                return !_.isEqual([x, y], points[0].coord);
            };
        });

        $(firstPoints.concat(secondPoints)).on("move", function() {
            var graph = _.extend({}, this.props.graph, {
                coords: [
                    [firstPoints[0].coord, firstPoints[1].coord],
                    [secondPoints[0].coord, secondPoints[1].coord]
                ]
            });
            this.props.onChange({graph: graph});
        }.bind(this));
    },

    getLinearSystemEquationString: function() {
        var coords = InteractiveGraph.getLinearSystemCoords(this.props.graph,
            this);
        return "\n" +
            getLineEquation(coords[0][0], coords[0][1]) +
            "\n" +
            getLineEquation(coords[1][0], coords[1][1]) +
            "\n" +
            getLineIntersection(coords[0], coords[1]);
    },

    removeLinearSystemControls: function() {
        _.chain(this.firstPoints)
         .concat(this.secondPoints)
         .concat([this.firstLine, this.secondLine])
         .invoke("remove");
    },

    isCoordInTrash: function(coord) {
        var graphie = this.graphie;
        var screenPoint = graphie.scalePoint(coord);
        return screenPoint[0] >= graphie.xpixels - 40 &&
                screenPoint[1] >= graphie.ypixels - 40;
    },

    createPointForPointsType: function(coord, i) {
        var self = this;
        var graphie = self.graphie;
        var point = graphie.addMovablePoint({
            coord: coord,
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            normalStyle: {
                stroke: KhanUtil.BLUE,
                fill: KhanUtil.BLUE
            }
        });

        point.onMove = function(x, y) {
            for (var j = 0; j < self.points.length; j++) {
                if (i !== j && kpoint.equal([x, y], self.points[j].coord)) {
                    return false;
                }
            }
            return true;
        };

        $(point).on("move", this.updateCoordsFromPoints);

        if (self.isClickToAddPoints()) {
            point.onMoveEnd = function(x, y) {
                if (self.isCoordInTrash([x, y])) {
                    // remove this point from points
                    self.points = _.filter(self.points, function(pt) {
                        return pt !== point;
                    });
                    // update the correct answer box
                    self.updateCoordsFromPoints();

                    // remove this movablePoint from graphie.
                    // we wait to do this until we're not inside of
                    // said point's onMoveEnd method so its state is
                    // consistent throughout this method call
                    setTimeout(_.bind(point.remove, point), 0);
                }
                return true;
            };
        }

        return point;
    },

    updateCoordsFromPoints: function() {
        var graph = _.extend({}, this.props.graph, {
            coords: _.pluck(this.points, "coord")
        });
        this.props.onChange({graph: graph});
    },

    addPointControls: function() {
        var coords = InteractiveGraph.getPointCoords(this.props.graph, this);
        this.points = _.map(coords, this.createPointForPointsType, this);
    },

    getPointEquationString: function() {
        var coords = InteractiveGraph.getPointCoords(this.props.graph, this);
        return coords.map(function(coord) {
            return "(" + coord[0] + ", " + coord[1] + ")";
        }).join(", ");
    },

    removePointControls: function() {
        _.invoke(this.points, "remove");
    },

    addSegmentControls: function() {
        var graphie = this.graphie;

        var coords = InteractiveGraph.getSegmentCoords(this.props.graph, this);

        this.points = [];
        this.lines = _.map(coords, function(segment, i) {
            var pointA = graphie.addMovablePoint({
                coord: segment[0],
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    fill: KhanUtil.BLUE
                }
            });
            this.points.push(pointA);

            var pointB = graphie.addMovablePoint({
                coord: segment[1],
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    fill: KhanUtil.BLUE
                }
            });
            this.points.push(pointB);

            var line = graphie.addMovableLineSegment({
                pointA: pointA,
                pointZ: pointB,
                fixed: true
            });

            // A and B can't be in the same place
            pointA.onMove = function(x, y) {
                return !_.isEqual([x, y], pointB.coord);
            };
            pointB.onMove = function(x, y) {
                return !_.isEqual([x, y], pointA.coord);
            };

            $([pointA, pointB]).on("move", function() {
                var segments = _.map(this.lines, function(line) {
                    return [line.pointA.coord, line.pointZ.coord];
                });
                var graph = _.extend({}, this.props.graph, {
                    coords: segments
                });
                this.props.onChange({graph: graph});
            }.bind(this));

            return line;
        }, this);
    },

    removeSegmentControls: function() {
        _.invoke(this.points, "remove");
        _.invoke(this.lines, "remove");
    },

    getSegmentEquationString: function() {
        var segments = InteractiveGraph.getSegmentCoords(this.props.graph,
            this);
        return _.map(segments, function(segment) {
            return "[" +
                _.map(segment, function(coord) {
                    return "(" + coord.join(", ") + ")";
                }).join(" ") +
            "]";
        }).join(" ");
    },

    addRayControls: function() {
        this.addLine("ray");
    },

    removeRayControls: function() {
        this.removeLine();
    },

    getRayEquationString: function() {
        var coords = InteractiveGraph.getLineCoords(this.props.graph, this);
        var a = coords[0];
        var b = coords[1];
        var eq = this.getLinearEquationString();

        if (a[0] > b[0]) {
            eq += " (for x <= " + a[0].toFixed(3) + ")";
        } else if (a[0] < b[0]) {
            eq += " (for x >= " + a[0].toFixed(3) + ")";
        } else if (a[1] > b[1]) {
            eq += " (for y <= " + a[1].toFixed(3) + ")";
        } else {
            eq += " (for y >= " + a[1].toFixed(3) + ")";
        }

        return eq;
    },

    addPolygonControls: function() {
        var graphie = this.graphie;

        var coords = InteractiveGraph.getPolygonCoords(this.props.graph, this);
        var n = coords.length;

        // TODO(alex): check against "grid" instead, use constants
        var snapToGrid = !_.contains(["angles", "sides"],
            this.props.graph.snapTo);

        this.points = _.map(coords, function(coord, i) {
            var point = graphie.addMovablePoint(_.extend({
                coord: coord,
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    fill: KhanUtil.BLUE
                }
            }, snapToGrid ? {
                snapX: graphie.snap[0],
                snapY: graphie.snap[1]
            } : {}
            ));

            // Index relative to current point -> absolute index
            function rel(j) {
                return (i + j + n) % n;
            }

            point.onMove = function(x, y) {
                var coords = _.pluck(this.points, "coord");
                coords[i] = [x, y];

                // Polygons can't have consecutive collinear points
                if (collinear(coords[rel(-2)], coords[rel(-1)], coords[i]) ||
                    collinear(coords[rel(-1)], coords[i],  coords[rel(1)]) ||
                    collinear(coords[i],  coords[rel(1)],  coords[rel(2)])) {
                    return false;
                }

                var segments = _.zip(coords, rotate(coords));

                if (n > 3) {
                    // Constrain to simple (non self-intersecting) polygon by
                    // testing whether adjacent segments intersect any others
                    for (var j = -1; j <= 0; j++) {
                        var segment = segments[rel(j)];
                        var others = _.without(segments,
                            segment, segments[rel(j-1)], segments[rel(j+1)]);

                        for (var k = 0; k < others.length; k++) {
                            var other = others[k];
                            if (intersects(segment, other)) {
                                return false;
                            }
                        }
                    }
                }

                if (this.props.graph.snapTo === "angles") {
                    // Snap to whole degree interior angles

                    var angles = _.map(angleMeasures(coords), function(rad) {
                        return rad * 180 / Math.PI;
                    });

                    _.each([-1, 1], function(j) {
                        angles[rel(j)] = Math.round(angles[rel(j)]);
                    });

                    var getAngle = function(a, vertex, b) {
                        var angle = KhanUtil.findAngle(
                            coords[rel(a)], coords[rel(b)], coords[rel(vertex)]
                        );
                        return (angle + 360) % 360;
                    };

                    var innerAngles = [
                        angles[rel(-1)] - getAngle(-2, -1, 1),
                        angles[rel(1)] - getAngle(-1, 1, 2)
                    ];
                    innerAngles[2] = 180 - (innerAngles[0] + innerAngles[1]);

                    // Avoid degenerate triangles
                    if (_.any(innerAngles, function(angle) {
                                return leq(angle, 1);
                            })) {
                        return false;
                    }

                    var knownSide = magnitude(vector(coords[rel(-1)],
                        coords[rel(1)]));

                    var onLeft = sign(ccw(
                        coords[rel(-1)], coords[rel(1)], coords[i]
                    )) === 1;

                    // Solve for side by using the law of sines
                    var side = Math.sin(innerAngles[1] * Math.PI / 180) /
                        Math.sin(innerAngles[2] * Math.PI / 180) * knownSide;

                    var outerAngle = KhanUtil.findAngle(coords[rel(1)],
                        coords[rel(-1)]);

                    var offset = this.graphie.polar(
                        side,
                        outerAngle + (onLeft? 1 : -1) * innerAngles[0]
                    );

                    return this.graphie.addPoints(coords[rel(-1)], offset);


                } else if (this.props.graph.snapTo === "sides") {
                    // Snap to whole unit side measures

                    var sides = _.map([
                        [coords[rel(-1)], coords[i]],
                        [coords[i], coords[rel(1)]],
                        [coords[rel(-1)], coords[rel(1)]]
                    ], function(coords) {
                        return magnitude(vector.apply(null, coords));
                    });

                    _.each([0, 1], function(j) {
                        sides[j] = Math.round(sides[j]);
                    });

                    // Avoid degenerate triangles
                    if (leq(sides[1] + sides[2], sides[0]) ||
                            leq(sides[0] + sides[2], sides[1]) ||
                            leq(sides[0] + sides[1], sides[2])) {
                        return false;
                    }

                    // Solve for angle by using the law of cosines
                    var innerAngle = lawOfCosines(sides[0],
                        sides[2], sides[1]);

                    var outerAngle = KhanUtil.findAngle(coords[rel(1)],
                        coords[rel(-1)]);

                    var onLeft = sign(ccw(
                        coords[rel(-1)], coords[rel(1)], coords[i]
                    )) === 1;

                    var offset = this.graphie.polar(
                        sides[0],
                        outerAngle + (onLeft ? 1 : -1) * innerAngle
                    );

                    return this.graphie.addPoints(coords[rel(-1)], offset);

                } else {
                    // Snap to grid (already done)
                    return true;
                }

            }.bind(this);

            $(point).on("move", function() {
                var graph = _.extend({}, this.props.graph, {
                    coords: _.pluck(this.points, "coord")
                });
                this.props.onChange({graph: graph});
            }.bind(this));

            return point;
        }, this);

        var angleLabels = _.times(n, function() {
            if (!this.props.graph.showAngles) {
                return "";
            } else if (this.props.graph.snapTo === "angles") {
                return "$deg0";
            } else {
                return "$deg1";
            }
        }, this);

        var numArcs = _.times(n, function() {
            return this.props.graph.showAngles ? 1 : 0;
        }, this);

        var sideLabels = _.times(n, function() {
            if (!this.props.graph.showSides) {
                return "";
            } else if (this.props.graph.snapTo === "sides") {
                return "$len0";
            } else {
                return "$len1";
            }
        }, this);

        this.polygon = graphie.addMovablePolygon(_.extend({
            points: this.points,
            angleLabels: angleLabels,
            numArcs: numArcs,
            sideLabels: sideLabels
        }, snapToGrid ? {
            snapX: graphie.snap[0],
            snapY: graphie.snap[1]
        } : {}
        ));

        $(this.polygon).on("move", function() {
            var graph = _.extend({}, this.props.graph, {
                coords: _.pluck(this.points, "coord")
            });
            this.props.onChange({graph: graph});
        }.bind(this));
    },

    removePolygonControls: function() {
        _.invoke(this.points, "remove");
        this.polygon.remove();
    },

    getPolygonEquationString: function() {
        var coords = InteractiveGraph.getPolygonCoords(this.props.graph, this);
        return _.map(coords, function(coord) {
            return "(" + coord.join(", ") + ")";
        }).join(" ");
    },

    addAngleControls: function() {
        var graphie = this.graphie;

        var coords = InteractiveGraph.getAngleCoords(this.props.graph, this);

        // The vertex snaps to the grid, but the rays don't...
        this.points = _.map(coords, function(coord, i) {
            return graphie.addMovablePoint(_.extend({
                coord: coord,
                normalStyle: {
                    stroke: KhanUtil.BLUE,
                    fill: KhanUtil.BLUE
                }
            }, i === 1 ? {
                snapX: graphie.snap[0],
                snapY: graphie.snap[1]
            } : {}));
        });

        // ...they snap to whole-degree angles from the vertex.
        this.angle = graphie.addMovableAngle({
            points: this.points,
            snapDegrees: this.props.graph.snapDegrees || 1,
            snapOffsetDeg: this.props.graph.angleOffsetDeg || 0,
            angleLabel: this.props.graph.showAngles ? "$deg0" : "",
            pushOut: 2,
            allowReflex: defaultVal(this.props.graph.allowReflexAngles, true)
        });

        $(this.angle).on("move", function() {
            var graph = _.extend({}, this.props.graph, {
                coords: this.angle.getClockwiseCoords()
            });
            this.props.onChange({graph: graph});
        }.bind(this));
    },

    removeAngleControls: function() {
        _.invoke(this.points, "remove");
        this.angle.remove();
    },

    getAngleEquationString: function() {
        var coords = InteractiveGraph.getAngleCoords(this.props.graph, this);
        var angle = KhanUtil.findAngle(coords[2], coords[0], coords[1]);
        return angle.toFixed(0) + "\u00B0 angle" +
                " at (" + coords[1].join(", ") + ")";
    },

    toggleShowAngles: function() {
        var graph = _.extend({}, this.props.graph, {
            showAngles: !this.props.graph.showAngles
        });
        this.props.onChange({graph: graph});
    },

    toggleShowSides: function() {
        var graph = _.extend({}, this.props.graph, {
            showSides: !this.props.graph.showSides
        });
        this.props.onChange({graph: graph});
    },

    toJSON: function() {
        return this.props.graph;
    },

    simpleValidate: function(rubric) {
        return InteractiveGraph.validate(this.toJSON(), rubric, this);
    },

    focus: $.noop
});


_.extend(InteractiveGraph, {
    getQuadraticCoefficients: function(coords) {
        var p1 = coords[0];
        var p2 = coords[1];
        var p3 = coords[2];

        var denom = (p1[0] - p2[0]) * (p1[0] - p3[0]) * (p2[0] - p3[0]);
        if (denom === 0) {
            return;
        }
        var a = (p3[0] * (p2[1] - p1[1]) +
                 p2[0] * (p1[1] - p3[1]) +
                 p1[0] * (p3[1] - p2[1])) / denom;
        var b = ((p3[0] * p3[0]) * (p1[1] - p2[1]) +
                 (p2[0] * p2[0]) * (p3[1] - p1[1]) +
                 (p1[0] * p1[0]) * (p2[1] - p3[1])) / denom;
        var c = (p2[0] * p3[0] * (p2[0] - p3[0]) * p1[1] +
                 p3[0] * p1[0] * (p3[0] - p1[0]) * p2[1] +
                 p1[0] * p2[0] * (p1[0] - p2[0]) * p3[1]) / denom;
        return [a, b, c];
    },

    /**
     * @param {object} graph Like props.graph or props.correct
     * @param {object} component InteractiveGraph instance
     */
    getLineCoords: function(graph, component) {
        return graph.coords ||
            component.pointsFromNormalized([[0.25, 0.75], [0.75, 0.75]]);
    },

    /**
     * @param {object} graph Like props.graph or props.correct
     * @param {object} component InteractiveGraph instance
     */
    getPointCoords: function(graph, component) {
        var numPoints = graph.numPoints || 1;
        var coords = graph.coords;

        if (coords) {
            return coords;
        } else {
            switch (numPoints) {
                case 1:
                    // Back in the day, one point's coords were in graph.coord
                    coords = [graph.coord || [0, 0]];
                    break;
                case 2:
                    coords = [[-5, 0], [5, 0]];
                    break;
                case 3:
                    coords = [[-5, 0], [0, 0], [5, 0]];
                    break;
                case 4:
                    coords = [[-6, 0], [-2, 0], [2, 0], [6, 0]];
                    break;
                case 5:
                    coords = [[-6, 0], [-3, 0], [0, 0], [3, 0], [6, 0]];
                    break;
                case 6:
                    coords = [[-5, 0], [-3, 0], [-1, 0], [1, 0], [3, 0],
                              [5, 0]];
                    break;
                case UNLIMITED:
                    coords = [];
                    break;
            }
            // Transform coords from their -10 to 10 space to 0 to 1
            // because of the old graph.coord, and also it's easier.
            var range = [[-10, 10], [-10, 10]];
            coords = InteractiveGraph.normalizeCoords(coords, range);

            var coords = component.pointsFromNormalized(coords);
            return coords;
        }
    },

    /**
     * @param {object} graph Like props.graph or props.correct
     * @param {object} component InteractiveGraph instance
     */
    getLinearSystemCoords: function(graph, component) {
        return graph.coords ||
            _.map([
                [[0.25, 0.75], [0.75, 0.75]],
                [[0.25, 0.25], [0.75, 0.25]]
            ], component.pointsFromNormalized, component);
    },

    /**
     * @param {object} graph Like props.graph or props.correct
     * @param {object} component InteractiveGraph instance
     */
    getPolygonCoords: function(graph, component) {
        var coords = graph.coords;
        if (coords) {
            return coords;
        }

        var n = graph.numSides || 3;
        var angle = 2 * Math.PI / n;
        var offset = (1 / n - 1 / 2) * Math.PI;

        // TODO(alex): Generalize this to more than just triangles so that
        // all polygons have whole number side lengths if snapping to sides
        var radius = graph.snapTo === "sides" ? Math.sqrt(3) / 3 * 7: 4;

        // Generate coords of a regular polygon with n sides
        coords = _.times(n, function(i) {
            return [
                radius * Math.cos(i * angle + offset),
                radius * Math.sin(i * angle + offset)
            ];
        });

        var range = [[-10, 10], [-10, 10]];
        coords = InteractiveGraph.normalizeCoords(coords, range);

        var snapToGrid = !_.contains(["angles", "sides"], graph.snapTo);
        coords = component.pointsFromNormalized(coords,
            /* noSnap */ !snapToGrid);

        return coords;
    },

    /**
     * @param {object} graph Like props.graph or props.correct
     * @param {object} component InteractiveGraph instance
     */
    getSegmentCoords: function(graph, component) {
        var coords = graph.coords;
        if (coords) {
            return coords;
        }

        var n = graph.numSegments || 1;
        var ys = {
            1: [5],
            2: [5, -5],
            3: [5, 0, -5],
            4: [6, 2, -2, -6],
            5: [6, 3, 0, -3, -6],
            6: [5, 3, 1, -1, -3, -5],
        }[n];
        var range = [[-10, 10], [-10, 10]];

        return _.map(ys, function(y) {
            var segment = [[-5, y], [5, y]];
            segment = InteractiveGraph.normalizeCoords(segment, range);
            segment = component.pointsFromNormalized(segment);
            return segment;
        });
    },

    /**
     * @param {object} graph Like props.graph or props.correct
     * @param {object} component InteractiveGraph instance
     */
    getAngleCoords: function(graph, component) {
        var coords = graph.coords;
        if (coords) {
            return coords;
        }

        var snap = graph.snapDegrees || 1;
        var angle = snap;
        while (angle < 20) {
            angle += snap;
        }
        angle = angle * Math.PI / 180;
        var offset = (graph.angleOffsetDeg || 0) * Math.PI / 180;

        coords = component.pointsFromNormalized([
            [0.85, 0.50],
            [0.5, 0.50]
        ]);

        var radius = magnitude(vector.apply(null, coords));

        // Adjust the lower point by angleOffsetDeg degrees
        coords[0] = [
            coords[1][0] + radius * Math.cos(offset),
            coords[1][1] + radius * Math.sin(offset)
        ];
        // Position the upper point angle radians from the
        // lower point
        coords[2] = [
            coords[1][0] + radius * Math.cos(angle + offset),
            coords[1][1] + radius * Math.sin(angle + offset)
        ];

        return coords;
    },

    normalizeCoords: function(coordsList, range) {
        return _.map(coordsList, function(coords) {
            return _.map(coords, function(coord, i) {
                var extent = range[i][1] - range[i][0];
                return ((coord + range[i][1]) / extent);
            });
        });
    },

    validate: function(state, rubric, component) {
        // TODO(alpert): Because this.props.graph doesn't always have coords,
        // check that .coords exists here, which is always true when something
        // has moved
        if (state.type === rubric.correct.type && state.coords) {
            if (state.type === "linear") {
                var guess = state.coords;
                var correct = rubric.correct.coords;
                // If both of the guess points are on the correct line, it's
                // correct.
                if (collinear(correct[0], correct[1], guess[0]) &&
                        collinear(correct[0], correct[1], guess[1])) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            } else if (state.type === "linear-system") {
                var guess = state.coords;
                var correct = rubric.correct.coords;

                if ((
                        collinear(correct[0][0], correct[0][1], guess[0][0]) &&
                        collinear(correct[0][0], correct[0][1], guess[0][1]) &&
                        collinear(correct[1][0], correct[1][1], guess[1][0]) &&
                        collinear(correct[1][0], correct[1][1], guess[1][1])
                    ) || (
                        collinear(correct[0][0], correct[0][1], guess[1][0]) &&
                        collinear(correct[0][0], correct[0][1], guess[1][1]) &&
                        collinear(correct[1][0], correct[1][1], guess[0][0]) &&
                        collinear(correct[1][0], correct[1][1], guess[0][1])
                    )) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }

            } else if (state.type === "quadratic") {
                // If the parabola coefficients match, it's correct.
                var guessCoeffs = this.getQuadraticCoefficients(state.coords);
                var correctCoeffs = this.getQuadraticCoefficients(
                        rubric.correct.coords);
                if (deepEq(guessCoeffs, correctCoeffs)) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            } else if (state.type === "circle") {
                if (deepEq(state.center, rubric.correct.center) &&
                        eq(state.radius, rubric.correct.radius)) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            } else if (state.type === "point") {
                var guess = state.coords;
                var correct = InteractiveGraph.getPointCoords(
                        rubric.correct, component);
                guess = guess.slice();
                correct = correct.slice();
                // Everything's already rounded so we shouldn't need to do an
                // eq() comparison but _.isEqual(0, -0) is false, so we'll use
                // eq() anyway. The sort should be fine because it'll stringify
                // it and -0 converted to a string is "0"
                guess.sort();
                correct.sort();
                if (deepEq(guess, correct)) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            } else if (state.type === "polygon") {
                var guess = state.coords.slice();
                var correct = rubric.correct.coords.slice();

                var match;
                if (rubric.correct.match === "similar") {
                    match = similar(guess, correct, Number.POSITIVE_INFINITY);
                } else if (rubric.correct.match === "congruent") {
                    match = similar(guess, correct, knumber.DEFAULT_TOLERANCE);
                } else if (rubric.correct.match === "approx") {
                    match = similar(guess, correct, 0.1);
                } else { /* exact */
                    guess.sort();
                    correct.sort();
                    match = deepEq(guess, correct);
                } 

                if (match) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            } else if (state.type === "segment") {
                var guess = state.coords.slice();
                var correct = rubric.correct.coords.slice();
                guess = _.invoke(guess, "sort").sort();
                correct = _.invoke(correct, "sort").sort();
                if (deepEq(guess, correct)) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            } else if (state.type === "ray") {
                var guess = state.coords;
                var correct = rubric.correct.coords;
                if (deepEq(guess[0], correct[0]) && 
                        collinear(correct[0], correct[1], guess[1])) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            } else if (state.type === "angle") {
                var guess = state.coords;
                var correct = rubric.correct.coords;

                var match;
                if (rubric.correct.match === "congruent") {
                    var angles = _.map([guess, correct], function(coords) {
                        var angle = KhanUtil.findAngle(
                            coords[2], coords[0], coords[1]);
                        return (angle + 360) % 360;
                    });
                    match = eq.apply(null, angles);
                } else { /* exact */
                    match = deepEq(guess[1], correct[1]) && 
                            collinear(correct[1], correct[0], guess[0]) &&
                            collinear(correct[1], correct[2], guess[2]);
                }

                if (match) {
                    return {
                        type: "points",
                        earned: 1,
                        total: 1,
                        message: null
                    };
                }
            }
        }

        // The input wasn't correct, so check if it's a blank input or if it's
        // actually just wrong
        if (_.isEqual(state, rubric.graph)) {
            // We're where we started.
            return {
                type: "invalid",
                message: null
            };
        } else {
            return {
                type: "points",
                earned: 0,
                total: 1,
                message: null
            };
        }
    }
});

var InteractiveGraphEditor = React.createClass({displayName: 'InteractiveGraphEditor',
    className: "perseus-widget-interactive-graph",

    getDefaultProps: function() {
        var range = this.props.range || [[-10, 10], [-10, 10]];
        var step = this.props.step || [1, 1];
        var gridStep = this.props.gridStep ||
                   Util.getGridStep(range, step, defaultEditorBoxSize);
        var snapStep = this.props.snapStep ||
                   Util.snapStepFromGridStep(gridStep);
        return {
            box: [defaultEditorBoxSize, defaultEditorBoxSize],
            labels: ["x", "y"],
            range: range,
            step: step,
            gridStep: gridStep,
            snapStep: snapStep,
            valid: true,
            backgroundImage: defaultBackgroundImage,
            markings: "graph",
            showProtractor: false,
            correct: {
                type: "linear",
                coords: null
            }
        };
    },

    mixins: [DeprecationMixin],
    deprecatedProps: deprecatedProps,

    render: function() {
        var graph;
        var equationString;

        if (this.props.valid === true) {
            graph = InteractiveGraph(
                {ref:"graph",
                box:this.props.box,
                range:this.props.range,
                labels:this.props.labels,
                step:this.props.step,
                gridStep:this.props.gridStep,
                snapStep:this.props.snapStep,
                graph:this.props.correct,
                backgroundImage:this.props.backgroundImage,
                markings:this.props.markings,
                showProtractor:this.props.showProtractor,
                flexibleType:true,
                onChange:function(newProps) {
                    var correct = this.props.correct;
                    if (correct.type === newProps.graph.type) {
                        correct = _.extend({}, correct, newProps.graph);
                    } else {
                        // Clear options from previous graph
                        correct = newProps.graph;
                    }
                    this.props.onChange({correct: correct});
                }.bind(this)} );
            equationString = graph.getEquationString();
        } else {
            graph = React.DOM.div(null, this.props.valid);
        }

        return React.DOM.div( {className:"perseus-widget-interactive-graph"}, 
            React.DOM.div(null, "Correct answer ",
                InfoTip(null, 
                    React.DOM.p(null, "Graph the correct answer in the graph below and ensure "+
                    "the equation or point coordinates displayed represent the "+
                    "correct answer.")
                ),
                " : ", equationString),


            GraphSettings(
                {box:this.props.box,
                range:this.props.range,
                labels:this.props.labels,
                step:this.props.step,
                gridStep:this.props.gridStep,
                snapStep:this.props.snapStep,
                valid:this.props.valid,
                backgroundImage:this.props.backgroundImage,
                markings:this.props.markings,
                showProtractor:this.props.showProtractor,
                onChange:this.props.onChange} ),


            this.props.correct.type === "polygon" &&
            React.DOM.div( {className:"type-settings"}, 
                React.DOM.label(null, 
                    " Student answer must ",
                    React.DOM.select(
                            {value:this.props.correct.match,
                            onChange:this.changeMatchType}, 
                        React.DOM.option( {value:"exact"}, "match exactly"),
                        React.DOM.option( {value:"congruent"}, "be congruent"),
                        React.DOM.option( {value:"approx"}, "be approximately congruent"),
                        React.DOM.option( {value:"similar"}, "be similar")
                    )
                ),
                InfoTip(null, 
                    React.DOM.ul(null, 
                        React.DOM.li(null, 
                            React.DOM.p(null, React.DOM.b(null, "Match Exactly:"), " Match exactly in size, "+
                            "orientation, and location on the grid even if it is "+
                            "not shown in the background.")
                        ),
                        React.DOM.li(null, 
                            React.DOM.p(null, React.DOM.b(null, "Be Congruent:"), " Be congruent in size and "+
                            "shape, but can be located anywhere on the grid.")
                        ),
                        React.DOM.li(null, 
                            React.DOM.p(null, 
                                React.DOM.b(null, "Be Approximately Congruent:"),
                                " Be exactly similar, and congruent in size and "+
                                "shape to within 0.1 units, but can be located "+
                                "anywhere on the grid. ", React.DOM.em(null, "Use this with "+
                                "snapping to angle measure.")
                            )
                        ),
                        React.DOM.li(null, 
                            React.DOM.p(null, React.DOM.b(null, "Be Similar:"), " Be similar with matching "+
                            "interior angles, and side measures that are "+
                            "matching or a multiple of the correct side "+
                            "measures. The figure can be located anywhere on the "+
                            "grid.")
                        )
                    )
                )
            ),
            this.props.correct.type === "angle" &&
            React.DOM.div( {className:"type-settings"}, 
                React.DOM.div(null, 
                    React.DOM.label(null, 
                        " Student answer must ",
                        React.DOM.select(
                                {value:this.props.correct.match,
                                onChange:this.changeMatchType}, 
                            React.DOM.option( {value:"exact"}, "match exactly"),
                            React.DOM.option( {value:"congruent"}, "be congruent")
                        )
                    ),
                    InfoTip(null, 
                        React.DOM.p(null, "Congruency requires only that the angle measures are "+
                        "the same. An exact match implies congruency, but also "+
                        "requires that the angles have the same orientation and "+
                        "that the vertices are in the same position.")
                    )
                )
            ),
            graph
        );
    },

    changeMatchType: function(e) {
        var correct = _.extend({}, this.props.correct, {
            match: e.target.value
        });
        this.props.onChange({correct: correct});
    },

    toJSON: function() {
        var json = _.pick(this.props, "step", "backgroundImage", "markings",
                          "labels", "showProtractor", "range", "gridStep",
                         "snapStep");

        var graph = this.refs.graph;
        if (graph) {
            var correct = graph && graph.toJSON();
            _.extend(json, {
                // TODO(alpert): Allow specifying flexibleType (whether the
                // graph type should be a choice or not)
                graph: {type: correct.type},
                correct: correct
            });

            _.each(["allowReflexAngles", "angleOffsetDeg", "numPoints",
                        "numSides", "numSegments", "showAngles", "showSides",
                        "snapTo", "snapDegrees"],
                    function(key) {
                        if (_.has(correct, key)) {
                            json.graph[key] = correct[key];
                        }
                    });
        }
        return json;
    }
});

Widgets.register("interactive-graph", InteractiveGraph);
Widgets.register("interactive-graph-editor", InteractiveGraphEditor);

})(Perseus);

},{"../components/graph-settings.jsx":4,"../components/graph.jsx":5,"../components/info-tip.jsx":6,"../components/number-input.jsx":7,"../core.js":11,"../util.js":19,"../widgets.js":20}],26:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");
require("../widgets.js");

var InfoTip      = require("../components/info-tip.jsx");
var PropCheckBox = require("../components/prop-check-box.jsx");

function eq(x, y) {
    return Math.abs(x - y) < 1e-9;
}

var reverseRel = {
    ge: "le",
    gt: "lt",
    le: "ge",
    lt: "gt"
};

var toggleStrictRel = {
    ge: "gt",
    gt: "ge",
    le: "lt",
    lt: "le"
};

function formatImproper(n, d) {
    if (d === 1) {
        return "" + n;
    } else {
        return n + "/" + d;
    }
}

function formatMixed(n, d) {
    if (n < 0) {
        return "-" + formatMixed(-n, d);
    }
    var w = Math.floor(n / d);
    if (w === 0) {
        return formatImproper(n, d);
    } else {
        return w + "\\:" + formatImproper(n - w * d, d);
    }
}

var InteractiveNumberLine = React.createClass({displayName: 'InteractiveNumberLine',
    getDefaultProps: function() {
        return {
            labelStyle: "decimal",
            labelTicks: false,
            isInequality: false,
            pointX: 0,
            rel: "ge"
        };
    },

    isValid: function() {
        return this.props.range[0] < this.props.range[1] &&
                0 < this.props.tickStep &&
                0 < this.props.snapDivisions;
    },

    render: function() {
        var inequalityControls;
        if (this.props.isInequality) {
            inequalityControls = React.DOM.div(null, 
                React.DOM.input( {type:"button", value:"Switch direction",
                    onClick:this.handleReverse} ),
                React.DOM.input( {type:"button",
                    value:
                        this.props.rel === "le" || this.props.rel === "ge" ?
                            "Make circle open" :
                            "Make circle filled",
                        
                    onClick:this.handleToggleStrict} )
            );
        }

        var valid = this.isValid();
        return React.DOM.div( {className:"perseus-widget " +
                "perseus-widget-interactive-number-line"}, 
            React.DOM.div( {style:{display: valid ? "" : "none"},
                    className:"graphie", ref:"graphieDiv"} ),
            React.DOM.div( {style:{display: valid ? "none" : ""}}, 
                " invalid number line configuration "
            ),
            inequalityControls
        );
    },

    handleReverse: function() {
        this.props.onChange({rel: reverseRel[this.props.rel]});
    },

    handleToggleStrict: function() {
        this.props.onChange({rel: toggleStrictRel[this.props.rel]});
    },

    componentDidMount: function() {
        this.addGraphie();
    },

    componentDidUpdate: function() {
        // Use jQuery to remove so event handlers don't leak
        var node = this.refs.graphieDiv.getDOMNode();
        $(node).children().remove();

        this.addGraphie();
    },

    _label: function(value) {
        var graphie = this.graphie;
        var labelStyle = this.props.labelStyle;

        // TODO(jack): Find out if any exercises have "decimal ticks" set,
        // and if so, re-save them and remove this check.
        if (labelStyle === "decimal" || labelStyle === "decimal ticks") {
            graphie.label([value, -0.53], value, "center");
        } else if (labelStyle === "improper") {
            var frac = KhanUtil.toFraction(value);
            graphie.label([value, -0.53],
                    formatImproper(frac[0], frac[1]), "center");
        } else if (labelStyle === "mixed") {
            var frac = KhanUtil.toFraction(value);
            graphie.label([value, -0.53],
                    formatMixed(frac[0], frac[1]), "center");
        }
    },

    addGraphie: function() {
        var self = this;
        var graphie = this.graphie = KhanUtil.createGraphie(
                this.refs.graphieDiv.getDOMNode());
        // Ensure a sane configuration to avoid infinite loops
        if (!this.isValid()) {
            return;
        }

        var range = this.props.range;
        var tickStep = this.props.tickStep;
        var scale = 400 / (range[1] - range[0]);

        graphie.init({
            range: [[range[0] - 30 / scale,
                     range[1] + 30 / scale],
                    [-1, 1]],
            scale: [scale, 40]
        });
        graphie.addMouseLayer();

        // Line

        graphie.line([range[0] - (25 / scale), 0],
             [range[1] + (25 / scale), 0], {
            arrows: "->"
        });
        graphie.line([range[1] + (25 / scale), 0],
             [range[0] - (25 / scale), 0], {
            arrows: "->"
        });

        // Ticks
        var labelStyle = this.props.labelStyle;
        for (var x = Math.ceil(range[0] / tickStep) * tickStep; x <= range[1];
                x += tickStep) {
            graphie.line([x, -0.2], [x, 0.2]);

            // TODO(jack): Find out if any exercises have "decimal ticks" set,
            // and if so, re-save them and remove this check.
            if (this.props.labelTicks || labelStyle === "decimal ticks") {
                this._label(x);
            }
        }

        graphie.style({
            stroke: KhanUtil.BLUE,
            strokeWidth: 3.5
        }, function() {
            graphie.line([range[0], -0.2], [range[0], 0.2]);
            graphie.line([range[1], -0.2], [range[1], 0.2]);
            if (range[0] < 0 && 0 < range[1]) {
                graphie.line([0, -0.2], [0, 0.2]);
            }
        });

        graphie.style({color: KhanUtil.BLUE}, function() {
            self._label(range[0]);
            self._label(range[1]);
            if (range[0] < 0 && 0 < range[1] && !self.props.labelTicks) {
                    graphie.label([0, -0.53], "0", "center");
            }
        });

        // Point

        var isInequality = this.props.isInequality;
        var rel = this.props.rel;

        var pointSize;
        var pointStyle;
        var highlightStyle;
        if (isInequality && (rel === "lt" || rel === "gt")) {
            pointSize = 5;
            pointStyle = {
                stroke: KhanUtil.ORANGE,
                fill: KhanUtil.BACKGROUND,
                "stroke-width": 3
            };
            highlightStyle = {
                stroke: KhanUtil.ORANGE,
                fill: KhanUtil.BACKGROUND,
                "stroke-width": 4
            };
        } else {
            pointSize = 4;
            pointStyle = highlightStyle = {
                stroke: KhanUtil.ORANGE,
                fill: KhanUtil.ORANGE
            };
        }

        var x = Math.min(Math.max(range[0], this.props.pointX), range[1]);
        var point = this.point = graphie.addMovablePoint({
            pointSize: pointSize,
            coord: [x, 0],
            snapX: this.props.tickStep / this.props.snapDivisions,
            constraints: {
                constrainY: true
            },
            normalStyle: pointStyle,
            highlightStyle: highlightStyle
        });
        point.onMove = function(x, y) {
            x = Math.min(Math.max(range[0], x), range[1]);
            updateInequality(x, y);
            return [x, y];
        };
        point.onMoveEnd = function(x, y) {
            this.props.onChange({pointX: x});
        }.bind(this);

        // Inequality line

        var inequalityLine;
        updateInequality(x, 0);

        function updateInequality(px, py) {
            if (inequalityLine) {
                inequalityLine.remove();
                inequalityLine = null;
            }
            if (isInequality) {
                var end;
                if (rel === "ge" || rel === "gt") {
                    end = [range[1] + (26 / scale), 0];
                } else {
                    end = [range[0] - (26 / scale), 0];
                }
                inequalityLine = graphie.line(
                    [px, py],
                    end,
                    {
                        arrows: "->",
                        stroke: KhanUtil.BLUE,
                        strokeWidth: 3.5
                    }
                );
                point.toFront();
            }
        }
    },

    toJSON: function() {
        return {
            pointX: this.props.pointX,
            rel: this.props.isInequality ? this.props.rel : "eq"
        };
    },

    simpleValidate: function(rubric) {
        return InteractiveNumberLine.validate(this.toJSON(), rubric);
    },

    focus: $.noop
});


_.extend(InteractiveNumberLine, {
    validate: function(state, rubric) {
        var range = rubric.range;
        var start = Math.min(Math.max(range[0], 0), range[1]);
        var startRel = rubric.isInequality ? "ge" : "eq";
        var correctRel = rubric.correctRel || "eq";

        if (eq(state.pointX, rubric.correctX || 0) &&
                correctRel === state.rel) {
            return {
                type: "points",
                earned: 1,
                total: 1,
                message: null
            };
        } else if (state.pointX === start && state.rel === startRel) {
            // We're where we started.
            return {
                type: "invalid",
                message: null
            };
        } else {
            return {
                type: "points",
                earned: 0,
                total: 1,
                message: null
            };
        }
    }
});


var InteractiveNumberLineEditor = React.createClass({displayName: 'InteractiveNumberLineEditor',
    getDefaultProps: function() {
        return {
            range: [0, 10],
            labelStyle: "decimal",
            labelTicks: false,
            tickStep: 1,
            snapDivisions: 4,
            correctRel: "eq",
            correctX: 0
        };
    },

    render: function() {
        return React.DOM.div(null, 
            React.DOM.label(null, 
                " min x: ", React.DOM.input( {defaultValue:'' + this.props.range[0],
                    onBlur:this.onRangeBlur.bind(this, 0)} )
            ),React.DOM.br(null ),
            React.DOM.label(null, 
                " max x: ", React.DOM.input( {defaultValue:'' + this.props.range[1],
                    onBlur:this.onRangeBlur.bind(this, 1)} )
            ),
            InfoTip(null, 
                React.DOM.p(null, "Change \"label styles\" below to display the max and min x in "+
                "different number formats.")
            ),React.DOM.br(null ),
            React.DOM.span(null, 
                " correct: ",
                React.DOM.select( {value:this.props.correctRel,
                        onChange:this.onChange.bind(this, "correctRel")}, 
                    React.DOM.optgroup( {label:"Equality"}, 
                        React.DOM.option( {value:"eq"}, "x =")
                    ),
                    React.DOM.optgroup( {label:"Inequality"}, 
                        React.DOM.option( {value:"lt"}, "x <"),
                        React.DOM.option( {value:"gt"}, "x >"),
                        React.DOM.option( {value:"le"}, "x ≤"),
                        React.DOM.option( {value:"ge"}, "x ≥")
                    )
                ),
                React.DOM.input( {defaultValue:'' + this.props.correctX,
                    onBlur:this.onNumBlur.bind(this, "correctX")} )
            ),React.DOM.br(null ),React.DOM.br(null ),
            React.DOM.label(null, 
                " label style: ",
                React.DOM.select( {value:this.props.labelStyle,
                        onChange:this.onChange.bind(this, "labelStyle")}, 
                    React.DOM.option( {value:"decimal"}, "Decimals"),
                    React.DOM.option( {value:"improper"}, "Improper fractions"),
                    React.DOM.option( {value:"mixed"}, "Mixed numbers")
                ),
                PropCheckBox(
                    {label:"label ticks",
                    labelTicks:this.props.labelTicks,
                    onChange:this.props.onChange} )
            ),React.DOM.br(null ),
            React.DOM.label(null, 
                " tick step: ", React.DOM.input( {defaultValue:'' + this.props.tickStep,
                    onBlur:this.onNumBlur.bind(this, "tickStep")} )
            ),
            InfoTip(null, 
                React.DOM.p(null, "A tick mark is placed at every number of steps "+
                "indicated.")
            ),React.DOM.br(null ),
            React.DOM.label(null, 
                " snap increments per tick: ",
                React.DOM.input( {defaultValue:'' + this.props.snapDivisions,
                    onBlur:this.onNumBlur.bind(this, "snapDivisions")} )
            ),
            InfoTip(null, 
                React.DOM.p(null, "Ensure the required number of snap increments is provided to "+
                "answer the question.")
            )
        );
    },

    onRangeBlur: function(i, e) {
        var x = Util.firstNumericalParse(e.target.value) || 0;
        e.target.value = x;

        var range = this.props.range.slice();
        range[i] = x;
        this.props.onChange({range: range});
    },

    onChange: function(key, e) {
        var opts = {};
        opts[key] = e.target.value;
        this.props.onChange(opts);
    },

    onNumBlur: function(key, e) {
        var x = Util.firstNumericalParse(e.target.value) || 0;
        e.target.value = x;

        var opts = {};
        opts[key] = x;
        this.props.onChange(opts);
    },

    toJSON: function() {
        return {
            range: this.props.range,
            labelStyle: this.props.labelStyle,
            labelTicks: this.props.labelTicks,
            tickStep: this.props.tickStep,
            snapDivisions: this.props.snapDivisions,
            correctRel: this.props.correctRel,
            isInequality: this.props.correctRel !== "eq",
            correctX: this.props.correctX
        };
    }
});

Perseus.Widgets.register("interactive-number-line", InteractiveNumberLine);
Perseus.Widgets
    .register("interactive-number-line-editor", InteractiveNumberLineEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../components/prop-check-box.jsx":8,"../core.js":11,"../util.js":19,"../widgets.js":20}],27:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
require("../renderer.jsx");
var Util = require("../util.js");

var shuffle = Util.shuffle;
var seededRNG = Util.seededRNG;

var InfoTip        = require("../components/info-tip.jsx");
var PropCheckBox   = require("../components/prop-check-box.jsx");
var Renderer       = Perseus.Renderer;
var Sortable       = require("../components/sortable.jsx");
var TextListEditor = require("../components/text-list-editor.jsx");
var Widgets        = require("../widgets.js");


var Matcher = React.createClass({displayName: 'Matcher',
    propTypes: {
        left: React.PropTypes.array,
        right: React.PropTypes.array,
        labels: React.PropTypes.array,
        orderMatters: React.PropTypes.bool,
        padding: React.PropTypes.bool,
        problemNum: React.PropTypes.number
    },

    getDefaultProps: function() {
        return {
            left: [],
            right: [],
            labels: ["", ""],
            orderMatters: true,
            padding: true,
            problemNum: 0
        };
    },

    getInitialState: function() {
        return {
            heights: {left: 0, right: 0}
        };
    },

    render: function() {
        // Use the same random() function to shuffle both columns sequentially
        var rng = seededRNG(this.props.problemNum);

        var left;
        if (!this.props.orderMatters) {
            // If the order doesn't matter, don't shuffle the left column
            left = this.props.left;
        } else {
            left = shuffle(this.props.left, rng, /* ensurePermuted */ true);
        }

        var right = shuffle(this.props.right, rng, /* ensurePermuted */ true);

        var showLabels = _.any(this.props.labels);
        var constraints = {height: _.max(this.state.heights)};

        return React.DOM.div( {className:"perseus-widget-matcher ui-helper-clearfix"}, 
            React.DOM.div( {className:"column"}, 
                showLabels && React.DOM.div( {className:"column-label"}, 
                    Renderer( {content:this.props.labels[0] || "..."} )
                ),
                Sortable(
                    {options:left,
                    layout:"vertical",
                    padding:this.props.padding,
                    disabled:!this.props.orderMatters,
                    constraints:constraints,
                    onMeasure:_.partial(this.onMeasure, "left"),
                    ref:"left"} )
            ),
            React.DOM.div( {className:"column"}, 
                showLabels && React.DOM.div( {className:"column-label"}, 
                    Renderer( {content:this.props.labels[1] || "..."} )
                ),
                Sortable(
                    {options:right,
                    layout:"vertical",
                    padding:this.props.padding,
                    constraints:constraints,
                    onMeasure:_.partial(this.onMeasure, "right"),
                    ref:"right"} )
            )
        );
    },

    onMeasure: function(side, dimensions) {
        var heights = _.clone(this.state.heights);
        heights[side] = _.max(dimensions.heights);
        this.setState({heights: heights});
    },

    toJSON: function(skipValidation) {
        return {
            left: this.refs.left.getOptions(),
            right: this.refs.right.getOptions()
        };
    },

    simpleValidate: function(rubric) {
        return Matcher.validate(this.toJSON(), rubric);
    },
});


_.extend(Matcher, {
    validate: function(state, rubric) {
        var correct = _.isEqual(state.left, rubric.left) &&
                      _.isEqual(state.right, rubric.right);

        return {
            type: "points",
            earned: correct ? 1 : 0,
            total: 1,
            message: null
        };
    }
});


var MatcherEditor = React.createClass({displayName: 'MatcherEditor',
    propTypes: {
        left: React.PropTypes.array,
        right: React.PropTypes.array,
        labels: React.PropTypes.array,
        orderMatters: React.PropTypes.bool,
        padding: React.PropTypes.bool
    },

    getDefaultProps: function() {
        return {
            left: ["$x$", "$y$", "$z$"],
            right: ["$1$", "$2$", "$3$"],
            labels: ["test", "label"],
            orderMatters: true,
            padding: true
        };
    },

    render: function() {
        return React.DOM.div( {className:"perseus-matcher-editor"}, 
            React.DOM.div(null, 
                " Correct answer: ",
                InfoTip(null, 
                    React.DOM.p(null, "Enter the correct answers here. The preview on the right "+
                    "will show the cards in a randomized order, which is how the "+
                    "student will see them.")
                )
            ),
            React.DOM.div( {className:"ui-helper-clearfix"}, 
                TextListEditor(
                    {options:this.props.left,
                    onChange:function(options, cb) {
                        this.props.onChange({left: options}, cb);
                    }.bind(this),
                    layout:"vertical"} ),
                TextListEditor(
                    {options:this.props.right,
                    onChange:function(options, cb) {
                        this.props.onChange({right: options}, cb);
                    }.bind(this),
                    layout:"vertical"} )
            ),
            React.DOM.span(null, 
                " Labels: ",
                InfoTip(null, 
                    React.DOM.p(null, "These are entirely optional.")
                )
            ),
            React.DOM.div(null, 
                React.DOM.input( {type:"text",
                    defaultValue:this.props.labels[0],
                    onChange:_.bind(this.onLabelChange, this, 0)} ),
                React.DOM.input( {type:"text",
                    defaultValue:this.props.labels[1],
                    onChange:_.bind(this.onLabelChange, this, 1)} )
            ),
            React.DOM.div(null, 
                PropCheckBox(
                    {label:"Order of the matched pairs matters:",
                    orderMatters:this.props.orderMatters,
                    onChange:this.props.onChange} ),
                InfoTip(null, 
                    React.DOM.p(null, "With this option enabled, only the order provided above "+
                    "will be treated as correct. This is useful when ordering is "+
                    "significant, such as in the context of a proof."),
                    React.DOM.p(null, "If disabled, pairwise matching is sufficient. To make "+
                    "this clear, the left column becomes fixed in the provided "+
                    "order and only the cards in the right column can be moved. "
                    )
                )
            ),
            React.DOM.div(null, 
                PropCheckBox(
                    {label:"Padding:",
                    padding:this.props.padding,
                    onChange:this.props.onChange} ),
                InfoTip(null, 
                    React.DOM.p(null, "Padding is good for text, but not needed for images.")
                )
            )
        );
    },

    onLabelChange: function(index, e) {
        var labels = _.clone(this.props.labels);
        labels[index] = e.target.value;
        this.props.onChange({labels: labels});
    },

    toJSON: function(skipValidation) {
        if (!skipValidation) {
            if (this.props.left.length !== this.props.right.length) {
                alert("Warning: The two halves of the matcher have different" +
                    " numbers of cards.");
            }
        }

        return _.pick(this.props,
            "left", "right", "labels", "orderMatters", "padding"
        );
    }
});

Widgets.register("matcher", Matcher);
Widgets.register("matcher-editor", MatcherEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../components/prop-check-box.jsx":8,"../components/sortable.jsx":9,"../components/text-list-editor.jsx":10,"../core.js":11,"../renderer.jsx":17,"../util.js":19,"../widgets.js":20}],28:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");
require("../renderer.jsx");

var InfoTip        = require("../components/info-tip.jsx");
var TextListEditor = require("../components/text-list-editor.jsx");
var Widgets        = require("../widgets.js");

var PlaceholderCard = React.createClass({displayName: 'PlaceholderCard',
    render: function() {
        return React.DOM.div( {className:"card-wrap", style:{width: this.props.width}}, 
            React.DOM.div(
                {className:"card placeholder",
                style:{height: this.props.height}} )
        );
    }
});

var DragHintCard = React.createClass({displayName: 'DragHintCard',
    render: function() {
        return React.DOM.div( {className:"card-wrap"}, 
            React.DOM.div( {className:"card drag-hint"} )
        );
    }
});

var DraggableCard = React.createClass({displayName: 'DraggableCard',
    getDefaultProps: function() {
        return {
            stack: false
        };
    },

    render: function() {
        var style = {};
        if (this.props.width) {
            style.width = this.props.width;
        }

        var className = ["card"];
        if (this.props.stack) {
            className.push("stack");
        }

        // Pull out the content to get rendered
        var rendererProps = _.pick(this.props, "content");

        return React.DOM.div( {className:"card-wrap",
                    style:style}, 
                React.DOM.div( {className:className.join(" "),
                       onMouseDown:this.onMouseDown,
                       onTouchStart:this.onMouseDown}, 
                    Perseus.Renderer(rendererProps)
                )
            );
    },

    onMouseDown: function(event) {
        if (!(event.button === 0 ||
                (event.touches != null && event.touches.length === 1))) {
            return;
        }

        event.preventDefault();
        if (event.touches != null) {
            this.props.onMouseDown(this, {
                    pageX: event.touches[0].pageX,
                    pageY: event.touches[0].pageY
                });
        } else {
            this.props.onMouseDown(this, event);
        }
    }

});

var FloatingCard = React.createClass({displayName: 'FloatingCard',
    getDefaultProps: function() {
        return {
            animating: false
        };
    },

    getInitialState: function() {
        return {
            mouse: this.props.startMouse
        };
    },

    render: function() {
        var style = {
            position: "absolute",
            left: this.props.startOffset.left,
            top: this.props.startOffset.top,
            width: this.props.width
        };

        var className = ["card"];
        if (!this.props.animating) {
            className.push("dragging");
            style.left += this.state.mouse.left - this.props.startMouse.left;
            style.top += this.state.mouse.top - this.props.startMouse.top;
        }

        // Pull out the content to get rendered
        var rendererProps = _.pick(this.props, "content");

        return React.DOM.div( {className:"card-wrap",
                    style:style}, 
                React.DOM.div( {className:className.join(" ")}, 
                    Perseus.Renderer(rendererProps)
                )
            );
    },

    componentDidMount: function() {
        $(document).on("vmousemove", this.onVMouseMove);
        $(document).on("vmouseup", this.onVMouseUp);
    },

    componentWillUnmount: function() {
        $(document).off("vmousemove", this.onVMouseMove);
        $(document).off("vmouseup", this.onVMouseUp);
    },

    componentDidUpdate: function(prevProps, prevState, rootNode) {
        if (this.props.animating && !prevProps.animating) {
            // If we just were changed into animating, start the animation.
            // We pick the animation speed based on the distance that the card
            // needs to travel. (Why sqrt? Just because it looks nice -- with a
            // linear scale, far things take too long to come back.)
            var ms = 15 * Math.sqrt(
                Math.sqrt(
                    Math.pow(this.props.animateTo.left -
                             this.props.startOffset.left, 2) +
                    Math.pow(this.props.animateTo.top -
                             this.props.startOffset.top, 2)
                )
            );
            $(this.getDOMNode()).animate(
                this.props.animateTo, Math.max(ms, 1),
                this.props.onAnimationEnd
            );
        }
    },

    onVMouseMove: function(event) {
        if (this.props.floating) {
            event.preventDefault();
            this.setState({
                mouse: {left: event.pageX, top: event.pageY}
            });
            this.props.onMouseMove(this);
        }
    },

    onVMouseUp: function(event) {
        if (this.props.floating) {
            event.preventDefault();
            this.props.onMouseUp(this, event);
        }
    }
});

var NORMAL = "normal",
    AUTO = "auto",
    HORIZONTAL = "horizontal",
    VERTICAL = "vertical";

var Orderer = React.createClass({displayName: 'Orderer',
    getDefaultProps: function() {
        return {
            current: [],
            options: [],
            correctOptions: [],
            height: NORMAL,
            layout: HORIZONTAL
        };
    },

    getInitialState: function() {
        return {
            current: [],
            dragging: false,
            placeholderIndex: null
        };
    },

    render: function() {
        var orderer = this;

        // This is the card we are currently dragging
        var dragging = this.state.dragging &&
            FloatingCard( {floating:true,
                       content:this.state.dragContent,
                       startOffset:this.state.offsetPos,
                       startMouse:this.state.grabPos,
                       width:this.state.dragWidth,
                       onMouseUp:this.onRelease,
                       onMouseMove:this.onMouseMove,
                       key:"draggingCard"}
                       );

        // This is the card that is currently animating
        var animating = this.state.animating &&
            FloatingCard( {floating:false,
                       animating:true,
                       content:this.state.dragContent,
                       startOffset:this.state.offsetPos,
                       width:this.state.dragWidth,
                       animateTo:this.state.animateTo,
                       onAnimationEnd:this.state.onAnimationEnd,
                       key:"draggingCard"}
                       );

        // This is the list of draggable, rearrangable cards
        var sortableCards = _.map(this.state.current, function(opt, i) {
            return DraggableCard(
                {ref:"sortable" + i,
                content:opt.content,
                width:opt.width,
                key:opt.key,
                onMouseDown:orderer.onClick.bind(orderer, "current", i)} );
        });

        if (this.state.placeholderIndex != null) {
            var placeholder = PlaceholderCard(
                {ref:"placeholder",
                width:this.state.dragWidth,
                height:this.state.dragHeight,
                key:"placeholder"} );
            sortableCards.splice(this.state.placeholderIndex, 0, placeholder);
        }

        // If there are no cards in the list, then add a "hint" card
        var sortable = React.DOM.div( {className:"ui-helper-clearfix draggable-box"}, 
            !sortableCards.length && DragHintCard(null ),
            React.DOM.div( {ref:"dragList"}, sortableCards)
        );

        // This is the bank of stacks of cards
        var bank = React.DOM.div( {ref:"bank", className:"bank ui-helper-clearfix"}, 
            _.map(this.props.options, function(opt, i) {
                return DraggableCard(
                    {ref:"bank" + i,
                    content:opt.content,
                    stack:true,
                    key:i,
                    onMouseDown:orderer.onClick.bind(orderer, "bank", i)} );
            })
        );

        return React.DOM.div( {className:"draggy-boxy-thing orderer " +
                        "height-" + this.props.height + " " +
                        "layout-" + this.props.layout + " ui-helper-clearfix",
                    ref:"orderer"}, 
                   bank,
                   sortable,
                   dragging,
                   animating
               );
    },

    onClick: function(type, index, draggable,  event) {
        var $draggable = $(draggable.getDOMNode());
        var list = this.state.current.slice();

        var opt;
        var placeholderIndex = null;

        if (type === "current") {
            // If this is coming from the original list, remove the original
            // card from the list
            list.splice(index, 1);
            opt = this.state.current[index];
            placeholderIndex = index;
        } else if (type === "bank") {
            opt = this.props.options[index];
        }

        this.setState({
            current: list,
            dragging: true,
            placeholderIndex: placeholderIndex,
            dragContent: opt.content,
            dragWidth: $draggable.width(),
            dragHeight: $draggable.height(),
            grabPos: {
                left: event.pageX,
                top: event.pageY
            },
            offsetPos: $draggable.position()
        });
    },

    onRelease: function(draggable, event) {
        var inCardBank = this.isCardInBank(draggable);
        var index = this.state.placeholderIndex;

        // Here, we build a callback function for the card to call when it is
        // done animating
        var onAnimationEnd = function() {
            var list = this.state.current.slice();

            if (!inCardBank) {
                // Insert the new card into the position
                var newCard = {
                    content: this.state.dragContent,
                    key: _.uniqueId("perseus_draggable_card_"),
                    width: this.state.dragWidth
                };

                list.splice(index, 0, newCard);
            }

            this.props.onChange({
                current: list
            });
            this.setState({
                current: list,
                dragging: false,
                placeholderIndex: null,
                animating: false
            });
        }.bind(this);

        // Find the position of the card we should animate to
        var offset = $(draggable.getDOMNode()).position();
        var finalOffset = null;
        if (inCardBank) {
            // If we're in the card bank, go through the options to find the
            // one with the same content
            _.each(this.props.options, function(opt, i) {
                if (opt.content === this.state.dragContent) {
                    var card = this.refs["bank" + i].getDOMNode();
                    finalOffset = $(card).position();
                }
            }, this);
        } else {
            // Otherwise, go to the position that the placeholder is at
            finalOffset = $(this.refs.placeholder.getDOMNode()).position();
        }

        if (finalOffset == null) {
            // If we didn't find a card to go to, simply make the changes we
            // would have made at the end. (should only happen if we are
            // messing around with card contents, and not on the real site)
            onAnimationEnd();
        } else {
            this.setState({
                offsetPos: offset,
                animateTo: finalOffset,
                onAnimationEnd: onAnimationEnd,
                animating: true,
                dragging: false
            });
        }
    },

    onMouseMove: function(draggable) {
        var index;
        if (this.isCardInBank(draggable)) {
            index = null;
        } else {
            index = this.findCorrectIndex(draggable, this.state.current);
        }

        this.setState({placeholderIndex: index});
    },

    findCorrectIndex: function(draggable, list) {
        // Find the correct index for a card given the current cards.
        var isHorizontal = this.props.layout === HORIZONTAL,
            $dragList = $(this.refs.dragList.getDOMNode()),
            leftEdge = $dragList.offset().left,
            topEdge = $dragList.offset().top,
            midWidth = $(draggable.getDOMNode()).offset().left - leftEdge,
            midHeight = $(draggable.getDOMNode()).offset().top - topEdge,
            index = 0,
            sumWidth = 0,
            sumHeight = 0;

        if (isHorizontal) {
            _.each(list, function(opt, i) {
                var card = this.refs["sortable" + i].getDOMNode();
                var outerWidth = $(card).outerWidth(true);
                if (midWidth > sumWidth + outerWidth / 2) {
                    index += 1;
                }
                sumWidth += outerWidth;
            }, this);
        } else {
            _.each(list, function(opt, i) {
                var card = this.refs["sortable" + i].getDOMNode();
                var outerHeight = $(card).outerHeight(true);
                if (midHeight > sumHeight + outerHeight / 2) {
                    index += 1;
                }
                sumHeight += outerHeight;
            }, this);
        }

        return index;
    },

    isCardInBank: function(draggable) {
        var isHorizontal = this.props.layout === HORIZONTAL,
            $draggable = $(draggable.getDOMNode()),
            $bank = $(this.refs.bank.getDOMNode()),
            draggableOffset = $draggable.offset(),
            bankOffset = $bank.offset(),
            draggableHeight = $draggable.outerHeight(true),
            bankHeight = $bank.outerHeight(true),
            bankWidth = $bank.outerWidth(true),
            dragList = this.refs.dragList.getDOMNode(),
            dragListWidth = $(dragList).width(),
            draggableWidth = $draggable.outerWidth(true),
            currentWidth =
                _.reduce(this.state.current, function(sum, opt, i) {
                    var card = this.refs["sortable" + i].getDOMNode();
                    return sum + $(card).outerWidth(true);
                }, 0, this);

        if (isHorizontal) {
            return (draggableOffset.top + draggableHeight / 2 <
                    bankOffset.top + bankHeight) ||
                   (currentWidth + draggableWidth > dragListWidth);
        } else {
            return (draggableOffset.left + draggableWidth / 2 <
                    bankOffset.left + bankWidth);
        }
    },

    toJSON: function(skipValidation) {
        return {current: _.map(this.props.current, function(v) {
            return v.content;
        })};
    },

    simpleValidate: function(rubric) {
        return Orderer.validate(this.toJSON(), rubric);
    },
});

_.extend(Orderer, {
    validate: function(state, rubric) {
        if (state.current.length === 0) {
            return {
                type: "invalid",
                message: null
            };
        }

        var correct = _.isEqual(
            state.current,
            _.pluck(rubric.correctOptions, 'content')
        );

        return {
            type: "points",
            earned: correct ? 1 : 0,
            total: 1,
            message: null
        };
    }
});


var OrdererEditor = React.createClass({displayName: 'OrdererEditor',
    getDefaultProps: function() {
        return {
            correctOptions: [
                {content: "$x$"}
            ],
            otherOptions: [
                {content: "$y$"}
            ],
            height: NORMAL,
            layout: HORIZONTAL
        };
    },

    render: function() {
        var editor = this;

        return React.DOM.div( {className:"perseus-widget-orderer"}, 
            React.DOM.div(null, 
                " Correct answer: ",
                InfoTip(null, React.DOM.p(null, 
                    " Place the cards in the correct order. The same card can be "+
                    "used more than once in the answer but will only be "+ 
                    "displayed once at the top of a stack of identical cards. "
                ))
            ),
            TextListEditor(
                {options:_.pluck(this.props.correctOptions, "content"),
                onChange:this.onOptionsChange.bind(this, "correctOptions"),
                layout:this.props.layout} ),

            React.DOM.div(null, 
                " Other cards: ",
                InfoTip(null, 
                    React.DOM.p(null, "Create cards that are not part of the answer.")
                )
            ),
            TextListEditor(
                {options:_.pluck(this.props.otherOptions, "content"),
                onChange:this.onOptionsChange.bind(this, "otherOptions"),
                layout:this.props.layout} ),

            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Layout: ",
                    React.DOM.select( {value:this.props.layout,
                            onChange:this.onLayoutChange}, 
                        React.DOM.option( {value:HORIZONTAL}, "Horizontal"),
                        React.DOM.option( {value:VERTICAL}, "Vertical")
                    )
                ),
                InfoTip(null, 
                    React.DOM.p(null, "Use the horizontal layout for short text and small "+
                    "images. The vertical layout is best for longer text (e.g. "+
                    "proofs).")
                )
            ),
            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Height: ",
                    React.DOM.select( {value:this.props.height,
                            onChange:this.onHeightChange}, 
                        React.DOM.option( {value:NORMAL}, "Normal"),
                        React.DOM.option( {value:AUTO}, "Automatic")
                    )
                ),
                InfoTip(null, 
                    React.DOM.p(null, "Use \"Normal\" for text, \"Automatic\" for images.")
                )
            )
        );
    },

    onOptionsChange: function(whichOptions, options, cb) {
        var props = {};
        props[whichOptions] = _.map(options, function(option) {
            return {content: option};
        });
        this.props.onChange(props, cb);
    },

    onLayoutChange: function(e) {
        this.props.onChange({layout: e.target.value});
    },

    onHeightChange: function(e) {
        this.props.onChange({height: e.target.value});
    },

    toJSON: function(skipValidation) {
        // We combine the correct answer and the other cards by merging them,
        // removing duplicates and empty cards, and sorting them into
        // categories based on their content
        var options =
            _.chain(_.pluck(this.props.correctOptions, 'content'))
             .union(_.pluck(this.props.otherOptions, 'content'))
             .uniq()
             .reject(function(content) { return content === ""; })
             .sort()
             .sortBy(function(content) {
                 if (/\d/.test(content)) {
                     return 0;
                 } else if (/^\$?[a-zA-Z]+\$?$/.test(content)) {
                     return 2;
                 } else {
                     return 1;
                 }
             })
             .map(function(content) {
                 return { content: content };
             })
             .value();

        return {
            options: options,
            correctOptions: this.props.correctOptions,
            otherOptions: this.props.otherOptions,
            height: this.props.height,
            layout: this.props.layout
        };
    }
});

Widgets.register("orderer", Orderer);
Widgets.register("orderer-editor", OrdererEditor);

})(Perseus);


},{"../components/info-tip.jsx":6,"../components/text-list-editor.jsx":10,"../core.js":11,"../renderer.jsx":17,"../util.js":19,"../widgets.js":20}],29:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");

var InfoTip = require("../components/info-tip.jsx");
var TextListEditor = require("../components/text-list-editor.jsx");
var Widgets = require("../widgets.js");

var deepEq = Util.deepEq;

var BAR = "bar",
    LINE = "line",
    PIC = "pic",
    HISTOGRAM = "histogram";

var Plotter = React.createClass({displayName: 'Plotter',
    propTypes: {
        type: React.PropTypes.oneOf([BAR, LINE, PIC, HISTOGRAM])
    },

    getDefaultProps: function () {
        return {
            type: BAR,
            labels: ["", ""],
            categories: [""],

            scaleY: 1,
            maxY: 10,
            snapsPerLine: 2,

            picSize: 40,
            picBoxHeight: 48,
            picUrl: "",

            plotDimensions: [380, 300]        
        };
    },

    getInitialState: function() {
        return {
            values: this.props.starting || [1]
        };
    },

    render: function() {
        return React.DOM.div( {className:"perseus-widget-plotter", ref:"graphieDiv"});
    },

    componentDidUpdate: function() {
        if (this.shouldSetupGraphie) {
            this.setupGraphie();
        }
    },

    componentDidMount: function() {
        this.setupGraphie();
    },

    componentWillReceiveProps: function(nextProps) {
        var props = ["type", "labels", "categories", "scaleY", "maxY",
            "snapsPerLine", "picUrl"];

        this.shouldSetupGraphie = _.any(props, function (prop) {
            return !_.isEqual(this.props[prop], nextProps[prop]);
        }, this);

        if (!_.isEqual(this.props.starting, nextProps.starting) &&
            !_.isEqual(this.state.values, nextProps.starting)) {
            this.shouldSetupGraphie = true;
            this.setState({values: nextProps.starting});
        }
    },

    setupGraphie: function() {
        var self = this;
        self.shouldSetupGraphie = false;
        var graphieDiv = self.refs.graphieDiv.getDOMNode();
        $(graphieDiv).empty();
        var graphie = KhanUtil.createGraphie(graphieDiv);

        // TODO(jakesandlund): It's not the react way to hang
        // something off the component object, but since graphie
        // is outside React, it makes it easier to do this.
        self.graphie = graphie;
        self.graphie.pics = [];
        self.mousedownPic = false;

        var isBar = self.props.type === BAR,
            isLine = self.props.type === LINE,
            isPic = self.props.type === PIC,
            isHistogram = self.props.type === HISTOGRAM;

        var config = {};
        var c = config; // c for short

        c.graph = {
            lines: [],
            bars: [],
            points: [],
            dividers: []
        };
        c.scaleY = self.props.scaleY;
        c.dimX = self.props.categories.length;
        var plotDimensions = self.props.plotDimensions;
        if (isLine) {
            c.dimX += 1;
        } else if (isHistogram) {
            c.barPad = 0;
            c.barWidth = 1;
        } else if (isBar) {
            c.barPad = 0.15;
            c.barWidth = 1 - 2 * c.barPad;
            c.dimX += 2 * c.barPad;
        } else if (isPic) {
            c.picBoxHeight = self.props.picBoxHeight;
            c.picBoxWidthPx = c.picBoxHeight * 1.3;
            var picPadAllWidth = plotDimensions[0] - c.dimX * c.picBoxWidthPx;
            c.picPad = picPadAllWidth / (2 * c.dimX + 2);
            var picFullWidth = c.picBoxWidthPx + 2 * c.picPad;

            // Convert from px to "unscaled"
            c.picPad = c.picPad / picFullWidth;
            c.picBoxWidth = c.picBoxWidthPx / picFullWidth;
            c.dimX += 2 * c.picPad;
        }
        c.dimY = Math.ceil(self.props.maxY / c.scaleY) * c.scaleY;
        c.scale = _.map([c.dimX, c.dimY], function (dim, i) {
            return plotDimensions[i] / dim;
        });
        if (isPic) {
            c.scale[1] = c.picBoxHeight / c.scaleY;
        }

        var padX = 25 / c.scale[0];
        var padY = 25 / c.scale[1];

        graphie.init({
            range: [[-3 * padX, c.dimX + padX], [-3 * padY, c.dimY + padY]],
            scale: c.scale
        });
        graphie.addMouseLayer();

        if (!isPic) {
            for (var y = 0; y <= c.dimY; y += c.scaleY) {
                graphie.label(
                    [0, y],
                    KhanUtil.roundToApprox(y, 2),
                    "left",
                    /* isTeX */ true /* for the \approx symbol */
                );
                graphie.style(
                    {stroke: "#000", strokeWidth: 1, opacity: 0.3},
                    function() {
                        graphie.line([0, y], [c.dimX, y]);
                    });
            }
        }

        self.setupCategories(config);

        if (isPic) {
            self.mousedownPic = false;
            $(document).on("mouseup.plotterPic", function() {
                self.mousedownPic = false;
            });
            self.drawPicHeights(self.state.values);
        }

        graphie.style(
            {stroke: "#000", strokeWidth: 2, opacity: 1.0},
            function() {
                graphie.line([0, 0], [c.dimX, 0]);
                graphie.line([0, 0], [0, c.dimY]);
            });

        graphie.label([c.dimX / 2, -35 / c.scale[1]],
            self.props.labels[0],
            "below", false)
            .css("font-weight", "bold");

        graphie.label([-60 / c.scale[0], c.dimY / 2],
            self.props.labels[1],
            "center", false)
            .css("font-weight", "bold")
            .addClass("rotate");
    },

	labelCategory: function(x, category) {
		var graphie = this.graphie;
		category = category + "";
		var isTeX = false;
		var mathyCategory = category.match(/^\$(.*)\$$/);
		if (mathyCategory) {
			category = mathyCategory[1];
			isTeX = true;
		}
		graphie.label([x, 0], category, "below", isTeX);
	},

    setupCategories: function(config) {
        var self = this;
        var c = config;
        var graphie = self.graphie;

        if (self.props.type === HISTOGRAM) {
            // Histograms with n labels/categories have n - 1 buckets
            var scale = _.times(self.props.categories.length - 1, function(i) {
                return self.setupHistogram(i, self.state.values[i], config);
            });

            // Scale buckets (bars) and dividers
            _.invoke(scale, "call");

            // Label categories
            _.each(self.props.categories, function(category, i) {
                var x = 0.5 + i * c.barWidth;

				self.labelCategory(x, category);
                var tickHeight = 6 / c.scale[1];
                graphie.style({
                    stroke: "#000", strokeWidth: 2, opacity: 1.0
                }, function() {
                    graphie.line([x, -tickHeight], [x, 0]);
                });
            });
        } else {
            _.each(self.props.categories, function (category, i) {
                var startHeight = self.state.values[i];
                var x;

                if (self.props.type === BAR) {
                    x = self.setupBar(i, startHeight, config);
                } else if (self.props.type === LINE) {
                    x = self.setupLine(i, startHeight, config);
                } else if (self.props.type === PIC) {
                    x = self.setupPic(i, startHeight, config);
                }

				self.labelCategory(x, category);

                var tickHeight = 6 / c.scale[1];
                graphie.style({
                    stroke: "#000", strokeWidth: 2, opacity: 1.0
                }, function() {
                    graphie.line([x, -tickHeight], [x, 0]);
                });
            });
        }
    },

    setupHistogram: function(i, startHeight, config) {
        var self = this;
        var c = config;
        var graphie = self.graphie;
        var barHalfWidth = c.barWidth / 2;
        var x = 0.5 + i * c.barWidth + barHalfWidth;        

        var scaleBar = function(i, height) {
            var center = graphie.scalePoint(0);

            // Scale filled bucket (bar)
            c.graph.bars[i].scale(
                1, Math.max(0.01, height / c.scaleY),
                center[0], center[1]
            );

            // Scale dividers between buckets
            var leftDivider = c.graph.dividers[i - 1],
                rightDivider = c.graph.dividers[i];

            if (leftDivider) {
                var divHeight = Math.min(self.state.values[i - 1], height);
                leftDivider.scale(
                    1, Math.max(0.01, divHeight / c.scaleY),
                    center[0], center[1]
                );
            }

            if (rightDivider) {
                var divHeight = Math.min(height, self.state.values[i + 1]);
                rightDivider.scale(
                    1, Math.max(0.01, divHeight / c.scaleY),
                    center[0], center[1]
                );
            }

            // Align top of bar to edge unless at bottom
            if (height) {
                c.graph.lines[i].visibleLine.translate(0, 2);
            }
        };

        graphie.style({
            stroke: "none", fill: "#9ab8ed", opacity: 1.0
        }, function() {
            c.graph.bars[i] = graphie.path([
                [x - barHalfWidth, 0],
                [x - barHalfWidth, c.scaleY],
                [x + barHalfWidth, c.scaleY],
                [x + barHalfWidth, 0],
                [x - barHalfWidth, 0]
            ]);
        });

        if (i) {
            // Don't draw a divider to the left of the first bucket
            graphie.style({
                stroke: "#000", strokeWidth: 1, opacity: 0.3
            }, function() {
                c.graph.dividers.push(graphie.path([
                    [x - barHalfWidth, 0],
                    [x - barHalfWidth, c.scaleY]
                ]));
            });
        }

        c.graph.lines[i] = graphie.addMovableLineSegment({
            coordA: [x - barHalfWidth, startHeight],
            coordZ: [x + barHalfWidth, startHeight],
            snapY: c.scaleY / self.props.snapsPerLine,
            constraints: {
                constrainX: true
            },
            normalStyle: {
                "stroke": KhanUtil.BLUE,
                "stroke-width": 4
            }
        });

        c.graph.lines[i].onMove = function(dx, dy) {
            var y = this.coordA[1];
            if (y < 0 || y > c.dimY) {
                y = Math.min(Math.max(y, 0), c.dimY);
                this.coordA[1] = this.coordZ[1] = y;

                // Snap the line back into range.
                this.transform();
            }

            var values = _.clone(self.state.values);
            values[i] = y;
            self.setState({values: values});
            self.props.onChange({ values: values });

            scaleBar(i, y);
        };

        return _.bind(scaleBar, this, i, startHeight);
    },

    setupBar: function(i, startHeight, config) {
        var self = this;
        var c = config;
        var graphie = self.graphie;
        var x = i + 0.5 + c.barPad;
        var barHalfWidth = c.barWidth / 2;

        var scaleBar = function(i, height) {
            var center = graphie.scalePoint(0);
            c.graph.bars[i].scale(
                    1, Math.max(0.01, height / c.scaleY),
                    center[0], center[1]);

            // Align top of bar to edge unless at bottom
            if (height) {
                c.graph.lines[i].visibleLine.translate(0, 2);
            }
        };

        graphie.style(
            {stroke: "none", fill: "#9ab8ed", opacity: 1.0},
            function() {
                c.graph.bars[i] = graphie.path([
                    [x - barHalfWidth, 0],
                    [x - barHalfWidth, c.scaleY],
                    [x + barHalfWidth, c.scaleY],
                    [x + barHalfWidth, 0],
                    [x - barHalfWidth, 0]
                ]);
            });

        c.graph.lines[i] = graphie.addMovableLineSegment({
            coordA: [x - barHalfWidth, startHeight],
            coordZ: [x + barHalfWidth, startHeight],
            snapY: c.scaleY / self.props.snapsPerLine,
            constraints: {
                constrainX: true
            },
            normalStyle: {
                "stroke": KhanUtil.BLUE,
                "stroke-width": 4
            }
        });

        c.graph.lines[i].onMove = function(dx, dy) {
            var y = this.coordA[1];
            if (y < 0 || y > c.dimY) {
                y = Math.min(Math.max(y, 0), c.dimY);
                this.coordA[1] = this.coordZ[1] = y;

                // Snap the line back into range.
                this.transform();
            }

            var values = _.clone(self.state.values);
            values[i] = y;
            self.setState({values: values});
            self.props.onChange({ values: values });

            scaleBar(i, y);
        };

        scaleBar(i, startHeight);
        return x;
    },

    setupLine: function(i, startHeight, config) {
        var self = this;
        var c = config;
        var graphie = self.graphie;
        var x = i + 1;
        c.graph.points[i] = graphie.addMovablePoint({
            coord: [x, startHeight],
            constraints: {
                constrainX: true
            },
            normalStyle: {
                fill: KhanUtil.BLUE,
                stroke: KhanUtil.BLUE
            },
            snapY: c.scaleY / self.props.snapsPerLine,
        });
        c.graph.points[i].onMove = function(x, y) {
            y = Math.min(Math.max(y, 0), c.dimY);
            var values = _.clone(self.state.values);
            values[i] = y;
            self.setState({values: values});
            self.props.onChange({ values: values });
            return [x, y];
        };
        if (i > 0) {
            c.graph.lines[i] = graphie.addMovableLineSegment({
                pointA: c.graph.points[i - 1],
                pointZ: c.graph.points[i],
                constraints: {
                    fixed: true
                },
                normalStyle: {
                    stroke: "#9ab8ed",
                    "stroke-width": 2
                }
            });
        }
        return x;
    },

    setupPic: function(i, startHeight, config) {
        var self = this;
        var c = config;
        var graphie = self.graphie;
        var pics = graphie.pics;
        var x = i + 0.5 + c.picPad;

        pics[i] = [];
        var n = Math.round(c.dimY / c.scaleY) + 1;
        _(n).times(function(j) {
            j -= 1;
            var midY = (j + 0.5) * c.scaleY;
            var leftX = x - c.picBoxWidth / 2;
            var topY = midY + 0.5 * c.scaleY;
            var coord = graphie.scalePoint([leftX, topY]);
            var mouseRect = graphie.mouselayer.rect(
                    coord[0], coord[1], c.picBoxWidthPx, c.picBoxHeight);
            $(mouseRect[0])
                .css({fill: "#000", opacity: 0.0, cursor: "pointer"})
                .on("mousedown", function(e) {
                    self.mousedownPic = true;
                    self.setPicHeight(i, topY);
                    e.preventDefault();
                })
                .on("mouseover", function() {
                    if (self.mousedownPic) {
                        self.setPicHeight(i, topY);
                    }
                });

            if (j < 0) {
                // Don't show a pic underneath the axis!
                return;
            }
            var scaledCenter = graphie.scalePoint([x, midY]);
            var size = self.props.picSize;
            pics[i][j] = graphie.raphael.image(
                    self.props.picUrl,
                    scaledCenter[0] - size / 2,
                    scaledCenter[1] - size / 2,
                    size,
                    size);
        });
        return x;
    },

    setPicHeight: function(i, y) {
        var values = _.clone(this.state.values);
        values[i] = y;
        this.setState({values: values});
        this.props.onChange({ values: values });
        this.drawPicHeights(values);
    },

    drawPicHeights: function(values) {
        var self = this;
        var graphie = self.graphie;
        var pics = graphie.pics;
        _.each(pics, function(ps, i) {
            _.each(ps, function(pic, j) {
                var y = (j + 1) * self.props.scaleY;
                var show = y <= values[i];
                $(pic[0]).css({opacity: show ? 1.0 : 0.0});
            });
        });
    },

    toJSON: function(skipValidation) {
        return this.state.values;
    },

    simpleValidate: function(rubric) {
        return Plotter.validate(this.toJSON(), rubric);
    },
});

_.extend(Plotter, {
    validate: function (guess, rubric) {
        if (deepEq(guess, rubric.starting)) {
            return {
                type: "invalid",
                message: null
            };
        } else {
            return {
                type: "points",
                earned: deepEq(guess, rubric.correct) ? 1 : 0,
                total: 1,
                message: null
            };
        }
    }
});


// Return a copy of array with length n, padded with given value
function padArray(array, n, value) {
    var copy = _.clone(array);
    copy.length = n;
    for (var i = array.length; i < n; i++) {
        copy[i] = value;
    }
    return copy;
}

var editorDefaults = {
    scaleY: 1,
    maxY: 10,
    snapsPerLine: 2
};

var PlotterEditor = React.createClass({displayName: 'PlotterEditor',
    propTypes: {
        type: React.PropTypes.oneOf([BAR, LINE, PIC, HISTOGRAM])
    },

    getDefaultProps: function () {
        return _.extend({}, editorDefaults, {
            correct: [1],
            starting: [1],

            type: BAR,
            labels: ["", ""],
            categories: [""],

            picSize: 30,
            picBoxHeight: 36,
            picUrl: Khan.imageBase + "badges/earth-small.png",

            plotDimensions: [275, 200]
        });
    },

    getInitialState: function() {
        return {
            editing: "correct"
        };
    },

    render: function() {
        var setFromScale = this.props.type === LINE ||
                           this.props.type === HISTOGRAM;
        return React.DOM.div( {className:"perseus-widget-plotter-editor"}, 
            React.DOM.div(null, 
                " Chart type: ",
                _.map([BAR, LINE, PIC, HISTOGRAM], function(type) {
                    return React.DOM.label( {key:type}, 
                        React.DOM.input(
                            {type:"radio",
                            name:"chart-type",
                            checked:this.props.type === type,
                            onChange:_.partial(this.changeType, type)} ),
                        type
                    );
                }, this)
            ),
            React.DOM.div(null, 
                " Labels: ",
                _.map(["x", "y"], function(axis, i) {
                    return React.DOM.label( {key:axis}, 
                        axis + ":",
                        React.DOM.input(
                            {type:"text",
                            onChange:_.partial(this.changeLabel, i),
                            defaultValue:this.props.labels[i]} )
                    );
                }, this)
            ),
            setFromScale && React.DOM.div(null, 
                React.DOM.div(null, 
                    React.DOM.label(null, 
                        " Scale (x): ",
                        React.DOM.input(
                            {type:"text",
                            ref:"scaleX"} )
                    )
                ),
                React.DOM.div(null, 
                    React.DOM.label(null, 
                        " Max x: ",
                        React.DOM.input(
                            {type:"text",
                            ref:"maxX"} )
                    )
                ),
                React.DOM.div(null, 
                    React.DOM.button( {onClick:this.setCategoriesFromScale}, 
                        " Set categories from scale "
                    ),
                    InfoTip(null, 
                      React.DOM.p(null, "Automatically sets categories according to the x-axis "+
                      "scale and max values.")
                    )
                )
            ),
            this.props.type === PIC && React.DOM.div(null, 
                React.DOM.label(null, 
                    " Picture: ",
                    React.DOM.input(
                        {type:"text",
                        className:"pic-url",
                        defaultValue:this.props.picUrl,
                        onKeyPress:this.changePicUrl,
                        onBlur:this.changePicUrl} ),
                InfoTip(null, 
                    React.DOM.p(null, "Use the default picture of Earth, or insert the URL for "+
                    "a different picture using the \"Add image\" function.")
                )
                )
            ),
            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Categories: ",
                    TextListEditor(
                        {ref:"categories",
                        layout:"horizontal",
                        options:this.props.categories,
                        onChange:this.changeCategories} )
                )
            ),
            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Scale (y): ",
                    React.DOM.input(
                        {type:"text",
                        onChange:this.changeScale,
                        defaultValue:this.props.scaleY} )
                )
            ),
            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Max y: ",
                    React.DOM.input(
                        {type:"text",
                        ref:"maxY",
                        onChange:this.changeMax,
                        defaultValue:this.props.maxY} )
                )
            ),
            this.props.type !== PIC && React.DOM.div(null, 
                React.DOM.label(null, 
                    " Snaps per line: ",
                    React.DOM.input(
                        {type:"text",
                        onChange:this.changeSnaps,
                        defaultValue:this.props.snapsPerLine} )
                ),
                InfoTip(null, 
                    React.DOM.p(null, "Creates the specified number of divisions between the "+
                    "horizontal lines. Fewer snaps between lines makes the graph "+
                    "easier for the student to create correctly.")
                )
            ),
            React.DOM.div(null, 
                " Editing values: ",
                _.map(["correct", "starting"], function(editing) {
                    return React.DOM.label( {key:editing}, 
                        React.DOM.input(
                            {type:"radio",
                            name:"editing",
                            checked:this.state.editing === editing,
                            onChange:_.partial(this.changeEditing, editing)}),
                        editing
                    );
                }, this),
                InfoTip(null, React.DOM.p(null, 
                    " Use this toggle to switch between editing the correct "+
                    "answer (what the student will be graded on) and the "+
                    "starting values (what the student will see plotted when "+
                    "they start the problem). Note: These cannot be the same. "
                ))
            ),
            this.transferPropsTo(
                Plotter(
                    {starting:this.props[this.state.editing],
                    onChange:this.handlePlotterChange} )
            )
        );
    },

    handlePlotterChange: function(newProps) {
        var props = {};
        props[this.state.editing] = newProps.values;
        this.props.onChange(props);
    },

    changeType: function(type) {
        var categories;
        if (type === HISTOGRAM) {
            // Switching to histogram, add a label (0) to the left
            categories = ["0"].concat(this.props.categories);
            this.props.onChange({type: type, categories: categories});
        } else if (this.props.type === HISTOGRAM) {
            // Switching from histogram, remove a label from the left
            categories = this.props.categories.slice(1);
            this.props.onChange({type: type, categories: categories});
        } else {
            this.props.onChange({type: type});
        }

        if (categories) {
            this.refs.categories.getDOMNode().value = categories.join(", ");
        }
    },

    changeLabel: function(i, e) {
        var labels = _.clone(this.props.labels);
        labels[i] = e.target.value;
        this.props.onChange({labels: labels});
    },

    changePicUrl: function(e) {
        // Only continue on blur or "enter"
        if (e.type === "keypress" && e.keyCode !== 13) {
            return;
        }

        this.props.onChange({picUrl: e.target.value});
    },

    changeCategories: function(categories) {
        var n = categories.length;
        if (this.props.type === HISTOGRAM) {
            // Histograms with n labels/categories have n - 1 buckets
            n--;
        }
        var value = this.props.scaleY;

        this.props.onChange({
            categories: categories,
            correct: padArray(this.props.correct, n, value),
            starting: padArray(this.props.starting, n, value)
        });
    },

    changeScale: function(e) {
        var oldScale = this.props.scaleY;
        var newScale = +e.target.value || editorDefaults.scaleY;

        var scale = function(value) {
            return value * newScale / oldScale;
        };

        var maxY = scale(this.props.maxY);

        this.props.onChange({
            scaleY: newScale,
            maxY: maxY,
            correct: _.map(this.props.correct, scale),
            starting: _.map(this.props.starting, scale)
        });

        this.refs.maxY.getDOMNode().value = maxY;
    },

    changeMax: function(e) {
        this.props.onChange({
            maxY: +e.target.value || editorDefaults.maxY
        });
    },

    changeSnaps: function(e) {
        this.props.onChange({
            snapsPerLine: +e.target.value || editorDefaults.snapsPerLine
        });
    },

    changeEditing: function(editing) {
        this.setState({editing: editing});
    },

    setCategoriesFromScale: function() {
        var scale = +this.refs["scaleX"].getDOMNode().value;
        var max = +this.refs["maxX"].getDOMNode().value;
        max = Math.ceil(max / scale) * scale;

        var categories;
        if (this.props.type === HISTOGRAM) {
            // Ranges for histogram labels should start at zero
            categories = _.range(0, max + scale, scale);
        } else {
            categories = _.range(scale, max + scale, scale);
        }
        this.changeCategories(categories);

        this.refs.categories.getDOMNode().value = categories.join(", ");
    },

    toJSON: function(skipValidation) {
        var json = _.pick(this.props, "correct", "starting", "type", "labels",
            "categories", "scaleY", "maxY", "snapsPerLine");

        if (this.props.type === PIC) {
            json.picUrl = this.props.picUrl;
        }

        return json;
    }
});

Widgets.register("plotter", Plotter);
Widgets.register("plotter-editor", PlotterEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../components/text-list-editor.jsx":10,"../core.js":11,"../util.js":19,"../widgets.js":20}],30:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");

var InfoTip = require("../components/info-tip.jsx");
var Widgets = require("../widgets.js");

var Protractor = React.createClass({displayName: 'Protractor',
    getDefaultProps: function() {
        return {
            width: 480,
            height: 480,
            imageUrl: null,
            imageTop: 0,
            imageLeft: 0,
            protractorX: 7.5,
            protractorY: 0.5
        };
    },

    getInitialState: function() {
        return {};
    },

    render: function() {
        return React.DOM.div( {className:"perseus-widget perseus-widget-protractor",
                style:{width: this.props.width, height: this.props.height}}, 
                    this.props.imageUrl && React.DOM.img( {src:this.props.imageUrl,
                        style:{top: this.props.imageTop + "px",
                        left: this.props.imageLeft + "px"}} ),
                    React.DOM.div( {className:"graphie", ref:"graphieDiv"} )
                );
    },

    componentDidMount: function() {
        this.setupGraphie();
    },

    setupGraphie: function() {
        var graphieDiv = this.refs.graphieDiv.getDOMNode();
        $(graphieDiv).empty();
        var graphie = this.graphie = KhanUtil.createGraphie(graphieDiv);

        graphie.init({
            range: [[0, this.props.width / 40], [0, this.props.height / 40]]
        });
        graphie.addMouseLayer();
        this.state.protractor = graphie.protractor([
                this.props.protractorX,
                this.props.protractorY]);
    },

    toJSON: function() {
        return {
            center: this.state.protractor.centerPoint.coord,
            angle: this.state.protractor.rotation
        };
    },

    simpleValidate: function(rubric) {
        return Protractor.validate(this.toJSON(), rubric);
    },

    focus: $.noop
});


_.extend(Protractor, {
    validate: function(state, rubric) {
        return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
        };
    }
});


var ProtractorEditor = React.createClass({displayName: 'ProtractorEditor',
    className: "perseus-widget-protractor",

    getDefaultProps: function() {
        return {
            imageUrl: null,
            imageTop: 0,
            imageLeft: 0
        };
    },

    render: function() {
        return React.DOM.div( {className:"perseus-widget-protractor"}, 
            React.DOM.div(null, "Image displayed under protractor:"),
            React.DOM.div(null, "URL: ",
                React.DOM.input( {type:"text",
                        className:"perseus-widget-protractor-url",
                        ref:"image-url",
                        defaultValue:this.props.imageUrl,
                        onKeyPress:this.changeImageUrl,
                        onBlur:this.changeImageUrl} ),
            InfoTip(null, 
                React.DOM.p(null, "Create an image in graphie, or use the \"Add image\" function "+
                "to create a background.")
            )
            ),
            this.props.imageUrl && React.DOM.div(null, 
                React.DOM.div(null, "Pixels from top: ",
                    React.DOM.input( {type:"text",
                            value:this.props.imageTop,
                            onInput:
                    _.partial(this.changeSetting, "imageTop")} )
                ),
                React.DOM.div(null, "Pixels from left: ",
                    React.DOM.input( {type:"text",
                            value:this.props.imageLeft,
                            onInput:
                    _.partial(this.changeSetting, "imageLeft")} )
                )
            )
        );
    },

    changeImageUrl: function(e) {
        // Only continue on blur or "enter"
        if (e.type === "keypress" && e.keyCode !== 13) {
            return;
        }

        this.props.onChange({
            imageUrl: this.refs["image-url"].getDOMNode().value
        });
    },

    changeSetting: function(type, e) {
        var newProps = {};
        newProps[type] = e.target.value;
        this.props.onChange(newProps);
    },

    toJSON: function() {
        var json = {
            imageUrl: this.props.imageUrl,
            imageTop: this.props.imageTop,
            imageLeft: this.props.imageLeft
        };
        return json;
    }
});

Widgets.register("protractor", Protractor);
Widgets.register("protractor-editor", ProtractorEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../core.js":11,"../widgets.js":20}],31:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");
require("../renderer.jsx");
require("../editor.jsx");

var InfoTip = require("../components/info-tip.jsx");
var Widgets = require("../widgets.js");

var shuffle = Util.shuffle;

var BaseRadio = React.createClass({displayName: 'BaseRadio',
    render: function() {
        var radioGroupName = _.uniqueId("perseus_radio_");
        var inputType = this.props.multipleSelect ? "checkbox" : "radio";

        return React.DOM.ul( {className:"perseus-widget-radio"}, 
            this.props.multipleSelect &&
                React.DOM.div( {className:"instructions"}, 
                    $_(null, "Select all that apply.")
                ),
            this.props.choices.map(function(choice, i) {

                var content = React.DOM.div(null, 
                        React.DOM.input(
                            {ref:"radio" + i,
                            type:inputType,
                            name:radioGroupName,
                            checked:choice.checked,
                            onChange:this.onChange.bind(this, i)} ),
                        choice.content
                    );

                if (this.props.labelWrap) {
                    return React.DOM.li(null, React.DOM.label(null, content));
                } else {
                    return React.DOM.li(null, content);
                }

            }, this)
        );
    },

    onChange: function(radioIndex, e) {
        var newChecked = _.map(this.props.choices, function(choice, i) {
            return this.refs["radio" + i].getDOMNode().checked;
        }, this);

        this.props.onCheckedChange(newChecked);
    },

    focus: function(i) {
        this.refs["radio" + (i || 0)].getDOMNode().focus();
        return true;
    }
});

var Radio = React.createClass({displayName: 'Radio',
    getDefaultProps: function() {
        return {
            choices: [{}],
            randomize: false,
            multipleSelect: false
        };
    },

    render: function() {
        var values = this.props.values || _.map(this.props.choices,
                function() {
            return false;
        });

        var choices = this.props.choices.map(function(choice, i) {
            return {
                // We need to make a copy, which _.pick does
                content: Perseus.Renderer(_.pick(choice, "content")),
                checked: values[i],
                originalIndex: i
            };
        });
        choices = this.randomize(choices);

        return BaseRadio(
            {ref:"baseRadio",
            labelWrap:true,
            multipleSelect:this.props.multipleSelect,
            choices:choices.map(function(choice) {
                return _.pick(choice, "content", "checked");
            }),
            onCheckedChange:this.onCheckedChange} );
    },

    focus: function(i) {
        return this.refs.baseRadio.focus(i);
    },

    onCheckedChange: function(checked) {
        this.props.onChange({
            values: this.derandomize(checked)
        });
    },

    toJSON: function(skipValidation) {
        // Return checked inputs in the form {values: [bool]}. (Dear future
        // timeline implementers: this used to be {value: i} before multiple
        // select was added)
        if (this.props.values) {
            return _.pick(this.props, "values");
        } else {
            // Nothing checked
            return {
                values: _.map(this.props.choices, function() {
                    return false;
                })
            };
        }
    },

    simpleValidate: function(rubric) {
        return Radio.validate(this.toJSON(), rubric);
    },

    randomize: function(array) {
        if (this.props.randomize && this.props.problemNum) {
            return shuffle(array, this.props.problemNum);
        } else {
            return array;
        }
    },

    derandomize: function(array) {
        if (this.props.randomize && this.props.problemNum) {
            var map = shuffle(_.range(array.length), this.props.problemNum);
            var derandomized = new Array(array.length);
            _.each(map, function(shuffledIndex, originalIndex) {
                derandomized[shuffledIndex] = array[originalIndex];
            });
            return derandomized;
        } else {
            return array;
        }
    }
});

_.extend(Radio, {
    validate: function(state, rubric) {
        if (!_.any(state.values)) {
            return {
                type: "invalid",
                message: null
            };
        } else {
            /* jshint -W018 */
            var correct = _.all(state.values, function(selected, i) {
                return !!rubric.choices[i].correct === selected;
            });
            /* jshint +W018 */

            return {
                type: "points",
                earned: correct ? 1 : 0,
                total: 1,
                message: null
            };
        }
    }
});

var RadioEditor = React.createClass({displayName: 'RadioEditor',
    getDefaultProps: function() {
        return {
            choices: [{}],
            randomize: false,
            multipleSelect: false
        };
    },

    render: function() {
        return React.DOM.div(null, 
            BaseRadio(
                {ref:"baseRadio",
                multipleSelect:this.props.multipleSelect,
                labelWrap:false,
                choices:this.props.choices.map(function(choice, i) {
                    var editor = Perseus.Editor({
                        ref: "editor" + i,
                        content: choice.content || "",
                        widgetEnabled: false,
                        onChange: function(newProps) {
                            if ("content" in newProps) {
                                this.onContentChange(i, newProps.content);
                            }
                        }.bind(this)
                    });
                    var deleteLink = React.DOM.a( {href:"#",
                            className:"simple-button orange delete-choice",
                            title:"Remove this choice",
                            onClick:this.onDelete.bind(this, i)}, 
                        React.DOM.span( {className:"icon-trash"} )
                    );
                    return {
                        content: React.DOM.div( {className:"choice-editor"}, 
                            editor,
                            this.props.choices.length >= 2 && deleteLink
                        ),
                        checked: choice.correct
                    };
                }, this),
                onCheckedChange:this.onCheckedChange} ),

            React.DOM.div( {className:"add-choice-container"}, 
                React.DOM.a( {href:"#", className:"simple-button orange",
                        onClick:this.addChoice}, 
                    React.DOM.span( {className:"icon-plus"} ),
                    " Add a choice "
                )
            ),

            React.DOM.div(null, React.DOM.label(null, 
                React.DOM.input(
                    {type:"checkbox",
                    checked:this.props.randomize,
                    onChange:function(e) {
                        this.props.onChange({randomize: e.target.checked});
                    }.bind(this)} ),
                " Randomize answer order "
            ),
            InfoTip(null, 
                React.DOM.p(null, "For this option to work, don’t label choices or have \"None "+
                "of the above\" as an option. For true/false questions, make the "+
                "first choice True and the second choice False, and do NOT "+
                "select randomize answer order.")
            )
            ),

            React.DOM.div(null, React.DOM.label(null, 
                React.DOM.input(
                    {type:"checkbox",
                    checked:this.props.multipleSelect,
                    onChange:this.onMultipleSelectChange} ),
                " Allow multiple selections "
            ))
        );
    },

    onMultipleSelectChange: function(e) {

        var allowMultiple = e.target.checked;

        var numSelected = _.reduce(this.props.choices,
                function(memo, choice) {
            return choice.correct ? memo + 1 : memo;
        }, 0);

        if (!allowMultiple && numSelected > 1) {
            var choices = _.map(this.props.choices, function(choice) {
                return _.defaults({
                    correct: false
                }, choice);
            });
            this.props.onChange({
                multipleSelect: allowMultiple,
                choices: choices
            });

        } else {
            this.props.onChange({
                multipleSelect: allowMultiple
            });
        }
    },

    onCheckedChange: function(checked) {
        var choices = _.map(this.props.choices, function(choice, i) {
            return _.extend({}, choice, {correct: checked[i]});
        });
        this.props.onChange({choices: choices});
    },

    onContentChange: function(choiceIndex, newContent, e) {
        var choices = this.props.choices.slice();
        choices[choiceIndex] = _.extend({}, choices[choiceIndex], {
            content: newContent
        });
        this.props.onChange({choices: choices});
    },

    onDelete: function(choiceIndex, e) {
        e.preventDefault();
        var choices = this.props.choices.slice();
        choices.splice(choiceIndex, 1);
        this.props.onChange({choices: choices});
    },

    addChoice: function(e) {
        e.preventDefault();

        var choices = this.props.choices;
        this.props.onChange({choices: choices.concat([{}])}, function() {
            this.refs["editor" + choices.length].focus();
        }.bind(this));
    },

    focus: function() {
        this.refs.editor0.focus();
        return true;
    },

    toJSON: function(skipValidation) {
        if (!skipValidation &&
                !_.some(_.pluck(this.props.choices, "correct"))) {
            alert("Warning: No choice is marked as correct.");
        }

        return _.pick(this.props, "choices", "randomize", "multipleSelect");
    }
});

Widgets.register("radio", Radio);
Widgets.register("radio-editor", RadioEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../core.js":11,"../editor.jsx":13,"../renderer.jsx":17,"../util.js":19,"../widgets.js":20}],32:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");

var shuffle = Util.shuffle;

var InfoTip        = require("../components/info-tip.jsx");
var PropCheckBox   = require("../components/prop-check-box.jsx");
var Sortable       = require("../components/sortable.jsx");
var TextListEditor = require("../components/text-list-editor.jsx");
var Widgets        = require("../widgets.js");

var HORIZONTAL = "horizontal",
    VERTICAL = "vertical";

var Sorter = React.createClass({displayName: 'Sorter',
    propTypes: {
        correct: React.PropTypes.array,
        layout: React.PropTypes.oneOf([HORIZONTAL, VERTICAL]),
        padding: React.PropTypes.bool,
        problemNum: React.PropTypes.number
    },

    getDefaultProps: function() {
        return {
            correct: [],
            layout: HORIZONTAL,
            padding: true,
            problemNum: 0
        };
    },

    render: function() {
        var options = shuffle(
            this.props.correct,
            this.props.problemNum,
            /* ensurePermuted */ true
        );

        return React.DOM.div( {className:"perseus-widget-sorter ui-helper-clearfix"}, 
            Sortable(
                {options:options,
                layout:this.props.layout,
                padding:this.props.padding,
                ref:"sortable"} )
        );
    },

    toJSON: function(skipValidation) {
        return {options: this.refs.sortable.getOptions()};
    },

    simpleValidate: function(rubric) {
        return Sorter.validate(this.toJSON(), rubric);
    },
});


_.extend(Sorter, {
    validate: function(state, rubric) {
        var correct = _.isEqual(state.options, rubric.correct);

        return {
            type: "points",
            earned: correct ? 1 : 0,
            total: 1,
            message: null
        };
    }
});


var SorterEditor = React.createClass({displayName: 'SorterEditor',
    propTypes: {
        correct: React.PropTypes.array,
        layout: React.PropTypes.oneOf([HORIZONTAL, VERTICAL]),
        padding: React.PropTypes.bool
    },

    getDefaultProps: function() {
        return {
            correct: ["$x$", "$y$", "$z$"],
            layout: HORIZONTAL,
            padding: true
        };
    },

    render: function() {
        var editor = this;

        return React.DOM.div(null, 
            React.DOM.div(null, 
                " Correct answer: ",
                InfoTip(null, React.DOM.p(null, 
                    " Enter the correct answer (in the correct order) here. The "+
                    "preview on the right will have the cards in a randomized "+
                    "order, which is how the student will see them. "
                ))
            ),
            TextListEditor(
                {options:this.props.correct,
                onChange:function(options, cb) {
                    editor.props.onChange({correct: options}, cb);
                },
                layout:this.props.layout} ),
            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Layout: ",
                    React.DOM.select( {value:this.props.layout,
                            onChange:this.onLayoutChange}, 
                        React.DOM.option( {value:HORIZONTAL}, "Horizontal"),
                        React.DOM.option( {value:VERTICAL}, "Vertical")
                    )
                ),
                InfoTip(null, 
                    React.DOM.p(null, "Use the horizontal layout for short text and small "+
                    "images. The vertical layout is best for longer text and "+
                    "larger images.")
                )
            ),
            React.DOM.div(null, 
                PropCheckBox(
                    {label:"Padding:",
                    padding:this.props.padding,
                    onChange:this.props.onChange} ),
                InfoTip(null, 
                    React.DOM.p(null, "Padding is good for text, but not needed for images.")
                )
            )
        );
    },

    onLayoutChange: function(e) {
        this.props.onChange({layout: e.target.value});
    },

    toJSON: function(skipValidation) {
        return _.pick(this.props, "correct", "layout", "padding");
    }
});

Widgets.register("sorter", Sorter);
Widgets.register("sorter-editor", SorterEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../components/prop-check-box.jsx":8,"../components/sortable.jsx":9,"../components/text-list-editor.jsx":10,"../core.js":11,"../util.js":19,"../widgets.js":20}],33:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");
require("../editor.jsx");
require("../renderer.jsx");
var InfoTip = require("../components/info-tip.jsx");

var Widgets = require("../widgets.js");
var Editor  = Perseus.Editor;


var Table = React.createClass({displayName: 'Table',
    render: function() {
        var headers = this.props.headers;
        return React.DOM.table( {className:"perseus-widget-table-of-values non-markdown"}, 
            React.DOM.thead(null, 
                React.DOM.tr(null, 
                    _.map(headers, function(header) {
                        return React.DOM.th(null, Perseus.Renderer({content: header}));
                    })
                
                )
            ),
            React.DOM.tbody(null, 
                _(this.props.rows).times(function(r) {
                    return React.DOM.tr(null, 
                        _(this.props.columns).times(function(c) {
                            return React.DOM.td(null, 
                                React.DOM.input(
                                    {ref:"answer" + r + "," + c,
                                    type:"text"}
                                )
                            );
                        })
                    );
                }.bind(this))
            
            )
        );
    },

    toJSON: function() {
        var self = this;
        return _.map(self.props.answers, function(answer, r) {
            return _.map(self.props.headers, function(header, c) {
                return self.refs["answer" + r + "," + c].getDOMNode().value;
            });
        });
    },

    simpleValidate: function(rubric) {
        return Table.validate(this.toJSON(), rubric);
    },

    focus: function() {
        this.refs["answer0,0"].getDOMNode().focus();
        return true;
    }
});

_.extend(Table, {
    validate: function(state, rubric) {
        var filterNonEmpty = function (table) {
            return _.filter(table, function (row) {

                // Check if row has a cell that is nonempty
                return _.some(row, _.identity);
            });
        };
        var solution = filterNonEmpty(rubric.answers);
        var supplied = filterNonEmpty(state);
        var hasEmptyCell = _.some(supplied, function(row) {
            return _.some(row, function(cell) {
                return cell === "";
            });
        });
        if (hasEmptyCell || !supplied.length) {
            return {
                type: "invalid",
                message: null
            };
        }
        if (supplied.length !== solution.length) {
            return {
                type: "points",
                earned: 0,
                total: 1,
                message: null
            };
        }
        var createValidator = Khan.answerTypes
                                  .number.createValidatorFunctional;
        var message = null;
        var allCorrect = _.every(solution, function (rowSolution) {
            var i;
            for (i = 0; i < supplied.length; i++) {
                var rowSupplied = supplied[i];
                var correct = _.every(rowSupplied, function (cellSupplied, i) {
                    var cellSolution = rowSolution[i];
                    var validator = createValidator(
                            cellSolution, {
                                simplify: true
                            });
                    var result = validator(cellSupplied);
                    if (result.message) {
                        message = result.message;
                    }
                    return result.correct;
                });
                if (correct) {
                    supplied.splice(i, 1);
                    return true;
                }
            }
            return false;
        });
        return {
            type: "points",
            earned: allCorrect ? 1 : 0,
            total: 1,
            message: message
        };
    }
});

var TableEditor = React.createClass({displayName: 'TableEditor',
    getDefaultProps: function() {
        var defaultRows = 4;
        var defaultColumns = 1;
        var blankAnswers = _(defaultRows).times(function() {
            return Util.stringArrayOfSize(defaultColumns);
        });
        return {
            headers: [""],
            rows: defaultRows,
            columns: defaultColumns,
            numRawRows: defaultRows,
            numRawColumns: defaultColumns,
            answers: blankAnswers,
            type: "set"
        };
    },

    focus: function() {
        this.refs.numberOfColumns.getDOMNode().focus();
    },

    render: function() {
        var self = this;
        var rows = this.props.rows;
        var cols = this.props.columns;
        return React.DOM.div(null, 
            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Number of columns: ",
                    React.DOM.input(
                        {ref:"numberOfColumns",
                        type:"text",
                        value:this.props.numRawColumns,
                        onInput:this.onSizeInput}
                    )
                )
            ),
            React.DOM.div(null, 
                React.DOM.label(null, 
                    " Number of rows: ",
                    React.DOM.input(
                        {ref:"numberOfRows",
                        type:"text",
                        value:this.props.numRawRows,
                        onInput:this.onSizeInput}
                    )
                )
            ),
            React.DOM.div(null, 
                " Table of answers type: ",
                React.DOM.ul(null, 
                    React.DOM.li(null, 
                        React.DOM.label(null, 
                            React.DOM.input(
                                {type:"radio",
                                checked:"checked"}
                            ),
                            " Set of values (complete) "
                        ),
                        InfoTip(null, 
                            React.DOM.p(null, "The student has to fill out all cells in the "+
                            "table.  For partially filled tables create a table "+
                            "using the template, and insert text input boxes "+
                            "as desired.")
                        )
                    )
                )
            ),
            React.DOM.div(null, 
                React.DOM.table( {className:"perseus-widget-table-of-values non-markdown"}, 
                    React.DOM.thead(null, 
                        React.DOM.tr(null, 
                            _(cols).times(function(i) {
                                return React.DOM.th(null, 
                                    Editor(
                                        {ref:"columnHeader" + i,
                                        content:self.props.headers[i],
                                        widgetEnabled:false,
                                        onChange:
                                            self.onHeaderChange.bind(self, i)
                                        }
                                    )
                                );
                            })
                        )
                    ),
                    React.DOM.tbody(null, 
                        _(rows).times(function(r) {
                            return React.DOM.tr(null, 
                                _(cols).times(function(c) {
                                    return React.DOM.td(null, 
                                        React.DOM.input(
                                            {ref:"answer" + r + "," + c,
                                            type:"text",
                                            onInput:self.onAnswerInput,
                                            value:self.props.answers[r][c]}
                                        )
                                    );
                                })
                            );
                        })
                    )
                )
            )
        );
    },

    onHeaderChange: function(index, newProps) {
        if (_.has(newProps, "content")) {
            var headers = this.props.headers.slice();
            headers[index] = newProps.content;
            this.props.onChange({headers: headers});
        }
    },

    onSizeInput: function() {
        var numRawRows = this.refs.numberOfRows.getDOMNode().value;
        var numRawCols = this.refs.numberOfColumns.getDOMNode().value;
        var rows = +numRawRows || 0;
        var cols = +numRawCols || 0;
        rows = Math.min(Math.max(1, rows), 30);
        cols = Math.min(Math.max(1, cols), 6);
        var oldColumns = this.props.columns;
        var oldRows = this.props.rows;

        var answers = this.props.answers;
        if (oldRows < rows) {
            _(rows - oldRows).times(function() {
                answers.push(Util.stringArrayOfSize(oldColumns));
            });
        }

        var headers = this.props.headers;

        function fixColumnSizing(array) {
            _(cols - oldColumns).times(function() {
                array.push("");
            });
        }

        if (oldColumns < cols) {
            fixColumnSizing(headers);
            _.each(answers, fixColumnSizing);
        }

        this.props.onChange({
            rows: rows,
            columns: cols,
            numRawRows: numRawRows,
            numRawColumns: numRawCols,
            answers: answers,
            headers: headers
        });
    },

    onAnswerInput: function() {
        var self = this;
        var answers = _(self.props.rows).times(function(r) {
            return _(self.props.columns).times(function(c) {
                return self.refs["answer" + r + "," + c].getDOMNode().value;
            });
        });
        this.props.onChange({answers: answers});
    },

    toJSON: function() {
        var self = this;
        var answers = this.props.answers.slice(0, this.props.rows);
        answers = _.map(answers, function(row) {
            return row.slice(0, self.props.columns);
        });
        var json = _.pick(this.props, 'rows', 'columns');
        json.answers = answers;
        json.headers = this.props.headers.slice(0, this.props.columns);
        return json;
    }
});

Widgets.register("table", Table);
Widgets.register("table-editor", TableEditor);

})(Perseus);

},{"../components/info-tip.jsx":6,"../core.js":11,"../editor.jsx":13,"../renderer.jsx":17,"../util.js":19,"../widgets.js":20}],34:[function(require,module,exports){
/** @jsx React.DOM */
(function(Perseus) {

require("../core.js");
var Util = require("../util.js");

var Graph         = require("../components/graph.jsx");
var GraphSettings = require("../components/graph-settings.jsx");
var InfoTip       = require("../components/info-tip.jsx");
var NumberInput   = require("../components/number-input.jsx");
var PropCheckBox  = require("../components/prop-check-box.jsx");
var TeX           = require("../tex.jsx");
var Widgets       = require("../widgets.js");

var ROTATE_SNAP_DEGREES = 15;
var DEGREE_SIGN = "\u00B0";
var RENDER_TRANSFORM_DELAY_IN_MS = 300;
var ROTATE_HANDLE_DIST = 1.5;
var REFLECT_ROTATE_HANDLE_DIST = 2;
var REFLECT_BUTTON_SIZE = 1;

var deepEq = Util.deepEq;
var knumber = KhanUtil.knumber;
var kvector = KhanUtil.kvector;
var kpoint = KhanUtil.kpoint;
var kray = KhanUtil.kray;
var kline = KhanUtil.kline;

var defaultBoxSize = 400;
var defaultBackgroundImage = {
    url: null,
    scale: 1,
    bottom: 0,
    left: 0,
};

function arraySum(array) {
    return _.reduce(array, function(memo, arg) { return memo + arg; }, 0);
}

/* Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */
function pluckObject(object, subKey) {
    return _.object(_.map(object, function (value, key) {
        return [key, value[subKey]];
    }));
}

var defaultGraphProps = function(setProps, boxSize) {
    setProps = setProps || {};
    var labels = setProps.labels || ["x", "y"];
    var range = setProps.range || [[-10, 10], [-10, 10]];
    var step = setProps.step || [1, 1];
    var gridStep = setProps.gridStep ||
               Util.getGridStep(range, step, boxSize);
    return {
        box: [boxSize, boxSize],
        labels: labels,
        range: range,
        step: step,
        gridStep: gridStep,
        valid: true,
        backgroundImage: defaultBackgroundImage,
        markings: "grid",
        showProtractor: false
    };
};

var defaultTransformerProps = {
    gradeEmpty: false,
    graphMode: "interactive",
    listMode: "dynamic",
    tools: {
        translation: {
            enabled: true,
            required: false,
            constraints: {}
        },
        rotation: {
            enabled: true,
            required: false,
            constraints: {
                fixed: false
            },
            coord: [1, 6]
        },
        reflection: {
            enabled: true,
            required: false,
            constraints: {
                fixed: false
            },
            coords: [[2, -4], [2, 2]]
        },
        dilation: {
            enabled: true,
            required: false,
            constraints: {
                fixed: false
            },
            coord: [6, 6]
        }
    },
    drawSolutionShape: true,
    starting: {
        shape: {
            type: "polygon-3",
            coords: [[2, 2], [2, 6], [7, 2]],
        },
        transformations: []
    },
    correct: {
        shape: {
            type: "polygon-3",
            coords: [[2, 2], [2, 6], [7, 2]],
        },
        transformations: []
    }
};

function colorForTool(tool) {
    return tool.constraints.fixed ? KhanUtil.GRAY : KhanUtil.ORANGE;
}


/* Scales a distance from the default range of
 * [-10, 10] to a given props.range pair
 *
 * Used for sizing various transformation tools
 * (rotation handle, dilation circle)
 */
function scaleToRange(dist, range) {
    var spreadX = range[0][1] - range[0][0];
    var spreadY = range[1][1] - range[1][0];

    return dist * Math.max(spreadX, spreadY) / 20;
}

function dilatePointFromCenter(point, dilationCenter, scale) {
    var pv = KhanUtil.kvector.subtract(point, dilationCenter);
    var pvScaled = KhanUtil.kvector.scale(pv, scale);
    var transformedPoint = KhanUtil.kvector.add(dilationCenter, pvScaled);
    return transformedPoint;
}

function stringFromDecimal(number) {
    return String(KhanUtil.roundTo(9, number));
}

function stringFromFraction(number) {
    var frac = KhanUtil.toFraction(number, knumber.DEFAULT_TOLERANCE);
    if (frac[1] === 1) {
        return stringFromDecimal(number);
    } else {
        return stringFromDecimal(frac[0]) + "/" +
                stringFromDecimal(frac[1]);
    }
}

function texFromPoint(point) {
    return [
        TeX(null, "("),
        stringFromDecimal(point[0]),
        TeX(null, ", {}"),
        stringFromDecimal(point[1]),
        TeX(null, ")")
    ];
}

function texFromVector(vector) {
    return [
        TeX(null, "\\langle"),
        stringFromDecimal(vector[0]),
        TeX(null, ", {}"),
        stringFromDecimal(vector[1]),
        TeX(null, "\\rangle")
    ];
}

function texFromAngleDeg(angleDeg) {
    return stringFromDecimal(angleDeg) + DEGREE_SIGN;
}

function orderInsensitiveCoordsEqual(coords1, coords2) {
    coords1 = _.clone(coords1).sort(kpoint.compare);
    coords2 = _.clone(coords2).sort(kpoint.compare);
    return _.all(_.map(coords1, function(coord1, i) {
        var coord2 = coords2[i];
        return kpoint.equal(coord1, coord2);
    }));
}



/* Perform operations on raw transform objects */
var TransformOps = {
    apply: function(transform) {
        // Any transformation with empty text boxes is a no-op until
        // filled out (these show up as nulls in transform.vector/line/etc).
        // TODO (jack): Merge this just into reflections now that other
        // transforms are always valid (after merging transformation
        // collapsing, which may use isValid)
        if (!Transformations[transform.type].isValid(transform)) {
            return _.identity;  // do not transform the coord
        } else {
            return Transformations[transform.type].apply(transform);
        }
    },

    append: function(transformList, newTransform) {
        // Append newTransform to transformList, and collapse the last
        // two transforms if they are collapsable
        var results = TransformOps._appendAndCollapseLastTwo(
            transformList,
            newTransform
        );
        // Collapse any no-ops at the end of the transformation list
        return TransformOps._collapseFinalNoOps(results);
    },

    _collapseFinalNoOps: function(transforms) {
        // Collapse no-op transformations at the end of the list
        if (transforms.length && TransformOps.isNoOp(_.last(transforms))) {
            return _.initial(transforms);
        } else {
            return transforms;
        }
    },

    _appendAndCollapseLastTwo: function(transformList, newTransform) {
        if (!transformList.length) {
            return [newTransform];
        } else {
            var collapsed = TransformOps.collapse(
                _.last(transformList),
                newTransform
            );
            return _.initial(transformList).concat(collapsed);
        }
    },

    isNoOp: function(transform) {
        return Transformations[transform.type].isNoOp(transform);
    },

    collapse: function(transform1, transform2) {
        // We can only collapse transforms that have the same type
        if (transform1.type !== transform2.type) {
            return [transform1, transform2];
        }

        // Clicking the button again removes empty transformations
        if (TransformOps.isEmpty(transform1) &&
                TransformOps.isEmpty(transform2)) {
            return [];
        }

        // Don't collapse invalid transformations otherwise
        if (!TransformOps.isValid(transform1) ||
                !TransformOps.isValid(transform2)) {
            return [transform1, transform2];
        }

        return TransformOps._collapseValidMonotypedTransforms(
            transform1,
            transform2
        );
    },

    isValid: function(transform) {
        return Transformations[transform.type].isValid(transform);
    },

    isEmpty: function(transform) {
        return Transformations[transform.type].isEmpty(transform);
    },

    _collapseValidMonotypedTransforms: function(transform1, transform2) {
        var collapsed = Transformations[transform1.type].collapse(
            transform1,
            transform2
        );
        if (collapsed) {
            // Force all answers into an array
            if (!_.isArray(collapsed)) {
                collapsed = [collapsed];
            }
            // Add types to all transforms in the answer
            _.each(collapsed, function(transform) {
                transform.type = transform1.type;
            });
            return collapsed;
        } else {
            // These transforms can't be collapsed together
            return [transform1, transform2];
        }
    },

    toTeX: function(transform) {
        return Transformations[transform.type].toTeX(transform);
    },

    /* A react representation of this transform object */
    ListItem: React.createClass({
        render: function() {
            if (this.props.mode === "dynamic") {
                return React.DOM.div(null, 
                    TransformOps.toTeX(this.props.transform)
                );
            } else if (this.props.mode === "interactive") {
                var transformClass =
                        Transformations[this.props.transform.type].Input;
                return transformClass(_.extend({
                    ref: "transform",
                    onChange: this.handleChange
                }, this.props.transform));
            } else {
                throw new Error("Invalid mode: " + this.props.mode);
            }
        },
        value: function() {
            if (this.props.mode === "interactive") {
                return _.extend({
                    type: this.props.transform.type,
                }, this.refs.transform.value());
            } else {
                return this.props.transform;
            }
        },
        handleChange: _.debounce(function() {
            this.props.onChange(this.value());
        }, RENDER_TRANSFORM_DELAY_IN_MS),
        focus: function() {
            this.refs.transform.focus();
        }
    })
};

var Transformations = {
    translation: {
        verbName: "Translate",
        nounName: "Translation",
        apply: function(transform) {
            return function(coord) {
                return KhanUtil.kvector.add(coord, transform.vector);
            };
        },
        isValid: function(transform) {
            return _.isFinite(transform.vector[0]) &&
                _.isFinite(transform.vector[1]);
        },
        isEmpty: function(transform) {
            return transform.vector[0] === null &&
                transform.vector[1] === null;
        },
        isNoOp: function(transform) {
            return kvector.equal(transform.vector, [0, 0]);
        },
        collapse: function(transform1, transform2) {
            return {
                vector: kvector.add(
                    transform1.vector,
                    transform2.vector
                )
            };
        },
        toTeX: function(transform) {
            return ["Translation by ", texFromVector(transform.vector)];
        },
        Input: React.createClass({
            render: function() {
                return React.DOM.div(null, 
                    " Translation by ",
                    TeX(null, "\\langle"),
                    NumberInput(
                        {ref:"x",
                        placeholder:0,
                        value:this.props.vector[0],
                        onChange:this.props.onChange} ),
                    TeX(null, ", {}"),
                    NumberInput(
                        {ref:"y",
                        placeholder:0,
                        value:this.props.vector[1],
                        onChange:this.props.onChange} ),
                    TeX(null, "\\rangle")
                );
            },
            value: function() {
                var x = this.refs.x.getValue();
                var y = this.refs.y.getValue();
                return {
                    vector: [x, y]
                };
            },
            focus: function() {
                this.refs.x.focus();
            }
        })
    },

    rotation: {
        verbName: "Rotate",
        nounName: "Rotation",
        apply: function(transform) {
            return function(coord) {
                return KhanUtil.kpoint.rotateDeg(coord, transform.angleDeg,
                        transform.center);
            };
        },
        isValid: function(transform) {
            return _.isFinite(transform.angleDeg) &&
                _.isFinite(transform.center[0]) &&
                _.isFinite(transform.center[1]);
        },
        isEmpty: function(transform) {
            return transform.angleDeg === null &&
                transform.center[0] === null &&
                transform.center[1] === null;
        },
        isNoOp: function(transform) {
            return knumber.equal(transform.angleDeg, 0);
        },
        collapse: function(transform1, transform2) {
            if (!kpoint.equal(transform1.center, transform2.center)) {
                return false;
            }
            return {
                center: transform1.center,
                angleDeg: transform1.angleDeg + transform2.angleDeg
            };
        },
        toTeX: function(transform) {
            return [
                "Rotation by ",
                texFromAngleDeg(transform.angleDeg),
                " about ",
                texFromPoint(transform.center)
            ];
        },
        Input: React.createClass({
            render: function() {
                return React.DOM.div(null, 
                    " Rotation about ", TeX(null, "("),
                    NumberInput(
                        {ref:"centerX",
                        placeholder:0,
                        value:this.props.center[0],
                        onChange:this.props.onChange} ),
                    TeX(null, ", {}"),
                    NumberInput(
                        {ref:"centerY",
                        placeholder:0,
                        value:this.props.center[1],
                        onChange:this.props.onChange} ),
                    TeX(null, ")"), " by ",
                    NumberInput(
                        {ref:"angleDeg",
                        placeholder:0,
                        value:this.props.angleDeg,
                        onChange:this.props.onChange} ),
                    DEGREE_SIGN
                );
            },
            value: function() {
                var angleDeg = this.refs.angleDeg.getValue();
                var centerX = this.refs.centerX.getValue();
                var centerY = this.refs.centerY.getValue();
                return {
                    angleDeg: angleDeg,
                    center: [centerX, centerY]
                };
            },
            focus: function() {
                this.refs.centerX.focus();
            }
        })
    },

    reflection: {
        verbName: "Reflect",
        nounName: "Reflection",
        apply: function(transform) {
            return function(coord) {
                return KhanUtil.kpoint.reflectOverLine(
                    coord,
                    transform.line
                );
            };
        },
        isValid: function(transform) {
            // A bit hacky, but we'll also define reflecting over a
            // single point as a no-op, to avoid NaN fun.
            return _.all(_.flatten(transform.line), _.isFinite) &&
                    !kpoint.equal(transform.line[0], transform.line[1]);
        },
        isEmpty: function(transform) {
            return _.all(_.flatten(transform.line), _.isNull);
        },
        isNoOp: function(transform) {
            // Invalid transforms are implicitly no-ops, so we don't
            // have to catch that case here.
            return false;
        },
        collapse: function(transform1, transform2) {
            if (!kline.equal(transform1.line, transform2.line)) {
                return false;
            }
            return [];
        },
        toTeX: function(transform) {
            var point1 = transform.line[0];
            var point2 = transform.line[1];
            return [
                "Reflection over the line from ",
                texFromPoint(point1),
                " to ",
                texFromPoint(point2)
            ];
        },
        Input: React.createClass({
            render: function() {
                return React.DOM.div(null, 
                    " Reflection over the line from ",
                    TeX(null, "("),
                    NumberInput(
                        {ref:"x1",
                        allowEmpty:true,
                        value:this.props.line[0][0],
                        onChange:this.props.onChange} ),
                    TeX(null, ", {}"),
                    NumberInput(
                        {ref:"y1",
                        allowEmpty:true,
                        value:this.props.line[0][1],
                        onChange:this.props.onChange} ),
                    TeX(null, ")"), " to ", TeX(null, "("),
                    NumberInput(
                        {ref:"x2",
                        allowEmpty:true,
                        value:this.props.line[1][0],
                        onChange:this.props.onChange} ),
                    TeX(null, ", {}"),
                    NumberInput(
                        {ref:"y2",
                        allowEmpty:true,
                        value:this.props.line[1][1],
                        onChange:this.props.onChange} ),
                    TeX(null, ")")
                );
            },
            value: function() {
                var x1 = this.refs.x1.getValue();
                var y1 = this.refs.y1.getValue();
                var x2 = this.refs.x2.getValue();
                var y2 = this.refs.y2.getValue();
                return {
                    line: [[x1, y1], [x2, y2]]
                };
            },
            focus: function() {
                this.refs.x1.focus();
            }
        })
    },

    dilation: {
        verbName: "Dilate",
        nounName: "Dilation",
        apply: function(transform) {
            return function(coord) {
                return dilatePointFromCenter(coord, transform.center,
                        transform.scale);
            };
        },
        isValid: function(transform) {
            return _.isFinite(transform.scale) &&
                _.isFinite(transform.center[0]) &&
                _.isFinite(transform.center[1]);
        },
        isEmpty: function(transform) {
            return transform.scale === null &&
                transform.center[0] === null &&
                transform.center[1] === null;
        },
        isNoOp: function(transform) {
            return knumber.equal(transform.scale, 1);
        },
        collapse: function(transform1, transform2) {
            if (!kpoint.equal(transform1.center, transform2.center)) {
                return false;
            }
            return {
                center: transform1.center,
                scale: transform1.scale * transform2.scale
            };
        },
        toTeX: function(transform) {
            var scaleString = stringFromFraction(transform.scale);
            return [
                "Dilation of scale ",
                scaleString,
                " about ",
                texFromPoint(transform.center)
            ];
        },
        Input: React.createClass({
            render: function() {
                return React.DOM.div(null, 
                    " Dilation about ",
                    TeX(null, "("),
                    NumberInput(
                        {ref:"x",
                        placeholder:0,
                        value:this.props.center[0],
                        onChange:this.props.onChange} ),
                    TeX(null, ", {}"),
                    NumberInput(
                        {ref:"y",
                        placeholder:0,
                        value:this.props.center[1],
                        onChange:this.props.onChange} ),
                    TeX(null, ")"), " by scale ",
                    NumberInput(
                        {ref:"scale",
                        placeholder:1,
                        value:this.props.scale,
                        onChange:this.props.onChange} )
                );
            },
            value: function() {
                var scale = this.refs.scale.getValue();
                var x = this.refs.x.getValue();
                var y = this.refs.y.getValue();
                return {
                    scale: scale,
                    center: [x, y]
                };
            },
            focus: function() {
                this.refs.x.focus();
            }
        })
    }
};


/* Various functions to deal with different shape types */
var ShapeTypes = {
    getPointCountForType: function(type) {
        var splitType = type.split("-");
        if (splitType[0] === "polygon") {
            return splitType[1] || 3;
        } else if (splitType[0] === "line" ||
                splitType[0] === "lineSegment") {
            return 2;
        } else if (splitType[0] === "angle") {
            return 3;
        } else if (splitType[0] === "circle") {
            return 2;
        } else if (splitType[0] === "point") {
            return 1;
        }
    },

    addMovableShape: function(graphie, options) {
        if (options.editable && options.translatable) {
            throw new Error("It doesn't make sense to have a movable shape " +
                    "where you can stretch the points and translate them " +
                    "simultaneously. options: " + JSON.stringify(options));
        }

        var shape;
        var points = _.map(options.shape.coords, function(coord) {
            var currentPoint;
            var isMoving = false;
            var previousCoord = coord;

            var onMove = function(x, y) {
                if (!isMoving) {
                    previousCoord = currentPoint.coord;
                    isMoving = true;
                }

                var moveVector = KhanUtil.kvector.subtract(
                    [x, y],
                    currentPoint.coord
                );

                // Translate from (x, y) semantics to (dX, dY) semantics
                // This is more useful for translations on multiple points,
                // where we care about how the points moved, not where any
                // individual point ended up
                if (options.onMove) {
                    moveVector = options.onMove(moveVector[0],
                            moveVector[1]);
                }

                // Perform a translation on all points in this shape when
                // any point moves
                if (options.translatable) {
                    _.each(points, function(point) {
                        // The point itself will be updated by the
                        // movablePoint class, so only translate the other
                        // points
                        if (point !== currentPoint) {
                            point.setCoord(KhanUtil.kvector.add(
                                point.coord,
                                moveVector
                            ));
                        }
                    });
                }

                // Update our shape and our currentPoint
                // Without this, some shapes (circles, angles) appear
                // "bouncy" as they are updated with currentPoint at the
                // current mouse coordinate (oldCoord), rather than newCoord
                var oldCoord = currentPoint.coord;
                var newCoord = KhanUtil.kvector.add(
                    currentPoint.coord,
                    moveVector
                );
                // Temporarily change our coordinate so that
                // shape.update() sees the new coordinate
                currentPoint.coord = newCoord;
                shape.update();
                // ...But don't break onMove, which assumes it
                // is the only thing changing our coord
                currentPoint.coord = oldCoord;
                return newCoord;
            };

            var onMoveEnd = function() {
                // onMove isn't guaranteed to be called before onMoveEnd, so
                // we have to take into account that we may not have moved and
                // set previousCoord.
                if (options.onMoveEnd && isMoving) {
                    isMoving = false;
                    // We don't use the supplied x and y parameters here
                    // because MovablePoint's onMoveEnd semantics suck.
                    // It returns the mouseX, mouseY without processing them
                    // through onMove, leaving us with weird fractional moves
                    var change = KhanUtil.kvector.subtract(
                        currentPoint.coord,
                        previousCoord
                    );
                    options.onMoveEnd(change[0], change[1]);
                }
                shape.update();
            };

            currentPoint = graphie.addMovablePoint({
                coord: coord,
                normalStyle: options.pointStyle,
                highlightStyle: options.pointStyle,
                constraints: {
                    fixed: !options.translatable && !options.editable
                },
                visible: options.showPoints,
                snapX: options.snap && options.snap[0] || 0,
                snapY: options.snap && options.snap[1] || 0,
                bounded: false, // Don't bound it when placing it on the graph
                onMove: onMove,
                onMoveEnd: onMoveEnd
            });

            // Bound it when moving
            // We can't set this earlier, because doing so would mean any
            // points outside of the graph would be moved into a moved into
            // a position that doesn't preserve the shape
            currentPoint.bounded = true;

            return currentPoint;
        });

        shape = ShapeTypes.addShape(graphie, options, points);
        var removeShapeWithoutPoints = shape.remove;
        shape.remove = function() {
            removeShapeWithoutPoints.apply(shape);
            _.invoke(points, "remove");
        };
        return shape;
    },

    addShape: function(graphie, options, points) {
        points = points || options.shape.coords;

        var types = ShapeTypes._typesOf(options.shape);
        var typeOptions = options.shape.options ||
                ShapeTypes.defaultOptions(types);

        var shapes = ShapeTypes._mapTypes(types, points,
                function(type, points, i) {
            var shapeOptions = _.extend({}, options, typeOptions[i]);
            return ShapeTypes._addType(graphie, type, points, shapeOptions);
        });

        var updateFuncs = _.filter(_.pluck(shapes, "update"), _.identity);
        var update = function() {
            _.invoke(updateFuncs, "call");
        };

        var removeFuncs = _.filter(_.pluck(shapes, "remove"), _.identity);
        var remove = function() {
            _.invoke(removeFuncs, "call");
        };

        var getOptions = function() {
            return _.map(shapes, function(shape) {
                if (shape.getOptions) {
                    return shape.getOptions();
                } else {
                    return {};
                }
            });
        };

        var toJSON = function() {
            var coords = _.map(points, function(pt) {
                if (_.isArray(pt)) {
                    return pt;
                } else {
                    return pt.coord;
                }
            });
            return {
                type: types,
                coords: coords,
                options: getOptions()
            };
        };

        return {
            type: types,
            points: points,
            update: update,
            remove: remove,
            toJSON: toJSON,
            getOptions: getOptions
        };
    },

    equal: function(shape1, shape2) {
        var types1 = ShapeTypes._typesOf(shape1);
        var types2 = ShapeTypes._typesOf(shape2);
        if (types1.length !== types2.length) {
            return false;
        }
        var shapes1 = ShapeTypes._mapTypes(types1, shape1.coords,
                ShapeTypes._combine);
        var shapes2 = ShapeTypes._mapTypes(types2, shape2.coords,
                ShapeTypes._combine);
        return _.all(_.map(shapes1, function(partialShape1, i) {
            var partialShape2 = shapes2[i];
            if (partialShape1.type !== partialShape2.type) {
                return false;
            }
            return ShapeTypes._forType(partialShape1.type).equal(
                partialShape1.coords,
                partialShape2.coords
            );
        }));
    },

    _typesOf: function(shape) {
        var types = shape.type;
        if (!_.isArray(types)) {
            types = [types];
        }
        return _.map(types, function(type) {
            if (type === "polygon") {
                return "polygon-3";
            } else {
                return type;
            }
        });
    },

    defaultOptions: function(types) {
        return _.map(types, function(type) {
            var typeDefaultOptions = ShapeTypes._forType(type).defaultOptions;
            return _.extend({}, typeDefaultOptions);
        });
    },

    _forType: function(type) {
        var baseType = type.split("-")[0];
        return ShapeTypes[baseType];
    },

    _mapTypes: function(types, points, func, context) {
        return _.map(types, function(type, i) {
            var pointCount = ShapeTypes.getPointCountForType(type);
            var currentPoints = _.first(points, pointCount);
            points = _.rest(points, pointCount);
            return func.call(context, type, currentPoints, i);
        });
    },

    _addType: function(graphie, type, points, options) {
        var lineCoords = _.isArray(points[0]) ? {
            coordA: points[0],
            coordZ: points[1],
        } : {
            pointA: points[0],
            pointZ: points[1],
        };

        type = type.split("-")[0];
        if (type === "polygon") {
            var polygon = graphie.addMovablePolygon(_.extend({}, options, {
                fixed: !options.editable,
                snapX: options.snap && options.snap[0] || 0,
                snapY: options.snap && options.snap[1] || 0,
                points: points,
                constrainToGraph: false
            }));
            return {
                update: _.bind(polygon.transform, polygon),
                remove: _.bind(polygon.remove, polygon)
            };
        } else if (type === "line" || type === "lineSegment") {
            var line = graphie.addMovableLineSegment(
                    _.extend({}, options, lineCoords, {
                movePointsWithLine: true,
                fixed: true,
                constraints: {
                    fixed: true
                },
                extendLine: (type === "line")
            }));

            // Hide points on uneditable lines
            // TODO(jack): This is disabled because translation currently
            // uses these points. re-enable this code when translation uses
            // a vector
//            if (type === "line" &&
//                    !_.isArray(points[0]) &&
//                    !options.editable) {
//                _.invoke(points, "remove");
//            }
            return {
                update: _.bind(line.transform, line, true),
                remove: _.bind(line.remove, line)
            };
        } else if (type === "angle") {
            // If this angle is editable, we want to be able to make angles
            // both larger and smaller than 180 degrees.
            // If this angle is not editable, it should always maintain
            // it's angle measure, even if it is reflected (causing the
            // clockwise-ness of the points to change)
            var shouldChangeReflexivity = options.editable ? null : false;

            var angle = graphie.addMovableAngle({
                angleLabel: "$deg0",
                fixed: true,
                points: points,
                normalStyle: options.normalStyle,
                reflex: options.reflex
            });

            // Hide non-vertex points on uneditable angles
            if (!_.isArray(points[0]) && !options.editable) {
                points[0].remove();
                points[2].remove();
            }
            return {
                update: _.bind(angle.update, angle, shouldChangeReflexivity),
                remove: _.bind(angle.remove, angle),
                getOptions: function() {
                    return {
                        reflex: angle.isReflex()
                    };
                }
            };
        } else if (type === "circle") {
            var perimeter = {
                // temporary object for the first removal
                remove: _.identity
            };
            var redrawPerim = function() {
                var coord0 = points[0].coord || points[0];
                var coord1 = points[1].coord || points[1];
                var radius = kpoint.distanceToPoint(coord0, coord1);
                perimeter.remove();
                perimeter = graphie.circle(coord0, radius, _.extend({
                    stroke: KhanUtil.BLUE,
                    "stroke-width": 2
                }, options.normalStyle));
            };

            redrawPerim();
            if (points[1].remove && !options.editable) {
                points[1].remove();
            }

            return {
                update: redrawPerim,
                remove: function() {
                    // Not _.bind because the remove function changes
                    // when the perimeter is redrawn
                    perimeter.remove();
                }
            };
        } else if (type === "point") {
            // do nothing
            return {
                update: null,
                remove: null
            };
        } else {
            throw new Error("Invalid shape type " + type);
        }
    },

    _combine: function(type, coords) {
        return {
            type: type,
            coords: coords
        };
    },

    polygon: {
        equal: orderInsensitiveCoordsEqual
    },

    line: {
        equal: kline.equal
    },

    lineSegment: {
        equal: orderInsensitiveCoordsEqual
    },

    angle: {
        equal: function(points1, points2) {
            if (!kpoint.equal(points1[1], points2[1])) {
                return false;
            }

            var line1_0 = [points1[1], points1[0]];
            var line1_2 = [points1[1], points1[2]];
            var line2_0 = [points2[1], points2[0]];
            var line2_2 = [points2[1], points2[2]];

            var equalUnflipped = kray.equal(line1_0, line2_0) &&
                    kray.equal(line1_2, line2_2);
            var equalFlipped = kray.equal(line1_0, line2_2) &&
                    kray.equal(line1_2, line2_0);

            return equalUnflipped || equalFlipped;
        },

        defaultOptions: {
            reflex: false
        }
    },

    circle: {
        equal: function(points1, points2) {
            var radius1 = kpoint.distanceToPoint(points1[0], points1[1]);
            var radius2 = kpoint.distanceToPoint(points2[0], points2[1]);
            return kpoint.equal(points1[0], points2[0]) &&
                knumber.equal(radius1, radius2);
        }
    },

    point: {
        equal: kpoint.equal
    }
};


var ToolSettings = React.createClass({displayName: 'ToolSettings',
    getDefaultProps: function() {
        return {
            allowFixed: true
        };
    },

    render: function() {
        return React.DOM.div(null, 
            this.props.name,": ",
            " ",
            PropCheckBox(
                {label:"enabled:",
                enabled:this.props.settings.enabled,
                onChange:this.props.onChange} ),
            " ",
            this.props.settings.enabled &&
                PropCheckBox(
                    {label:"required:",
                    required:this.props.settings.required,
                    onChange:this.props.onChange} ),
            
            this.props.settings.enabled &&
                InfoTip(null, 
                    " 'Required' will only grade the answer as correct if the "+
                    "student has used at least one such transformation. "
                ),
            
            " ",
            this.props.allowFixed && this.props.settings.enabled &&
                PropCheckBox(
                    {label:"fixed:",
                    fixed:this.props.settings.constraints.fixed,
                    onChange:this.changeConstraints} ),
            
            this.props.allowFixed && this.props.settings.enabled &&
                InfoTip(null, 
                    " Enable 'fixed' to prevent the student from repositioning "+
                    "the tool. The tool will appear in the position at which it "+
                    "is placed in the editor below. "
                )
            
        );
    },

    changeConstraints: function(changed) {
        var newConstraints = _.extend({}, this.props.constraints, changed);
        this.props.onChange({
            constraints: newConstraints
        });
    }
});


var TransformationExplorerSettings = React.createClass({displayName: 'TransformationExplorerSettings',
    render: function() {

        return React.DOM.div( {className:"transformer-settings"}, 
            React.DOM.div(null, 
                " Mode: ",
                React.DOM.select( {value:this.getMode(),
                        onChange:this.changeMode}, 
                    React.DOM.option( {value:"interactive,dynamic"}, 
                        " Exploration with text "
                    ),
                    React.DOM.option( {value:"interactive,static"}, 
                        " Exploration without text "
                    ),
                    React.DOM.option( {value:"dynamic,interactive"}, 
                        " Formal with movement "
                    ),
                    React.DOM.option( {value:"static,interactive"}, 
                        " Formal without movement "
                    )
                ),
                InfoTip(null, 
                    React.DOM.ul(null, 
                        React.DOM.li(null, 
                            React.DOM.b(null, "Exploration:"), " Students create "+
                            "transformations with tools on the graph. "
                        ),
                        React.DOM.li(null, 
                            React.DOM.b(null, "Formal with movement:"), " Students specify "+
                            "transformations mathematically in the "+
                            "transformation list. Graph shows the results of "+
                            "these transformations. "
                        ),
                        React.DOM.li(null, 
                            React.DOM.b(null, "Formal without movement:"), " Students specify "+
                            "transformations mathematically in the "+
                            "transformation list. Graph does not update. "
                        )
                    )
                )
            ),
            ToolSettings(
                    {name:"Translations",
                    settings:this.props.tools.translation,
                    allowFixed:false,
                    onChange:this.changeHandlerFor("translation")} ),
            ToolSettings(
                    {name:"Rotations",
                    settings:this.props.tools.rotation,
                    onChange:this.changeHandlerFor("rotation")} ),
            ToolSettings(
                    {name:"Reflections",
                    settings:this.props.tools.reflection,
                    onChange:this.changeHandlerFor("reflection")} ),
            ToolSettings(
                    {name:"Dilations",
                    settings:this.props.tools.dilation,
                    onChange:this.changeHandlerFor("dilation")} ),
            PropCheckBox(
                    {label:"Draw Solution:",
                    drawSolutionShape:this.props.drawSolutionShape,
                    onChange:this.props.onChange} )
        );
    },

    getMode: function() {
        return this.props.graphMode + "," + this.props.listMode;
    },

    changeMode: function(e) {
        var selected = e.target.value;
        var modes = selected.split(",");

        this.props.onChange({
            graphMode: modes[0],
            listMode: modes[1]
        });
    },

    changeHandlerFor: function(toolName) {
        return _.bind(function(change) {
            var newTools = _.clone(this.props.tools);
            newTools[toolName] = _.extend({}, this.props.tools[toolName],
                    change);

            this.props.onChange({
                tools: newTools
            });
        }, this);
    }
});


var TransformationsShapeEditor = React.createClass({displayName: 'TransformationsShapeEditor',
    render: function() {
        return React.DOM.div(null, 
            Graph(
                {ref:"graph",
                box:this.props.graph.box,
                range:this.props.graph.range,
                labels:this.props.graph.labels,
                step:this.props.graph.step,
                gridStep:this.props.graph.gridStep,
                markings:this.props.graph.markings,
                backgroundImage:this.props.graph.backgroundImage,
                onNewGraphie:this.setupGraphie} ),
            React.DOM.select(
                    {key:"type-select",
                    value:this.getTypeString(this.props.shape.type),
                    onChange:this.changeType} , 
                React.DOM.option( {value:"polygon-3"}, "Triangle"),
                React.DOM.option( {value:"polygon-4"}, "Quadrilateral"),
                React.DOM.option( {value:"polygon-5"}, "Pentagon"),
                React.DOM.option( {value:"polygon-6"}, "Hexagon"),
                React.DOM.option( {value:"line"}, "Line"),
                React.DOM.option( {value:"line,line"}, "2 lines"),
                React.DOM.option( {value:"lineSegment"}, "Line segment"),
                React.DOM.option( {value:"lineSegment,lineSegment"}, 
                    " 2 line segments "
                ),
                React.DOM.option( {value:"angle"}, "Angle"),
                React.DOM.option( {value:"circle"}, "Circle")
            )
        );
    },

    /* Return the option string for a given type */
    getTypeString: function(type) {
        if (_.isArray(type)) {
            return _.map(type, this.getTypeString).join(",");
        } else if (type === "polygon") {
            return "polygon-" + this.props.shape.coords.length;
        } else {
            return type;
        }
    },

    /* Change the type on the window event e
     *
     * e.target.value is the new type string
     */
    changeType: function(e) {
        var types = String(e.target.value).split(",");
        var pointCount = arraySum(_.map(
                types,
                ShapeTypes.getPointCountForType
        ));

        var radius = scaleToRange(4, this.refs.graph.props.range);
        var offset = (1 / 2 - 1 / pointCount) * 180;
        var coords = _.times(pointCount, function(i) {
            return KhanUtil.kpoint.rotateDeg([radius, 0],
                360 * i / pointCount + offset);
        });

        this.props.onChange({
            shape: {
                type: types,
                coords: coords,
                options: ShapeTypes.defaultOptions(types)
            }
        });
    },

    componentDidUpdate: function(prevProps) {
        if (!deepEq(prevProps.shape, this.props.shape)) {
            this.refs.graph.reset();
        }
    },

    updateCoords: function() {
        this.props.onChange({
            shape: this.shape.toJSON()
        });
    },

    setupGraphie: function(graphie) {
        this.shape = ShapeTypes.addMovableShape(graphie, {
            editable: true,
            snap: graphie.snap,
            shape: this.props.shape,
            onMoveEnd: this.updateCoords
        });
    },

});

var TransformationListItem = TransformOps.ListItem;

var TransformationList = React.createClass({displayName: 'TransformationList',
    render: function() {
        if (this.props.mode === "static") {
            return React.DOM.span(null );  // don't render anything
        }

        this.transformationList = _.map(
            this.props.transformations,
            function(transform, i) {
                return TransformationListItem(
                            {ref:"transformation" + i,
                            key:"transformation" + i,
                            transform:transform,
                            mode:this.props.mode,
                            onChange:this.handleChange} );
            },
            this
        );

        return React.DOM.div( {className:"perseus-transformation-list"}, 
            this.transformationList
        );
    },

    value: function() {
        return _.times(this.props.transformations.length, function(i) {
            return this.refs["transformation" + i].value();
        }, this);
    },

    handleChange: function() {
        this.props.onChange(this.value());
    },

    focusLast: function() {
        if (this.transformationList.length) {
            _.last(this.transformationList).focus();
        }
    }
});

var ToolButton = React.createClass({displayName: 'ToolButton',
    render: function() {
        var classes = this.props.toggled ?
            "simple-button exercise-orange toggled highlighted-tool-button" :
            "simple-button";

        return React.DOM.button(
                {type:"button",
                className:classes,
                onClick:this.props.onClick}, 
            this.props.children
        );
    }
});

var ToolsBar = React.createClass({displayName: 'ToolsBar',
    getInitialState: function() {
        return {
            selected: null
        };
    },

    render: function() {
        var tools = _.map(Transformations, function(tool, type) {
            if (this.props.enabled[type]) {
                return ToolButton(
                        {key:type,
                        toggled:this.state.selected === type,
                        onClick:_.bind(this.changeSelected, this, type)}, 
                    tool.verbName
                );
            }
        }, this);

        return React.DOM.div( {className:"transformer-tools-bar"}, 
            React.DOM.span( {className:"simple-button-group"}, 
                tools
            ),
            React.DOM.button(
                    {className:"transformer-undo-button simple-button",
                    type:"button",
                    onClick:this.props.onUndoClick}, 
                React.DOM.span( {className:"icon-undo"} ),
                " ",
                " Undo "
            ),
            React.DOM.div( {className:"clear"})
        );
    },

    changeSelected: function(tool) {
        this.props.removeTool(this.state.selected);

        if (!tool || tool === this.state.selected) {
            this.setState({
                selected: null
            });
        } else {
            this.props.addTool(tool);
            this.setState({
                selected: tool
            });
        }
    }
});

var AddTransformBar = React.createClass({displayName: 'AddTransformBar',
    render: function() {
        var tools = _.map(Transformations, function(tool, type) {
            if (this.props.enabled[type]) {
                return ToolButton(
                        {key:type,
                        toggled:false,
                        onClick:_.bind(this.changeSelected, this, type)}, 
                    React.DOM.span( {className:"icon-plus"} ),
                    " ",
                    tool.nounName
                );
            }
        }, this);

        return React.DOM.div( {className:"transformer-tools-bar"}, 
            tools,
            React.DOM.button(
                    {className:"transformer-undo-button simple-button",
                    type:"button",
                    onClick:this.props.onUndoClick}, 
                React.DOM.span( {className:"icon-undo"} ),
                " ",
                " Undo "
            ),
            React.DOM.div( {className:"clear"})
        );
    },

    changeSelected: function(tool) {
        if (tool) {
            this.props.addTool(tool);
        }
    }
});

var Transformer = React.createClass({displayName: 'Transformer',
    // TODO (jack): These should be refactored into a nice object at the top
    // so that we don't have all this duplication
    getDefaultProps: function() {
        return _.defaults({
            graph: {},
            transformations: []
        }, defaultTransformerProps);
    },

    render: function() {
        // Fill in any missing value in this.props.graph
        // this can happen because the graph json doesn't include
        // box, for example
        var graph = _.extend(
                defaultGraphProps(this.props.graph, defaultBoxSize),
                this.props.graph
        );

        var interactiveToolsMode = this.props.graphMode === "interactive";

        var ToolsBarClass = interactiveToolsMode ?
                ToolsBar :
                AddTransformBar;

        // This style is applied inline because it is dependent on the
        // size of the graph as set by the graph.box prop, and this also
        // lets us specify it in the same place the graph's width is
        // specified.
        var toolsBar = React.DOM.div( {style:{width: graph.box[0]}}, 
            ToolsBarClass(
                {ref:"toolsBar",
                enabled:pluckObject(this.props.tools, "enabled"),
                addTool:this.addTool,
                removeTool:this.removeTool,
                onUndoClick:this.handleUndoClick} )
        );

        return React.DOM.div( {className:"perseus-widget " +
                        "perseus-widget-transformer"}, 
            Graph(
                {ref:"graph",
                box:graph.box,
                range:graph.range,
                labels:graph.labels,
                step:graph.step,
                gridStep:graph.gridStep,
                markings:graph.markings,
                backgroundImage:graph.backgroundImage,
                showProtractor:graph.showProtractor,
                onNewGraphie:this.setupGraphie} ),

            !interactiveToolsMode && (
                "Add transformations below:"
            ),

            this.props.graphMode === "static" && [
                React.DOM.br( {key:"static-br"} ),
                React.DOM.em( {key:"static-nomove"}, 
                    " Note: For this question, the shape will not move. "
                )
            ],

            interactiveToolsMode && toolsBar,

            TransformationList(
                {ref:"transformationList",
                mode:this.props.listMode,
                transformations:this.props.transformations,
                onChange:this.setTransformationProps} ),

            !interactiveToolsMode && toolsBar

        );
    },

    componentDidUpdate: function(prevProps) {
        if (this.shouldSetupGraphie(this.props, prevProps)) {
            this.refs.graph.reset();
        } else if (!deepEq(this.props.transformations,
                this.transformations)) {
            this.setTransformations(this.props.transformations);
        }
    },

    shouldSetupGraphie: function(nextProps, prevProps) {
        if (!deepEq(prevProps.starting, nextProps.starting)) {
            return true;
        } else if (prevProps.graphMode !== nextProps.graphMode) {
            return true;
        } else if (prevProps.listMode !== nextProps.listMode) {
            return true;
        } else if (prevProps.drawSolutionShape !==
                nextProps.drawSolutionShape) {
            return true;
        } else if (nextProps.drawSolutionShape && !deepEq(
                prevProps.correct.shape, nextProps.correct.shape)) {
            return true;
        } else if (!deepEq(this.tools, nextProps.tools)) {
            return true;
        } else {
            return false;
        }
    },

    graphie: function() {
        return this.refs.graph.graphie();
    },

    setupGraphie: function() {
        var self = this;

        var graphie = this.graphie();

        // A background image of our solution:
        if (this.props.drawSolutionShape &&
                this.props.correct.shape &&
                this.props.correct.shape.coords) {
            ShapeTypes.addShape(graphie, {
                fixed: true,
                shape: self.props.correct.shape,
                normalStyle: {
                    stroke: KhanUtil.GRAY,
                    "stroke-dasharray": "",
                    "stroke-width": 2
                }
            });
        }

        this.currentTool = null;
        this.refs.toolsBar.changeSelected(null);
        this.addTransformerShape(this.props.starting.shape,
                /* translatable */ false);
        this.setTransformations(this.props.transformations);

        // Save a copy of our tools so that we can check future
        // this.props.tools changes against them
        // This seems weird, but gives us an easy way to tell whether
        // props changes were self-inflicted (for which a graphie reset
        // is not required, and is in fact a bad idea right now because
        // of resetting the size of the dilation tool).
        // TODO (jack): A deepClone method would be nice here
        this.tools = {
            translation: _.clone(this.props.tools.translation),
            rotation: _.clone(this.props.tools.rotation),
            reflection: _.clone(this.props.tools.reflection),
            dilation: _.clone(this.props.tools.dilation)
        };
    },

    /* Applies all transformations in `transformations`
     * to the starting shape, and updates this.transformations
     * to reflect this
     *
     * Usually called with this.props.transformations
     */
    setTransformations: function(transformations) {
        this.resetCoords();
        this.transformations = _.clone(transformations);
        _.each(this.transformations, this.applyTransform);
    },

    // the polygon that we transform
    addTransformerShape: function(shape, translatable) {
        var self = this;
        var graphie = this.graphie();

        this.shape = ShapeTypes.addMovableShape(graphie, {
            shape: shape,
            editable: false,
            showPoints: (this.props.graphMode !== "static"),
            translatable: translatable,
            onMove: function (dX, dY) {
                dX = KhanUtil.roundToNearest(graphie.snap[0], dX);
                dY = KhanUtil.roundToNearest(graphie.snap[1], dY);
                self.addTransform({
                    type: "translation",
                    vector: [dX, dY]
                });
                return [dX, dY];
            },
            pointStyle: {
                fill: (translatable ? KhanUtil.ORANGE : KhanUtil.BLUE),
                stroke: (translatable ? KhanUtil.ORANGE : KhanUtil.BLUE)
            }
        });
    },

    addTool: function(toolId) {
        var self = this;

        if (this.props.graphMode === "interactive") {
            if (toolId === "translation") {
                this.currentTool = this.addTranslationTool();
            } else if (toolId === "rotation") {
                this.currentTool = this.addRotationTool();
            } else if (toolId === "reflection") {
                this.currentTool = this.addReflectionTool();
            } else if (toolId === "dilation") {
                this.currentTool = this.addDilationTool();
            } else {
                throw new Error("Invalid tool id: " + toolId);
            }
        } else {
            var transform;
            if (toolId === "translation") {
                transform = {
                    type: toolId,
                    vector: [null, null]
                };
            } else if (toolId === "rotation") {
                transform = {
                    type: toolId,
                    center: [null, null],
                    angleDeg: null
                };
            } else if (toolId === "reflection") {
                // Reflections with nulls in them won't be applied until
                // fills in the blanks
                transform = {
                    type: toolId,
                    line: [[null, null], [null, null]]
                };
            } else if (toolId === "dilation") {
                transform = {
                    type: toolId,
                    center: [null, null],
                    scale: null
                };
            } else {
                throw new Error("Invalid tool id: " + toolId);
            }

            this.doTransform(transform, function() {
                self.refs.transformationList.focusLast();
            });
        }
    },

    removeTool: function(toolId) {
        if (this.currentTool) {
            this.currentTool.remove();
        }
        this.currentTool = null;
    },

    addTranslationTool: function() {
        var self = this;
        this.shape.remove();
        this.addTransformerShape(this.shape.toJSON(),
                /* translatable */ true);

        return {
            remove: function() {
                self.shape.remove();
                self.addTransformerShape(self.shape.toJSON(),
                        /* translatable */ false);
            }
        };
    },

    // Snaps a coord to this.graphie()'s snap
    snapCoord: function(coord) {
        var graphie = this.graphie();
        return _.map(coord, function (val, dim) {
            return KhanUtil.roundToNearest(graphie.snap[dim], val);
        });
    },

    // Normalize the coords into something that fits the new 45 degree
    // reflection line.
    normalizeReflectionCoords: function(messyCoords) {
        var midpoint = this.snapCoord(kline.midpoint(messyCoords));
        var origDirectionPolar = kvector.polarDegFromCart(
            kvector.subtract(messyCoords[0], messyCoords[1])
        );
        var directionPolar = [
            1,
            KhanUtil.roundToNearest(45, origDirectionPolar[1])
        ];
        var direction = kvector.cartFromPolarDeg(directionPolar);
        var coords = _.map([-1, 1], function(directionCoefficient) {
            var coord = kvector.add(
                midpoint,
                kvector.scale(
                    direction,
                    directionCoefficient *
                        this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST)
                )
            );
            return this.snapCoord(coord);
        }, this);
        return coords;
    },

    addReflectionTool: function() {
        var options = this.props.tools.reflection;
        if (!options.enabled) {
            return;
        }
        var self = this;
        var graphie = this.refs.graph.graphie();

        var updateReflectionTool = function() {
            self.changeTool("reflection", {
                coords: _.pluck(reflectPoints, "coord")
            });
        };

        var coords = this.normalizeReflectionCoords(options.coords);

        // The points defining the line of reflection; hidden from the
        // user.
        var reflectPoints = _.map(coords, function(coord) {
            return graphie.addMovablePoint({
                coord: coord,
                visible: false
            });
        }, this);

        // the line of reflection
        // TODO(jack): graphie.style here is a hack to prevent the dashed
        // style from leaking into the rest of the shapes. Remove when
        // graphie.addMovableLineSegment doesn't leak styles anymore.
        var reflectLine;
        graphie.style({}, function() {
            reflectLine = graphie.addMovableLineSegment({
                fixed: options.constraints.fixed,
                constraints: options.constraints,
                pointA: reflectPoints[0],
                pointZ: reflectPoints[1],
                snapX: graphie.snap[0],
                snapY: graphie.snap[1],
                extendLine: true,
                normalStyle: {
                    "stroke": (options.constraints.fixed ?
                            KhanUtil.GRAY :
                            KhanUtil.ORANGE
                    ),
                    "stroke-width": 2,
                    "stroke-dasharray": "- "
                },
                highlightStyle: {
                    "stroke": KhanUtil.ORANGE,
                    "stroke-width": 2,
                    "stroke-dasharray": "- " // TODO(jack) solid doesn't
                                             // work here, but would be
                                             // nicer
                },
                movePointsWithLine: true,
                onMoveEnd: updateReflectionTool
            });
        });

        // the "button" point in the center of the line of reflection
        var reflectButton = graphie.addReflectButton({
            fixed: options.constraints.fixed,
            line: reflectLine,
            size: this.scaleToCurrentRange(REFLECT_BUTTON_SIZE),
            onClick: function() {
                self.doTransform({
                    type: "reflection",
                    line: _.pluck(reflectPoints, "coord")
                });
                if (reflectRotateHandle) {
                    // flip the rotation handle
                    reflectRotateHandle.setCoord(kvector.add(
                        reflectButton.coord,
                        kvector.subtract(
                            reflectButton.coord,
                            reflectRotateHandle.coord
                        )
                    ));
                    reflectRotateHandle.update();
                }
            },
            normalStyle: {
                stroke: KhanUtil.ORANGE,
                "stroke-width": 2,
                fill: KhanUtil.ORANGE
            },
            highlightStyle: {
                stroke: KhanUtil.ORANGE,
                "stroke-width": 3,
                fill: KhanUtil.ORANGE
            },
            onMoveEnd: updateReflectionTool
        });

        var reflectRotateHandle = null;
        if (!options.constraints.fixed) {
            // The rotation handle for rotating the line of reflection
            var initRotateHandleAngle = kvector.polarDegFromCart(
                kvector.subtract(
                    reflectPoints[1].coord,
                    reflectPoints[0].coord
                )
            )[1] + 90; // 90 degrees off of the line
            reflectRotateHandle = graphie.addRotateHandle({
                center: reflectButton,
                radius: this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST),
                angleDeg: initRotateHandleAngle,
                width: this.scaleToCurrentRange(0.24),
                hoverWidth: this.scaleToCurrentRange(0.4),
                lengthAngle: 17,
                onMove: function(newAngle) {
                    return KhanUtil.roundToNearest(45, newAngle);
                },
                onMoveEnd: updateReflectionTool
            });
        }

        // Move the reflectButton and reflectRotateHandle with the line
        $(reflectLine).on("move",
                function() {
            reflectButton.update();
            $(reflectButton).trigger("move"); // update the rotation handle,
                    // which watches for this in ke/utils/interactive.js.
        });

        // Update the line and reflect button when the reflectRotateHandle is
        // rotated
        if (reflectRotateHandle) {
            $(reflectRotateHandle).on("move", function() {
                var rotateHandleApprox = self.snapCoord(
                    reflectRotateHandle.coord
                );

                var rotateVector = kvector.subtract(
                    rotateHandleApprox,
                    reflectButton.coord
                );

                var flipped = reflectButton.isFlipped() ? 1 : 0;
                reflectPoints[flipped].setCoord(kvector.add(
                    reflectButton.coord,
                    kvector.rotateDeg(rotateVector, 90)
                ));
                reflectPoints[1 - flipped].setCoord(kvector.add(
                    reflectButton.coord,
                    kvector.rotateDeg(rotateVector, -90)
                ));

                reflectLine.transform(true);
                reflectButton.update();
            });
        }

        return {
            remove: function() {
                reflectButton.remove();
                if (reflectRotateHandle) {
                    reflectRotateHandle.remove();
                }
                reflectLine.remove();
                reflectPoints[0].remove();
                reflectPoints[1].remove();
            }
        };
    },

    /* Scales a distance from the default range of
     * [-10, 10] to the current this.props.graph.range
     *
     * Used for sizing various transformation tools
     * (rotation handle, dilation circle)
     */
    scaleToCurrentRange: function(dist) {
        return scaleToRange(dist, this.refs.graph.props.range);
    },

    addRotationTool: function() {
        var options = this.props.tools.rotation;
        if (!options.enabled) {
            return;
        }
        var self = this;
        var graphie = this.refs.graph.graphie();

        var pointColor = colorForTool(options);
        // The center of our rotation, which can be moved to change the
        // center of rotation
        this.rotatePoint = graphie.addMovablePoint({
            constraints: options.constraints,
            coord: options.coord,
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            normalStyle: {               // ugh, this seems to be a global and
                "stroke-dasharray": "",  // is set to dash above
                stroke: pointColor,
                fill: pointColor
            },
            highlightStyle: {
                "stroke-dasharray": "",
                stroke: pointColor,
                fill: pointColor
            }
        });

        // The point that we move around the center of rotation to actually
        // cause rotations
        this.rotateHandle = graphie.addRotateHandle({
            center: this.rotatePoint,
            radius: this.scaleToCurrentRange(ROTATE_HANDLE_DIST),
            width: this.scaleToCurrentRange(0.24),
            hoverWidth: this.scaleToCurrentRange(0.4),
            onMove: function(newAngle, oldAngle) {
                var transform = self.getRotationTransformFromAngle(
                    self.rotatePoint.coord,
                    newAngle - oldAngle
                );

                // Rotate polygon with rotateHandle
                self.doTransform(transform);

                return oldAngle + transform.angleDeg;
            }
        });

        // Update tools.rotation.coord
        this.rotatePoint.onMoveEnd = function(x, y) {
            self.changeTool("rotation", {
                coord: [x, y]
            });
        };


        return {
            remove: function() {
                self.rotateHandle.remove();
                self.rotatePoint.remove();
            }
        };
    },

    addDilationTool: function() {
        var options = this.props.tools.dilation;
        if (!options.enabled) {
            return;
        }
        var self = this;
        var graphie = this.refs.graph.graphie();

        var pointColor = colorForTool(options);
        // the circle for causing dilation transforms
        self.dilationCircle = graphie.addCircleGraph({
            centerConstraints: options.constraints,
            center: options.coord,
            radius: self.scaleToCurrentRange(2),
            snapX: graphie.snap[0],
            snapY: graphie.snap[1],
            minRadius: self.scaleToCurrentRange(1),
            snapRadius: self.scaleToCurrentRange(0.5),
            onResize: function(newRadius, oldRadius) {
                self.doTransform({
                    type: "dilation",
                    center: self.dilationCircle.centerPoint.coord,
                    scale: newRadius/oldRadius
                });
            },
            circleNormalStyle: {
                "stroke": KhanUtil.ORANGE,
                "stroke-width": 2,
                "stroke-dasharray": "- ",
                "fill-opacity": 0
            },
            circleHighlightStyle: {
                "stroke": KhanUtil.ORANGE,
                "stroke-width": 2,
                "stroke-dasharray": "",
                "fill": KhanUtil.ORANGE,
                "fill-opacity": 0.05
            },
            centerNormalStyle: {
                "stroke": pointColor,
                "fill": pointColor,
                "stroke-width": 2,
                "stroke-dasharray": ""
            },
            centerHighlightStyle: {
                "stroke": pointColor,
                "fill": pointColor,
                "stroke-width": 2,
                "stroke-dasharray": ""
            }
        });

        var origOnMoveEnd = this.dilationCircle.centerPoint.onMoveEnd;
        this.dilationCircle.centerPoint.onMoveEnd = function() {
            if (origOnMoveEnd) {
                origOnMoveEnd.apply(this, _.toArray(arguments));
            }
            self.changeTool("dilation", {
                coord: self.dilationCircle.centerPoint.coord
            });
        };

        return {
            remove: function() {
                self.dilationCircle.remove();
            }
        };
    },

    // returns a transformation object representing a rotation
    // rounds the angle to the nearest 15 degrees
    getRotationTransformFromAngle: function(center, angleChanged) {
        angleChanged = (angleChanged + 360) % 360;
        if (angleChanged > 180) {
            angleChanged -= 360;
        }
        var roundedAngle = Math.round(
                angleChanged / ROTATE_SNAP_DEGREES
            ) * ROTATE_SNAP_DEGREES;

        return {
            type: "rotation",
            center: center,
            angleDeg: roundedAngle
        };
    },

    // apply and save a transform
    doTransform: function(transform, callback) {
        this.applyTransform(transform);
        this.addTransform(transform, callback);
    },

    // apply a transform to our polygon (without modifying our transformation
    // list)
    applyTransform: function(transform) {
        if (this.props.graphMode !== "static") {
            var transformFunc = TransformOps.apply(transform);
            this.applyCoordTransformation(transformFunc);
        }
    },

    // transform our polygon by transforming each point using a given function
    applyCoordTransformation: function(pointTransform) {
        _.each(this.shape.points, function(point) {
            var newCoord = pointTransform(point.coord);
            point.setCoord(newCoord);
        });
        this.shape.update();
    },

    resetCoords: function() {
        var startCoords = this.props.starting.shape.coords;
        _.each(this.shape.points, function(point, i) {
            point.setCoord(startCoords[i]);
        });
        this.shape.update();
    },

    // Remove the last transfromation
    handleUndoClick: function() {
        this.refs.toolsBar.changeSelected(null);
        if (this.props.transformations.length) {
            this.props.onChange({
                transformations: _.initial(this.props.transformations)
            });
        }
    },

    setTransformationProps: function(newTransfomationList) {
        this.props.onChange({
            transformations: newTransfomationList
        });
    },

    // add a transformation to our props list of transformation
    addTransform: function(transform, callback) {
        this.transformations = TransformOps.append(
                this.transformations,
                transform
        );
        this.props.onChange({
            transformations: _.clone(this.transformations)
        }, callback);
    },

    changeTool: function(tool, changes) {
        var newTools = _.clone(this.props.tools);
        newTools[tool] = _.extend({}, this.props.tools[tool], changes);
        this.tools[tool] = _.clone(newTools[tool]);
        this.props.onChange({
            tools: newTools,
        });
    },

    simpleValidate: function(rubric) {
        return Transformer.validate(this.toJSON(), rubric);
    },

    /**
     * Calculate where the coordinates would be if they were
     * moved, even if we're in formal mode with no movement
     * (and thus the actual movablepoints may not have moved
     */
    getCoords: function() {
        var startCoords = this.props.starting.shape.coords;
        var transforms = this.props.transformations;
        return _.reduce(transforms, function (coords, transform) {
            return _.map(coords, TransformOps.apply(transform));
        }, startCoords);
    },

    toJSON: function() {
        var json = _.pick(this.props, "grading", "starting", "graphMode",
                "listMode", "tools", "drawSolutionShape", "gradeEmpty");
        json.graph = this.refs.graph.toJSON();
        json.answer = {
            transformations: this.props.transformations,
            // This doesn't call this.shape.toJSON() because that doesn't
            // handle coordinates in formal mode without movement, since
            // the movablepoints never move
            shape: {
                type: this.shape.type,
                coords: this.getCoords(),
                options: this.shape.getOptions()
            }
        };
        json.version = 1.2; // Give us some safety to change the format
                            // when we realize that I wrote
                            // a horrible json spec for this widget
        return json;
    }
});

_.extend(Transformer, {
    validate: function (guess, rubric) {
        // Check for any required transformations
        for (var type in Transformations) {
            if (rubric.tools[type].required) {
                var isUsed = _.any(_.map(guess.answer.transformations,
                        function(transform) {
                    // Required transformations must appear in the
                    // transformation list, and must not be no-ops
                    return (transform.type === type) &&
                        !TransformOps.isEmpty(transform) &&
                        !TransformOps.isNoOp(transform);
                }));

                if (!isUsed) {
                    return {
                        type: "invalid",
                        message: "Your transformation must use a " + type + "."
                    };
                }
            }
        }

        // Compare shapes
        if (ShapeTypes.equal(guess.answer.shape,
                rubric.correct.shape)) {
            return {
                type: "points",
                earned: 1,
                total: 1,
                message: null
            };
        } else if (!rubric.gradeEmpty && deepEq(
                    guess.answer.shape.coords,
                    rubric.starting.shape.coords
                )) {
            return {
                type: "invalid",
                message: "Use the interactive graph to define a correct " +
                    "transformation."
            };
        } else {
            return {
                type: "points",
                earned: 0,
                total: 1,
                message: null
            };
        }
    }
});

var TransformerEditor = React.createClass({displayName: 'TransformerEditor',
    // TODO (jack): These should be refactored into a nice object at the top
    // so that we don't have all this duplication
    getDefaultProps: function() {
        return _.defaults({
            graph: defaultGraphProps(this.props.graph, 340)
        }, defaultTransformerProps);
    },

    render: function() {
        // Fill in any missing value in this.props.graph
        // this can happen because the graph json doesn't include
        // box, for example
        var graph = _.extend(
                defaultGraphProps(this.props.graph, 340),
                this.props.graph
        );

        return React.DOM.div(null, 
            React.DOM.div(null, 
                PropCheckBox(
                    {label:"Grade empty answers as wrong:",
                    gradeEmpty:this.props.gradeEmpty,
                    onChange:this.props.onChange} ),
                InfoTip(null, 
                    React.DOM.p(null, 
                        " We generally don't grade empty answers. This usually "+
                        "works well, but sometimes can result in giving away "+
                        "part of an answer in a multi-part question. "
                    ),
                    React.DOM.p(null, 
                        " If this is a multi-part question (there is another "+
                        "widget), you probably want to enable this option. "+
                        "Otherwise, you should leave it disabled. "
                    ),
                    React.DOM.p(null, 
                        " Confused? Talk to Elizabeth. "
                    )
                )
            ),
            React.DOM.div(null, "Graph settings:"),
            GraphSettings(
                {box:graph.box,
                labels:graph.labels,
                range:graph.range,
                step:graph.step,
                gridStep:graph.gridStep,
                valid:graph.valid,
                backgroundImage:graph.backgroundImage,
                markings:graph.markings,
                showProtractor:graph.showProtractor,
                onChange:this.changeGraph} ),
            React.DOM.div(null, "Transformation settings:"),
            TransformationExplorerSettings(
                {ref:"transformationSettings",
                graphMode:this.props.graphMode,
                listMode:this.props.listMode,
                tools:this.props.tools,
                drawSolutionShape:this.props.drawSolutionShape,
                onChange:this.props.onChange} ),
            React.DOM.div(null, "Starting location:"),
            TransformationsShapeEditor(
                {ref:"shapeEditor",
                graph:graph,
                shape:this.props.starting.shape,
                onChange:this.changeStarting} ),
            React.DOM.div(null, "Solution transformations:"),
            Transformer(
                {ref:"explorer",
                graph:graph,
                graphMode:this.props.graphMode,
                listMode:this.props.listMode,
                gradeEmpty:this.props.gradeEmpty,
                tools:this.props.tools,
                drawSolutionShape:this.props.drawSolutionShape,
                starting:this.props.starting,
                correct:this.props.starting,
                transformations:this.props.correct.transformations,
                onChange:this.changeTransformer} )
        );
    },

    // propagate a props change on our graph settings to
    // this.props.graph
    changeGraph: function(graphChanges, callback) {
        var newGraph = _.extend({}, this.props.graph, graphChanges);
        this.props.onChange({
            graph: newGraph
        }, callback);
    },

    // propagate a props change on our starting graph to
    // this.props.starting
    changeStarting: function(startingChanges) {
        var newStarting = _.extend({}, this.props.starting, startingChanges);
        this.props.onChange({
            starting: newStarting
        });
    },

    // propagate a transformations change onto correct.transformations
    changeTransformer: function(changes, callback) {
        if (changes.transformations) {
            changes.correct = {
                transformations: changes.transformations
            };
            delete changes.transformations;
        }
        this.props.onChange(changes, callback);
    },

    toJSON: function() {
        var json = this.refs.explorer.toJSON();
        json.correct = json.answer;
        delete json.answer;
        return json;
    }
});


Widgets.register("transformer", Transformer);
Widgets.register("transformer-editor", TransformerEditor);

})(Perseus);

},{"../components/graph-settings.jsx":4,"../components/graph.jsx":5,"../components/info-tip.jsx":6,"../components/number-input.jsx":7,"../components/prop-check-box.jsx":8,"../core.js":11,"../tex.jsx":18,"../util.js":19,"../widgets.js":20}]},{},[12])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvYWxsLXdpZGdldHMuanMiLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvYW5zd2VyLWFyZWEtZWRpdG9yLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy9jb21wb25lbnRzL2JsdXItaW5wdXQuanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL2NvbXBvbmVudHMvZ3JhcGgtc2V0dGluZ3MuanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL2NvbXBvbmVudHMvZ3JhcGguanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL2NvbXBvbmVudHMvaW5mby10aXAuanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL2NvbXBvbmVudHMvbnVtYmVyLWlucHV0LmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy9jb21wb25lbnRzL3Byb3AtY2hlY2stYm94LmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy9jb21wb25lbnRzL3NvcnRhYmxlLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy9jb21wb25lbnRzL3RleHQtbGlzdC1lZGl0b3IuanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL2NvcmUuanMiLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvZWRpdG9yLXBhZ2UuanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL2VkaXRvci5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvaGludC1lZGl0b3IuanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL2l0ZW0tZWRpdG9yLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy9pdGVtLXJlbmRlcmVyLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy9yZW5kZXJlci5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvdGV4LmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy91dGlsLmpzIiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL3dpZGdldHMuanMiLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy9jYXRlZ29yaXphdGlvbi5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy9kcm9wZG93bi5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy9leHByZXNzaW9uLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy93aWRnZXRzL2lucHV0LW51bWJlci5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy9pbnRlcmFjdGl2ZS1ncmFwaC5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy9pbnRlcmFjdGl2ZS1udW1iZXItbGluZS5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy9tYXRjaGVyLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy93aWRnZXRzL29yZGVyZXIuanN4IiwiL1VzZXJzL2Rldi9raGFuL3BlcnNldXMvc3JjL3dpZGdldHMvcGxvdHRlci5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy9wcm90cmFjdG9yLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy93aWRnZXRzL3JhZGlvLmpzeCIsIi9Vc2Vycy9kZXYva2hhbi9wZXJzZXVzL3NyYy93aWRnZXRzL3NvcnRlci5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy90YWJsZS5qc3giLCIvVXNlcnMvZGV2L2toYW4vcGVyc2V1cy9zcmMvd2lkZ2V0cy90cmFuc2Zvcm1lci5qc3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNytEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oUGVyc2V1cykge1xuXG5yZXF1aXJlKFwiLi93aWRnZXRzL2NhdGVnb3JpemF0aW9uLmpzeFwiKTtcbnJlcXVpcmUoXCIuL3dpZGdldHMvZHJvcGRvd24uanN4XCIpO1xucmVxdWlyZShcIi4vd2lkZ2V0cy9leHByZXNzaW9uLmpzeFwiKTtcbnJlcXVpcmUoXCIuL3dpZGdldHMvaW5wdXQtbnVtYmVyLmpzeFwiKTtcbnJlcXVpcmUoXCIuL3dpZGdldHMvaW50ZXJhY3RpdmUtZ3JhcGguanN4XCIpO1xucmVxdWlyZShcIi4vd2lkZ2V0cy9pbnRlcmFjdGl2ZS1udW1iZXItbGluZS5qc3hcIik7XG5yZXF1aXJlKFwiLi93aWRnZXRzL21hdGNoZXIuanN4XCIpO1xucmVxdWlyZShcIi4vd2lkZ2V0cy9vcmRlcmVyLmpzeFwiKTtcbnJlcXVpcmUoXCIuL3dpZGdldHMvcGxvdHRlci5qc3hcIik7XG5yZXF1aXJlKFwiLi93aWRnZXRzL3Byb3RyYWN0b3IuanN4XCIpO1xucmVxdWlyZShcIi4vd2lkZ2V0cy9yYWRpby5qc3hcIik7XG5yZXF1aXJlKFwiLi93aWRnZXRzL3NvcnRlci5qc3hcIik7XG5yZXF1aXJlKFwiLi93aWRnZXRzL3RhYmxlLmpzeFwiKTtcbnJlcXVpcmUoXCIuL3dpZGdldHMvdHJhbnNmb3JtZXIuanN4XCIpO1xuXG59KShQZXJzZXVzKTtcblxuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG4oZnVuY3Rpb24oUGVyc2V1cykge1xuXG5yZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xucmVxdWlyZShcIi4vcmVuZGVyZXIuanN4XCIpO1xucmVxdWlyZShcIi4vZWRpdG9yLmpzeFwiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcblxudmFyIEluZm9UaXAgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2luZm8tdGlwLmpzeFwiKTtcbnZhciBXaWRnZXRzID0gcmVxdWlyZShcIi4vd2lkZ2V0cy5qc1wiKTtcbnZhciBSZW5kZXJlciA9IFBlcnNldXMuUmVuZGVyZXI7XG52YXIgRWRpdG9yID0gUGVyc2V1cy5FZGl0b3I7XG5cbnZhciBBbnN3ZXJBcmVhUmVuZGVyZXIgPSBQZXJzZXVzLkFuc3dlckFyZWFSZW5kZXJlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPKGFscGVydCk6IE1vdmUgdXAgdG8gcGFyZW50IHByb3BzP1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkZ2V0OiB7fSxcbiAgICAgICAgICAgIGNsczogdGhpcy5nZXRDbGFzcyh0aGlzLnByb3BzLnR5cGUpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtjbHM6IHRoaXMuZ2V0Q2xhc3MobmV4dFByb3BzLnR5cGUpfSk7XG4gICAgfSxcblxuICAgIGdldENsYXNzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIm11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBSZW5kZXJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBXaWRnZXRzLmdldCh0eXBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKHJvb3ROb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNscyhfLmV4dGVuZCh7XG4gICAgICAgICAgICByZWY6IFwid2lkZ2V0XCIsXG4gICAgICAgICAgICBwcm9ibGVtTnVtOiB0aGlzLnByb3BzLnByb2JsZW1OdW0sXG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24obmV3UHJvcHMsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZGdldCA9IF8uZXh0ZW5kKHt9LCB0aGlzLnN0YXRlLndpZGdldCwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3dpZGdldDogd2lkZ2V0fSwgY2IpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgIH0sIHRoaXMucHJvcHMub3B0aW9ucywgdGhpcy5zdGF0ZS53aWRnZXQpKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRleGFtcGxlcyA9ICQoXCI8ZGl2IGlkPSdleGFtcGxlcyc+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAkKFwiI2NhbGN1bGF0b3JcIikudG9nZ2xlKHRoaXMucHJvcHMuY2FsY3VsYXRvcik7XG5cbiAgICAgICAgJChcIiNleGFtcGxlcy1zaG93XCIpLmhpZGUoKTtcbiAgICAgICAgaWYgKCQoXCIjZXhhbXBsZXMtc2hvd1wiKS5kYXRhKFwicXRpcFwiKSkge1xuICAgICAgICAgICAgJChcIiNleGFtcGxlcy1zaG93XCIpLnF0aXAoXCJkZXN0cm95XCIsIC8qIGltbWVkaWF0ZSAqLyB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLnJlZnMud2lkZ2V0O1xuICAgICAgICB2YXIgZXhhbXBsZXMgPSB3aWRnZXQuZXhhbXBsZXMgPyB3aWRnZXQuZXhhbXBsZXMoKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKGV4YW1wbGVzICYmICQoXCIjZXhhbXBsZXMtc2hvd1wiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICQoXCIjZXhhbXBsZXMtc2hvd1wiKS5hcHBlbmQodGhpcy4kZXhhbXBsZXMpO1xuXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IF8ubWFwKGV4YW1wbGVzLCBmdW5jdGlvbihleGFtcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiLSBcIiArIGV4YW1wbGU7XG4gICAgICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuXG4gICAgICAgICAgICBSZWFjdC5yZW5kZXJDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgUmVuZGVyZXIoe2NvbnRlbnQ6IGNvbnRlbnR9KSxcbiAgICAgICAgICAgICAgICB0aGlzLiRleGFtcGxlc1swXSk7XG5cbiAgICAgICAgICAgICQoXCIjZXhhbXBsZXMtc2hvd1wiKS5xdGlwKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuJGV4YW1wbGVzLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZToge2NsYXNzZXM6IFwicXRpcC1saWdodCBsZWFmLXRvb2x0aXBcIn0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgbXk6IFwiY2VudGVyIHJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgIGF0OiBcImNlbnRlciBsZWZ0XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNob3c6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGlkZToge2RlbGF5OiAwfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQoXCIjZXhhbXBsZXMtc2hvd1wiKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICAkKFwiI2NhbGN1bGF0b3JcIikuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNscy5leGFtcGxlcyAmJiAkKFwiI2V4YW1wbGVzLXNob3dcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAkKFwiI2V4YW1wbGVzLXNob3dcIikuaGlkZSgpO1xuICAgICAgICAgICAgUmVhY3QudW5tb3VudENvbXBvbmVudEF0Tm9kZShcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJleGFtcGxlc1wiKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnMud2lkZ2V0LmZvY3VzKCk7XG4gICAgfSxcblxuICAgIGd1ZXNzQW5kU2NvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPKGFscGVydCk6IFRoZXNlIHNob3VsZCBwcm9iYWJseSBoYXZlIHRoZSBzYW1lIHNpZ25hdHVyZS4uLlxuICAgICAgICBpZiAodGhpcy5wcm9wcy50eXBlID09PSBcIm11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnMud2lkZ2V0Lmd1ZXNzQW5kU2NvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBndWVzcyA9IHRoaXMucmVmcy53aWRnZXQudG9KU09OKCk7XG5cbiAgICAgICAgICAgIHZhciBzY29yZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmdyYWRlZCA9PSBudWxsIHx8IHRoaXMucHJvcHMuZ3JhZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJvcHMuZ3JhZGVkIGlzIHVuc2V0IG9yIHRydWVcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFscGVydCk6IFNlcGFyYXRlIG91dCB0aGUgcnVicmljXG4gICAgICAgICAgICAgICAgc2NvcmUgPSB0aGlzLnJlZnMud2lkZ2V0LnNpbXBsZVZhbGlkYXRlKHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3JlID0gVXRpbC5ub1Njb3JlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2d1ZXNzLCBzY29yZV07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIEFuc3dlckFyZWFFZGl0b3IgPSBQZXJzZXVzLkFuc3dlckFyZWFFZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW5wdXQtbnVtYmVyXCIsXG4gICAgICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGNhbGN1bGF0b3I6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjbHM7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnR5cGUgPT09IFwibXVsdGlwbGVcIikge1xuICAgICAgICAgICAgY2xzID0gRWRpdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xzID0gV2lkZ2V0cy5nZXQodGhpcy5wcm9wcy50eXBlICsgXCItZWRpdG9yXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IGNscyhfLmV4dGVuZCh7XG4gICAgICAgICAgICByZWY6IFwiZWRpdG9yXCIsXG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24obmV3UHJvcHMsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy5vcHRpb25zLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7b3B0aW9uczogb3B0aW9uc30sIGNiKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICB9LCB0aGlzLnByb3BzLm9wdGlvbnMpKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtYW5zd2VyLWVkaXRvclwifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwicGVyc2V1cy1hbnN3ZXItb3B0aW9uc1wifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICBcIiBTaG93IGNhbGN1bGF0b3I6IFwiLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJjaGVja2JveFwiLCBjaGVja2VkOnRoaXMucHJvcHMuY2FsY3VsYXRvcixcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6ZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Y2FsY3VsYXRvcjogZS50YXJnZXQuY2hlY2tlZH0pO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyl9IClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiVXNlIHRoZSBjYWxjdWxhdG9yIHdoZW4gY29tcGxldGluZyBkaWZmaWN1bHQgY2FsY3VsYXRpb25zIGlzIFwiK1xuICAgICAgICAgICAgICAgIFwiTk9UIHRoZSBpbnRlbnQgb2YgdGhlIHF1ZXN0aW9uLiBET07igJlUIHVzZSB0aGUgY2FsY3VsYXRvciB3aGVuIFwiK1xuICAgICAgICAgICAgICAgIFwidGVzdGluZyB0aGUgc3R1ZGVudOKAmXMgYWJpbGl0eSB0byBjb21wbGV0ZSBkaWZmZXJlbnQgdHlwZXMgb2YgXCIrXG4gICAgICAgICAgICAgICAgXCJjb21wdXRhdGlvbnMuXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgQW5zd2VyIHR5cGU6IFwiLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoIHt2YWx1ZTp0aGlzLnByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnMuZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKX0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJyYWRpb1wifSwgXCJNdWx0aXBsZSBjaG9pY2VcIiksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcInRhYmxlXCJ9LCBcIlRhYmxlIG9mIHZhbHVlc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiaW5wdXQtbnVtYmVyXCJ9LCBcIlRleHQgaW5wdXQgKG51bWJlcilcIiksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImV4cHJlc3Npb25cIn0sIFwiRXhwcmVzc2lvbiAvIEVxdWF0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJtdWx0aXBsZVwifSwgXCJDdXN0b20gZm9ybWF0XCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJVc2UgdGhlIGN1c3RvbSBmb3JtYXQgaWYgdGhlIHF1ZXN0aW9uIGlzIGluIHRoZSBxdWVzdGlvbiBcIitcbiAgICAgICAgICAgICAgICBcImFyZWEsIGFuZCB0ZWxsIHRoZSBzdHVkZW50cyBob3cgdG8gY29tcGxldGUgdGhlIHByb2JsZW0uXCIpXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6Y2xzICE9PSBFZGl0b3IgPyBcInBlcnNldXMtYW5zd2VyLXdpZGdldFwiIDogXCJcIn0sIFxuICAgICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIC8vIENvdWxkIGJlIGp1c3QgXy5waWNrKHRoaXMucHJvcHMsIFwidHlwZVwiLCBcIm9wdGlvbnNcIik7IGJ1dCB2YWxpZGF0aW9uIVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5wcm9wcy50eXBlLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5yZWZzLmVkaXRvci50b0pTT04oc2tpcFZhbGlkYXRpb24pLFxuICAgICAgICAgICAgY2FsY3VsYXRvcjogdGhpcy5wcm9wcy5jYWxjdWxhdG9yXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbn0pKFBlcnNldXMpO1xuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG5cbi8qIFlvdSBrbm93IHdoZW4geW91IHdhbnQgdG8gcHJvcGFnYXRlIGlucHV0IHRvIGEgcGFyZW50Li4uXG4gKiBidXQgdGhlbiB0aGF0IHBhcmVudCBkb2VzIHNvbWV0aGluZyB3aXRoIHRoZSBpbnB1dC4uLlxuICogdGhlbiBjaGFuZ2luZyB0aGUgcHJvcHMgb2YgdGhlIGlucHV0Li4uXG4gKiBvbiBldmVyeSBrZXlzdHJva2UuLi5cbiAqIHNvIGlmIHNvbWUgaW5wdXQgaXMgaW52YWxpZCBvciBpbmNvbXBsZXRlLi4uXG4gKiB0aGUgaW5wdXQgZ2V0cyByZXNldCBvciBvdGhlcndpc2UgZWZmZWQuLi5cbiAqXG4gKiBUaGlzIGlzIHRoZSBzb2x1dGlvbi5cbiAqXG4gKiBFbm91Z2ggbWVsb2RyYW1hLiBJdHMgYW4gaW1wdXQgdGhhdCBvbmx5IHNlbmRzIGNoYW5nZXMgdG8gaXRzIHBhcmVudCBvblxuICogYmx1ci5cbiAqL1xudmFyIEJsdXJJbnB1dCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0JsdXJJbnB1dCcsXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIHZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSxcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5wcm9wcy52YWx1ZSB9O1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgIHt0eXBlOlwidGV4dFwiLFxuICAgICAgICAgICAgdmFsdWU6dGhpcy5zdGF0ZS52YWx1ZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuaGFuZGxlQ2hhbmdlLFxuICAgICAgICAgICAgb25CbHVyOnRoaXMuaGFuZGxlQmx1cn0gKTtcbiAgICB9LFxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IG5leHRQcm9wcy52YWx1ZSB9KTtcbiAgICB9LFxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IGUudGFyZ2V0LnZhbHVlIH0pO1xuICAgIH0sXG4gICAgaGFuZGxlQmx1cjogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbHVySW5wdXQ7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xuXG52YXIgSW5mb1RpcCAgICAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9pbmZvLXRpcC5qc3hcIik7XG52YXIgTnVtYmVySW5wdXQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9udW1iZXItaW5wdXQuanN4XCIpO1xuXG52YXIgZGVmYXVsdEJveFNpemUgPSA0MDA7XG52YXIgZGVmYXVsdEJhY2tncm91bmRJbWFnZSA9IHtcbiAgICB1cmw6IG51bGwsXG4gICAgc2NhbGU6IDEsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG59O1xuXG5mdW5jdGlvbiBudW1TdGVwcyhyYW5nZSwgc3RlcCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKChyYW5nZVsxXSAtIHJhbmdlWzBdKSAvIHN0ZXApO1xufVxuXG52YXIgR3JhcGhTZXR0aW5ncyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0dyYXBoU2V0dGluZ3MnLFxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbHNUZXh0Ym94OiB0aGlzLnByb3BzLmxhYmVscyxcbiAgICAgICAgICAgIGdyaWRTdGVwVGV4dGJveDogdGhpcy5wcm9wcy5ncmlkU3RlcCxcbiAgICAgICAgICAgIHNuYXBTdGVwVGV4dGJveDogdGhpcy5wcm9wcy5zbmFwU3RlcCxcbiAgICAgICAgICAgIHN0ZXBUZXh0Ym94OiB0aGlzLnByb3BzLnN0ZXAsXG4gICAgICAgICAgICByYW5nZVRleHRib3g6IHRoaXMucHJvcHMucmFuZ2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJveDogWzM0MCwgMzQwXSxcbiAgICAgICAgICAgIGxhYmVsczogW1wieFwiLCBcInlcIl0sXG4gICAgICAgICAgICByYW5nZTogW1stMTAsIDEwXSwgWy0xMCwgMTBdXSxcbiAgICAgICAgICAgIHN0ZXA6IFsxLCAxXSxcbiAgICAgICAgICAgIGdyaWRTdGVwOiBbMSwgMV0sXG4gICAgICAgICAgICBzbmFwU3RlcDogVXRpbC5zbmFwU3RlcEZyb21HcmlkU3RlcChcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmdyaWRTdGVwIHx8IFsxLCAxXSksXG4gICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogZGVmYXVsdEJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICAgIG1hcmtpbmdzOiBcImdyYXBoXCIsXG4gICAgICAgICAgICBzaG93UHJvdHJhY3RvcjogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiZ3JhcGgtc2V0dGluZ3NcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXCJ4IGxhYmVsOiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCAge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOlwibGFiZWxzLTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0Ol8uYmluZCh0aGlzLmNoYW5nZUxhYmVsLCB0aGlzLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnN0YXRlLmxhYmVsc1RleHRib3hbMF19IClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXCJ5IGxhYmVsOiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCAge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOlwibGFiZWxzLTFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0Ol8uYmluZCh0aGlzLmNoYW5nZUxhYmVsLCB0aGlzLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnN0YXRlLmxhYmVsc1RleHRib3hbMV19IClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXCJ4IHJhbmdlOiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCAge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOlwicmFuZ2UtMC0wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25JbnB1dDpfLmJpbmQodGhpcy5jaGFuZ2VSYW5nZSwgdGhpcywgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5zdGF0ZS5yYW5nZVRleHRib3hbMF1bMF19ICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCggIHt0eXBlOlwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcInJhbmdlLTAtMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ6Xy5iaW5kKHRoaXMuY2hhbmdlUmFuZ2UsIHRoaXMsIDAsIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMuc3RhdGUucmFuZ2VUZXh0Ym94WzBdWzFdfSApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiB5IHJhbmdlOiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCAge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOlwicmFuZ2UtMS0wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25JbnB1dDpfLmJpbmQodGhpcy5jaGFuZ2VSYW5nZSwgdGhpcywgMSwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5zdGF0ZS5yYW5nZVRleHRib3hbMV1bMF19ICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCggIHt0eXBlOlwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcInJhbmdlLTEtMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ6Xy5iaW5kKHRoaXMuY2hhbmdlUmFuZ2UsIHRoaXMsIDEsIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMuc3RhdGUucmFuZ2VUZXh0Ym94WzFdWzFdfSApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBUaWNrIFN0ZXA6IFwiLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoICB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6XCJzdGVwLTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0Ol8uYmluZCh0aGlzLmNoYW5nZVN0ZXAsIHRoaXMsIDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMuc3RhdGUuc3RlcFRleHRib3hbMF19ICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCggIHt0eXBlOlwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcInN0ZXAtMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ6Xy5iaW5kKHRoaXMuY2hhbmdlU3RlcCwgdGhpcywgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5zdGF0ZS5zdGVwVGV4dGJveFsxXX0gKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgR3JpZCBTdGVwOiBcIixcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVySW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwiZ3JpZC1zdGVwLTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOl8uYmluZCh0aGlzLmNoYW5nZUdyaWRTdGVwLCB0aGlzLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMuc3RhdGUuZ3JpZFN0ZXBUZXh0Ym94WzBdfSApLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJJbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJncmlkLXN0ZXAtMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6Xy5iaW5kKHRoaXMuY2hhbmdlR3JpZFN0ZXAsIHRoaXMsIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5zdGF0ZS5ncmlkU3RlcFRleHRib3hbMV19IClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIFNuYXAgU3RlcDogXCIsXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcklucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcInNuYXAtc3RlcC0wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpfLmJpbmQodGhpcy5jaGFuZ2VTbmFwU3RlcCwgdGhpcywgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnN0YXRlLnNuYXBTdGVwVGV4dGJveFswXX0gKSxcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVySW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwic25hcC1zdGVwLTFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOl8uYmluZCh0aGlzLmNoYW5nZVNuYXBTdGVwLCB0aGlzLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMuc3RhdGUuc25hcFN0ZXBUZXh0Ym94WzFdfSApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXCJNYXJraW5nczogXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KCB7dmFsdWU6dGhpcy5wcm9wcy5tYXJraW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5jaGFuZ2VNYXJraW5nc30sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImdyYXBoXCJ9LCBcIkdyYXBoIChheGVzICsgZ3JpZClcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiZ3JpZFwifSwgXCJHcmlkIG9ubHlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwibm9uZVwifSwgXCJOb25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImltYWdlLXNldHRpbmdzXCJ9LCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFwiQmFja2dyb3VuZCBpbWFnZTpcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcIlVybDogXCIsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOlwiZ3JhcGgtc2V0dGluZ3MtYmFja2dyb3VuZC11cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6XCJiZy11cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6dGhpcy5wcm9wcy5iYWNrZ3JvdW5kSW1hZ2UudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5UHJlc3M6dGhpcy5jaGFuZ2VCYWNrZ3JvdW5kVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQmx1cjp0aGlzLmNoYW5nZUJhY2tncm91bmRVcmx9ICksXG4gICAgICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIkNyZWF0ZSBhbiBpbWFnZSBpbiBncmFwaGllLCBvciB1c2UgdGhlIFxcXCJBZGQgaW1hZ2VcXFwiIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiB0byBjcmVhdGUgYSBiYWNrZ3JvdW5kLlwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmJhY2tncm91bmRJbWFnZS51cmwgJiYgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcIlBpeGVscyBmcm9tIGxlZnQ6IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOlwiYmctbGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmJhY2tncm91bmRJbWFnZS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgXy5wYXJ0aWFsKHRoaXMuY2hhbmdlQmFja2dyb3VuZFNldHRpbmcsIFwibGVmdFwiKX0gKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFwiUGl4ZWxzIGZyb20gYm90dG9tOiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcImJnLWJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmJhY2tncm91bmRJbWFnZS5ib3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnBhcnRpYWwodGhpcy5jaGFuZ2VCYWNrZ3JvdW5kU2V0dGluZywgXCJib3R0b21cIil9IClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcIkltYWdlIHNjYWxlOiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcImJnLXNjYWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMucHJvcHMuYmFja2dyb3VuZEltYWdlLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgXy5wYXJ0aWFsKHRoaXMuY2hhbmdlQmFja2dyb3VuZFNldHRpbmcsIFwic2NhbGVcIil9IClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwibWlzYy1zZXR0aW5nc1wifSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBTaG93IHByb3RyYWN0b3I6IFwiLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoIHt0eXBlOlwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6dGhpcy5wcm9wcy5zaG93UHJvdHJhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy50b2dnbGVTaG93UHJvdHJhY3Rvcn0gKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbmdlR3JhcGggPSB0aGlzLmNoYW5nZUdyYXBoO1xuICAgICAgICB0aGlzLmNoYW5nZUdyYXBoID0gXy5kZWJvdW5jZShfLmJpbmQoY2hhbmdlR3JhcGgsIHRoaXMpLCAzMDApO1xuICAgIH0sXG5cblxuICAgIHZhbGlkUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBudW1iZXJzID0gXy5ldmVyeShyYW5nZSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pc0Zpbml0ZShudW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCEgbnVtYmVycykge1xuICAgICAgICAgICAgcmV0dXJuIFwiUmFuZ2UgbXVzdCBiZSBhIHZhbGlkIG51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZVswXSA+PSByYW5nZVsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUmFuZ2UgbXVzdCBoYXZlIGEgaGlnaGVyIG51bWJlciBvbiB0aGUgcmlnaHRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGVTdGVwVmFsdWU6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBzdGVwID0gc2V0dGluZ3Muc3RlcDtcbiAgICAgICAgdmFyIHJhbmdlID0gc2V0dGluZ3MucmFuZ2U7XG4gICAgICAgIHZhciBuYW1lID0gc2V0dGluZ3MubmFtZTtcbiAgICAgICAgdmFyIG1pblRpY2tzID0gc2V0dGluZ3MubWluVGlja3M7XG4gICAgICAgIHZhciBtYXhUaWNrcyA9IHNldHRpbmdzLm1heFRpY2tzO1xuXG4gICAgICAgIGlmICghIF8uaXNGaW5pdGUoc3RlcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgXCIgbXVzdCBiZSBhIHZhbGlkIG51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuU3RlcHMgPSBudW1TdGVwcyhyYW5nZSwgc3RlcCk7XG4gICAgICAgIGlmIChuU3RlcHMgPCBtaW5UaWNrcykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiBpcyB0b28gbGFyZ2UsIHRoZXJlIG11c3QgYmUgYXQgbGVhc3QgXCIgK1xuICAgICAgICAgICAgICAgbWluVGlja3MgKyBcIiB0aWNrcy5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoblN0ZXBzID4gbWF4VGlja3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgXCIgaXMgdG9vIHNtYWxsLCB0aGVyZSBjYW4gYmUgYXQgbW9zdCBcIiArXG4gICAgICAgICAgICAgICBtYXhUaWNrcyArIFwiIHRpY2tzLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICB2YWxpZFNuYXBTdGVwOiBmdW5jdGlvbihzdGVwLCByYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0ZXBWYWx1ZSh7XG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgbmFtZTogXCJTbmFwIHN0ZXBcIixcbiAgICAgICAgICAgIG1pblRpY2tzOiA1LFxuICAgICAgICAgICAgbWF4VGlja3M6IDYwXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2YWxpZEdyaWRTdGVwOiBmdW5jdGlvbihzdGVwLCByYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0ZXBWYWx1ZSh7XG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgbmFtZTogXCJHcmlkIHN0ZXBcIixcbiAgICAgICAgICAgIG1pblRpY2tzOiAzLFxuICAgICAgICAgICAgbWF4VGlja3M6IDYwXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2YWxpZFN0ZXA6IGZ1bmN0aW9uKHN0ZXAsIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU3RlcFZhbHVlKHtcbiAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBuYW1lOiBcIlN0ZXBcIixcbiAgICAgICAgICAgIG1pblRpY2tzOiAzLFxuICAgICAgICAgICAgbWF4VGlja3M6IDIwXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUdyYXBoU2V0dGluZ3M6IGZ1bmN0aW9uKHJhbmdlLCBzdGVwLCBncmlkU3RlcCwgc25hcFN0ZXApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbXNnO1xuICAgICAgICB2YXIgZ29vZFJhbmdlID0gXy5ldmVyeShyYW5nZSwgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgIG1zZyA9IHNlbGYudmFsaWRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gbXNnID09PSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFnb29kUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdvb2RTdGVwID0gXy5ldmVyeShzdGVwLCBmdW5jdGlvbihzdGVwLCBpKSB7XG4gICAgICAgICAgICBtc2cgPSBzZWxmLnZhbGlkU3RlcChzdGVwLCByYW5nZVtpXSk7XG4gICAgICAgICAgICByZXR1cm4gbXNnID09PSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFnb29kU3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ29vZEdyaWRTdGVwID0gXy5ldmVyeShncmlkU3RlcCwgZnVuY3Rpb24oZ3JpZFN0ZXAsIGkpIHtcbiAgICAgICAgICAgIG1zZyA9IHNlbGYudmFsaWRHcmlkU3RlcChncmlkU3RlcCwgcmFuZ2VbaV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1zZyA9PT0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZ29vZEdyaWRTdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnb29kU25hcFN0ZXAgPSBfLmV2ZXJ5KHNuYXBTdGVwLCBmdW5jdGlvbihzbmFwU3RlcCwgaSkge1xuICAgICAgICAgICAgbXNnID0gc2VsZi52YWxpZFNuYXBTdGVwKHNuYXBTdGVwLCByYW5nZVtpXSk7XG4gICAgICAgICAgICByZXR1cm4gbXNnID09PSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFnb29kU25hcFN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGNoYW5nZUxhYmVsOiBmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgIHZhciB2YWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzVGV4dGJveC5zbGljZSgpO1xuICAgICAgICBsYWJlbHNbaV0gPSB2YWw7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbHNUZXh0Ym94OiBsYWJlbHMgfSwgdGhpcy5jaGFuZ2VHcmFwaCk7XG4gICAgfSxcblxuICAgIGNoYW5nZVJhbmdlOiBmdW5jdGlvbihpLCBqLCBlKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnJlZnNbXCJyYW5nZS1cIiArIGkgKyBcIi1cIiArIGpdLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc3RhdGUucmFuZ2VUZXh0Ym94LnNsaWNlKCk7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXSA9IHJhbmdlc1tpXS5zbGljZSgpO1xuICAgICAgICByYW5nZVtqXSA9IHZhbDtcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0YXRlLnN0ZXBUZXh0Ym94LnNsaWNlKCk7XG4gICAgICAgIHZhciBncmlkU3RlcCA9IHRoaXMuc3RhdGUuZ3JpZFN0ZXBUZXh0Ym94LnNsaWNlKCk7XG4gICAgICAgIHZhciBzbmFwU3RlcCA9IHRoaXMuc3RhdGUuc25hcFN0ZXBUZXh0Ym94LnNsaWNlKCk7XG4gICAgICAgIHZhciBzY2FsZSA9IFV0aWwuc2NhbGVGcm9tRXh0ZW50KHJhbmdlLCB0aGlzLnByb3BzLmJveFtpXSk7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkUmFuZ2UocmFuZ2UpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGVwW2ldID0gVXRpbC50aWNrU3RlcEZyb21FeHRlbnQoXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLCB0aGlzLnByb3BzLmJveFtpXSk7XG4gICAgICAgICAgICBncmlkU3RlcFtpXSA9IFV0aWwuZ3JpZFN0ZXBGcm9tVGlja1N0ZXAoc3RlcFtpXSwgc2NhbGUpO1xuICAgICAgICAgICAgc25hcFN0ZXBbaV0gPSBncmlkU3RlcFtpXSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzdGVwVGV4dGJveDogc3RlcCxcbiAgICAgICAgICAgIGdyaWRTdGVwVGV4dGJveDogZ3JpZFN0ZXAsXG4gICAgICAgICAgICBzbmFwU3RlcFRleHRib3g6IHNuYXBTdGVwLFxuICAgICAgICAgICAgcmFuZ2VUZXh0Ym94OiByYW5nZXNcbiAgICAgICAgfSwgdGhpcy5jaGFuZ2VHcmFwaCk7XG4gICAgfSxcblxuICAgIGNoYW5nZVN0ZXA6IGZ1bmN0aW9uKGksIGUpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVmc1tcInN0ZXAtXCIgKyBpXS5nZXRET01Ob2RlKCkudmFsdWU7XG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGF0ZS5zdGVwVGV4dGJveC5zbGljZSgpO1xuICAgICAgICBzdGVwW2ldID0gdmFsO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgc3RlcFRleHRib3g6IHN0ZXAgfSwgdGhpcy5jaGFuZ2VHcmFwaCk7XG4gICAgfSxcblxuICAgIGNoYW5nZVNuYXBTdGVwOiBmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnJlZnNbXCJzbmFwLXN0ZXAtXCIgKyBpXS5nZXRWYWx1ZSgpO1xuICAgICAgICB2YXIgc25hcFN0ZXAgPSB0aGlzLnN0YXRlLnNuYXBTdGVwVGV4dGJveC5zbGljZSgpO1xuICAgICAgICBzbmFwU3RlcFtpXSA9IHZhbDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNuYXBTdGVwVGV4dGJveDogc25hcFN0ZXAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUdyYXBoKTtcbiAgICB9LFxuXG4gICAgY2hhbmdlR3JpZFN0ZXA6IGZ1bmN0aW9uKGksIGUpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVmc1tcImdyaWQtc3RlcC1cIiArIGldLmdldFZhbHVlKCk7XG4gICAgICAgIHZhciBncmlkU3RlcCA9IHRoaXMuc3RhdGUuZ3JpZFN0ZXBUZXh0Ym94LnNsaWNlKCk7XG4gICAgICAgIGdyaWRTdGVwW2ldID0gdmFsO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGdyaWRTdGVwVGV4dGJveDogZ3JpZFN0ZXAsXG4gICAgICAgICAgICBzbmFwU3RlcFRleHRib3g6IF8ubWFwKGdyaWRTdGVwLCBmdW5jdGlvbihzdGVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXAgLyAyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgdGhpcy5jaGFuZ2VHcmFwaCk7XG4gICAgfSxcblxuICAgIGNoYW5nZU1hcmtpbmdzOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe21hcmtpbmdzOiBlLnRhcmdldC52YWx1ZX0pO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVsc1RleHRib3g7XG4gICAgICAgIHZhciByYW5nZSA9IF8ubWFwKHRoaXMuc3RhdGUucmFuZ2VUZXh0Ym94LCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHJhbmdlLCBOdW1iZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0ZXAgPSBfLm1hcCh0aGlzLnN0YXRlLnN0ZXBUZXh0Ym94LCBOdW1iZXIpO1xuICAgICAgICB2YXIgZ3JpZFN0ZXAgPSB0aGlzLnN0YXRlLmdyaWRTdGVwVGV4dGJveDtcbiAgICAgICAgdmFyIHNuYXBTdGVwID0gdGhpcy5zdGF0ZS5zbmFwU3RlcFRleHRib3g7XG4gICAgICAgIHZhciB2YWxpZCA9IHRoaXMudmFsaWRhdGVHcmFwaFNldHRpbmdzKHJhbmdlLCBzdGVwLCBncmlkU3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBTdGVwKTtcbiAgICAgICAgaWYgKHZhbGlkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgICBncmlkU3RlcDogZ3JpZFN0ZXAsXG4gICAgICAgICAgICAgICAgc25hcFN0ZXA6IHNuYXBTdGVwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHZhbGlkOiB2YWxpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hhbmdlQmFja2dyb3VuZFVybDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gT25seSBjb250aW51ZSBvbiBibHVyIG9yIFwiZW50ZXJcIlxuICAgICAgICBpZiAoZS50eXBlID09PSBcImtleXByZXNzXCIgJiYgZS5rZXlDb2RlICE9PSAxMykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVybCA9IHNlbGYucmVmc1tcImJnLXVybFwiXS5nZXRET01Ob2RlKCkudmFsdWU7XG4gICAgICAgIHZhciBzZXRVcmwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IF8uY2xvbmUoc2VsZi5wcm9wcy5iYWNrZ3JvdW5kSW1hZ2UpO1xuICAgICAgICAgICAgaW1hZ2UudXJsID0gdXJsO1xuICAgICAgICAgICAgaW1hZ2Uud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICBpbWFnZS5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICAgICAgc2VsZi5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgICAgICBtYXJraW5nczogdXJsID8gXCJub25lXCIgOiBcImdyYXBoXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gc2V0VXJsO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0VXJsKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hhbmdlQmFja2dyb3VuZFNldHRpbmc6IGZ1bmN0aW9uKHR5cGUsIGUpIHtcbiAgICAgICAgdmFyIGltYWdlID0gXy5jbG9uZSh0aGlzLnByb3BzLmJhY2tncm91bmRJbWFnZSk7XG4gICAgICAgIGltYWdlW3R5cGVdID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoeyBiYWNrZ3JvdW5kSW1hZ2U6IGltYWdlIH0pO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTaG93UHJvdHJhY3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe3Nob3dQcm90cmFjdG9yOiAhdGhpcy5wcm9wcy5zaG93UHJvdHJhY3Rvcn0pO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhTZXR0aW5ncztcblxuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG5cbnJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xudmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcblxudmFyIGRlZmF1bHRCb3hTaXplID0gNDAwO1xudmFyIGRlZmF1bHRCYWNrZ3JvdW5kSW1hZ2UgPSB7XG4gICAgdXJsOiBudWxsLFxuICAgIHNjYWxlOiAxLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxufTtcblxuZnVuY3Rpb24gbnVtU3RlcHMocmFuZ2UsIHN0ZXApIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigocmFuZ2VbMV0gLSByYW5nZVswXSkgLyBzdGVwKTtcbn1cblxudmFyIEdyYXBoID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnR3JhcGgnLFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBib3g6IFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkXG4gICAgfSxcblxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3g6IFtkZWZhdWx0Qm94U2l6ZSwgZGVmYXVsdEJveFNpemVdLFxuICAgICAgICAgICAgbGFiZWxzOiBbXCJ4XCIsIFwieVwiXSxcbiAgICAgICAgICAgIHJhbmdlOiBbWy0xMCwgMTBdLCBbLTEwLCAxMF1dLFxuICAgICAgICAgICAgc3RlcDogWzEsIDFdLFxuICAgICAgICAgICAgZ3JpZFN0ZXA6IFsxLCAxXSxcbiAgICAgICAgICAgIHNuYXBTdGVwOiBbMC41LCAwLjVdLFxuICAgICAgICAgICAgbWFya2luZ3M6IFwiZ3JhcGhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogZGVmYXVsdEJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICAgIHNob3dQcm90cmFjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIG9uTmV3R3JhcGhpZTogbnVsbCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IG51bGxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5wcm9wcy5iYWNrZ3JvdW5kSW1hZ2U7XG4gICAgICAgIGlmIChpbWFnZS51cmwpIHtcbiAgICAgICAgICAgIHZhciBwcmVTY2FsZSA9IHRoaXMucHJvcHMuYm94WzBdIC8gZGVmYXVsdEJveFNpemU7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBpbWFnZS5zY2FsZSAqIHByZVNjYWxlO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogKHByZVNjYWxlICogaW1hZ2UuYm90dG9tKSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiAocHJlU2NhbGUgKiBpbWFnZS5sZWZ0KSArIFwicHhcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogKHNjYWxlICogaW1hZ2Uud2lkdGgpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIGhlaWdodDogKHNjYWxlICogaW1hZ2UuaGVpZ2h0KSArIFwicHhcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlID0gUmVhY3QuRE9NLmltZygge3N0eWxlOnN0eWxlLCBzcmM6aW1hZ2UudXJsfSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJncmFwaGllLWNvbnRhaW5lclwifSwgXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJncmFwaGllXCIsIHJlZjpcImdyYXBoaWVEaXZcIn0gKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NldHVwR3JhcGhpZSgpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBPbmx5IHNldHVwR3JhcGhpZSBvbmNlIHBlciBjb21wb25lbnREaWRVcGRhdGUoKS5cbiAgICAgICAgLy8gU2VlIGV4cGxhbmF0aW9uIGluIHNldHVwR3JhcGhpZSgpLlxuICAgICAgICB0aGlzLl9oYXNTZXR1cEdyYXBoaWVUaGlzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRTZXR1cEdyYXBoaWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwR3JhcGhpZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2hvdWxkU2V0dXBHcmFwaGllID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBwb3RlbnRpYWxDaGFuZ2VzID0gW1wibGFiZWxzXCIsIFwicmFuZ2VcIiwgXCJzdGVwXCIsIFwibWFya2luZ3NcIixcbiAgICAgICAgICAgIFwic2hvd1Byb3RyYWN0b3JcIiwgXCJncmlkU3RlcFwiLCBcInNuYXBTdGVwXCJdO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIF8uZWFjaChwb3RlbnRpYWxDaGFuZ2VzLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNFcXVhbChzZWxmLnByb3BzW3Byb3BdLCBuZXh0UHJvcHNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2hvdWxkU2V0dXBHcmFwaGllID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qIFJlc2V0IHRoZSBncmFwaGllIGNhbnZhcyB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICAgICAqXG4gICAgICogVXNlIHdoZW4gcmUtcmVuZGVyaW5nIHRoZSBwYXJlbnQgY29tcG9uZW50IGFuZCB5b3UgbmVlZCBhIGJsYW5rXG4gICAgICogZ3JhcGhpZS5cbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NldHVwR3JhcGhpZSgpO1xuICAgIH0sXG5cbiAgICBncmFwaGllOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYXBoaWU7XG4gICAgfSxcblxuICAgIHBvaW50c0Zyb21Ob3JtYWxpemVkOiBmdW5jdGlvbihjb29yZHNMaXN0LCBub1NuYXApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gXy5tYXAoY29vcmRzTGlzdCwgZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAoY29vcmRzLCBmdW5jdGlvbihjb29yZCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGYucHJvcHMucmFuZ2VbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5vU25hcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF0gKyAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBjb29yZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHNlbGYucHJvcHMuc3RlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5TdGVwcyA9IG51bVN0ZXBzKHJhbmdlLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpY2sgPSBNYXRoLnJvdW5kKGNvb3JkICogblN0ZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdICsgc3RlcCAqIHRpY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfc2V0dXBHcmFwaGllOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gT25seSBzZXR1cEdyYXBoaWUgb25jZSBwZXIgY29tcG9uZW50RGlkVXBkYXRlKCkuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgdGhpcyBjb21wb25lbnQgZnJvbSByZW5kZXJpbmcgZ3JhcGhpZVxuICAgICAgICAvLyBhbmQgdGhlbiBpbW1lZGlhdGVseSByZS1yZW5kZXIgZ3JhcGhpZSBiZWNhdXNlIGl0c1xuICAgICAgICAvLyBwYXJlbnQgY29tcG9uZW50IGFza2VkIGl0IHRvLiBUaGlzIHdpbGwgaGFwcGVuIHdoZW5cbiAgICAgICAgLy8gcHJvcHMgb24gdGhlIHBhcmVudCBhbmQgcHJvcHMgb24gdGhpcyBjb21wb25lbnQgYm90aFxuICAgICAgICAvLyByZXF1aXJlIGdyYXBoaWUgdG8gYmUgcmUtcmVuZGVyZWQuXG4gICAgICAgIGlmICh0aGlzLl9oYXNTZXR1cEdyYXBoaWVUaGlzVXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JhcGhpZURpdiA9IHRoaXMucmVmcy5ncmFwaGllRGl2LmdldERPTU5vZGUoKTtcbiAgICAgICAgJChncmFwaGllRGl2KS5lbXB0eSgpO1xuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5wcm9wcy5sYWJlbHM7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMucHJvcHMucmFuZ2U7XG4gICAgICAgIHZhciBncmFwaGllID0gdGhpcy5fZ3JhcGhpZSA9IEtoYW5VdGlsLmNyZWF0ZUdyYXBoaWUoZ3JhcGhpZURpdik7XG5cbiAgICAgICAgdmFyIGdyaWRDb25maWcgPSB0aGlzLl9nZXRHcmlkQ29uZmlnKCk7XG4gICAgICAgIGdyYXBoaWUuc25hcCA9IHRoaXMucHJvcHMuc25hcFN0ZXA7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMubWFya2luZ3MgPT09IFwiZ3JhcGhcIikge1xuICAgICAgICAgICAgZ3JhcGhpZS5ncmFwaEluaXQoe1xuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBzY2FsZTogXy5wbHVjayhncmlkQ29uZmlnLCBcInNjYWxlXCIpLFxuICAgICAgICAgICAgICAgIGF4aXNBcnJvd3M6IFwiPC0+XCIsXG4gICAgICAgICAgICAgICAgbGFiZWxGb3JtYXQ6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIFwiXFxcXHNtYWxse1wiICsgcyArIFwifVwiOyB9LFxuICAgICAgICAgICAgICAgIGdyaWRTdGVwOiB0aGlzLnByb3BzLmdyaWRTdGVwLFxuICAgICAgICAgICAgICAgIHRpY2tTdGVwOiBfLnBsdWNrKGdyaWRDb25maWcsIFwidGlja1N0ZXBcIiksXG4gICAgICAgICAgICAgICAgbGFiZWxTdGVwOiAxLFxuICAgICAgICAgICAgICAgIHVuaXR5TGFiZWxzOiBfLnBsdWNrKGdyaWRDb25maWcsIFwidW5pdHlMYWJlbFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmFwaGllLmxhYmVsKFswLCByYW5nZVsxXVsxXV0sIGxhYmVsc1sxXSwgXCJhYm92ZVwiKTtcbiAgICAgICAgICAgIGdyYXBoaWUubGFiZWwoW3JhbmdlWzBdWzFdLCAwXSwgbGFiZWxzWzBdLCBcInJpZ2h0XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMubWFya2luZ3MgPT09IFwiZ3JpZFwiKSB7XG4gICAgICAgICAgICBncmFwaGllLmdyYXBoSW5pdCh7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBfLnBsdWNrKGdyaWRDb25maWcsIFwic2NhbGVcIiksXG4gICAgICAgICAgICAgICAgZ3JpZFN0ZXA6IHRoaXMucHJvcHMuZ3JpZFN0ZXAsXG4gICAgICAgICAgICAgICAgYXhlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGlja3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhYmVsczogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMubWFya2luZ3MgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBncmFwaGllLmluaXQoe1xuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBzY2FsZTogXy5wbHVjayhncmlkQ29uZmlnLCBcInNjYWxlXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoaWUuYWRkTW91c2VMYXllcih7XG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByb3BzLm9uQ2xpY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvdHJhY3RvcigpO1xuXG4gICAgICAgIC8vIFdlIHNldCB0aGlzIGZsYWcgYmVmb3JlIGp1bXBpbmcgaW50byBvdXIgY2FsbGJhY2tcbiAgICAgICAgLy8gdG8gYXZvaWQgcmVjdXJzaW5nIGlmIG91ciBjYWxsYmFjayBjYWxscyByZXNldCgpIGl0c2VsZlxuICAgICAgICB0aGlzLl9oYXNTZXR1cEdyYXBoaWVUaGlzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25OZXdHcmFwaGllKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTmV3R3JhcGhpZShncmFwaGllKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0R3JpZENvbmZpZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF8ubWFwKHNlbGYucHJvcHMuc3RlcCwgZnVuY3Rpb24oc3RlcCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwuZ3JpZERpbWVuc2lvbkNvbmZpZyhcbiAgICAgICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wcy5yYW5nZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wcy5ib3hbaV0sXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJvcHMuZ3JpZFN0ZXBbaV0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVByb3RyYWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wcm90cmFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnByb3RyYWN0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaG93UHJvdHJhY3Rvcikge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gdGhpcy5wb2ludHNGcm9tTm9ybWFsaXplZChbWzAuNTAsIDAuMDVdXSlbMF07XG4gICAgICAgICAgICB0aGlzLnByb3RyYWN0b3IgPSB0aGlzLl9ncmFwaGllLnByb3RyYWN0b3IoY29vcmQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnBpY2sodGhpcy5wcm9wcywgJ3JhbmdlJywgJ3N0ZXAnLCAnbWFya2luZ3MnLCAnbGFiZWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZEltYWdlJywgJ3Nob3dQcm90cmFjdG9yJywgJ2dyaWRTdGVwJyxcbiAgICAgICAgICAgICAgICAgICAgICAnc25hcFN0ZXAnKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG5cbnZhciBJbmZvVGlwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnSW5mb1RpcCcsXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvdmVyOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJwZXJzZXVzLWluZm8tdGlwXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5pKCB7Y2xhc3NOYW1lOlwiaWNvbi1xdWVzdGlvbi1zaWduXCIsXG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyOnRoaXMuaGFuZGxlTW91c2VFbnRlcixcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU6dGhpcy5oYW5kbGVNb3VzZUxlYXZlfSApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJwZXJzZXVzLWluZm8tdGlwLWNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTp7ZGlzcGxheTogdGhpcy5zdGF0ZS5ob3ZlciA/ICdibG9jaycgOiAnbm9uZSd9fSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJwZXJzZXVzLWluZm8tdGlwLXRyaWFuZ2xlXCJ9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge2NsYXNzTmFtZTpcInBlcnNldXMtaW5mby10aXAtY29udGVudC1jb250YWluZXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2ZXJ0aWNhbC1zaGFkb3dcIn0sIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBoYW5kbGVNb3VzZUVudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aG92ZXI6IHRydWV9KTtcbiAgICB9LFxuXG4gICAgaGFuZGxlTW91c2VMZWF2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2hvdmVyOiBmYWxzZX0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9UaXA7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xudmFyIGtudW1iZXIgPSBLaGFuVXRpbC5rbnVtYmVyO1xuXG4vKiBJZiBzdHIgcmVwcmVzZW50cyBhIHZhbGlkIG51bWJlciwgcmV0dXJuIHRoYXQgbnVtYmVyLlxuICogT3RoZXJ3aXNlLCBpZiBzdHIgaXMgZW1wdHkgYW5kIGFsbG93RW1wdHkgaXMgdHJ1ZSwgcmV0dXJuXG4gKiBudWxsLlxuICogT3RoZXJ3aXNlLCByZXR1cm4gZGVmYXVsdFZhbHVlXG4gKi9cbmZ1bmN0aW9uIG51bWJlckZyb21TdHJpbmcoc3RyLCBkZWZhdWx0VmFsdWUsIGFsbG93RW1wdHkpIHtcbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBhbGxvd0VtcHR5ID8gbnVsbCA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gVXRpbC5maXJzdE51bWVyaWNhbFBhcnNlKHN0cik7XG4gICAgICAgIHJldHVybiBfLmlzRmluaXRlKHJlc3VsdCkgPyByZXN1bHQgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxufVxuXG52YXIgaXNOdW1lcmljU3RyaW5nID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vIFNwZWNpZnkgYSByZXN1bHQgdGhhdCBjb3VsZCBvbmx5IGJlIHJldHVybmVkIGJ5XG4gICAgLy8gbnVtYmVyRnJvbVN0cmluZyBpZiBpdCB3YXMgc3BlY2lmaWVkIGFzIHRoZSBkZWZhdWx0XG4gICAgLy8gbnVsbCBhbmQgdW5kZWZpbmVkIGFyZSBsZXNzIG5pY2UgYmVjYXVzZSBudW1iZXJGcm9tU3RyaW5nXG4gICAgLy8gY291bGQgcmV0dXJuIG51bGwgaWYgYWxsb3dFbXB0eSBpcyB0cnVlLCBhbmQgd2Ugd2FudFxuICAgIC8vIHRoYXQgY2FzZSB0byByZXR1cm4gdHJ1ZSBoZXJlLlxuICAgIHZhciBkZWZhdWx0UmVzdWx0ID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzTnVtZXJpY1N0cmluZyhzdHIsIGFsbG93RW1wdHkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlckZyb21TdHJpbmcoc3RyLCBkZWZhdWx0UmVzdWx0LCBhbGxvd0VtcHR5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gZGVmYXVsdFJlc3VsdDtcbiAgICB9O1xufSkoKTtcblxuLy8gVE9ETyAoamFjayk6IEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhpcyBkaWQgbW9yZSBvZiB0aGUgaW52ZXJzZSBvZlxuLy8gbnVtYmVyRnJvbVN0cmluZywgaGFuZGxpbmcgZnJhY3Rpb25zIGFuZCBzdWNoLlxuZnVuY3Rpb24gc3RyaW5nRnJvbU51bWJlcihudW0pIHtcbiAgICByZXR1cm4gbnVtICE9IG51bGwgPyBTdHJpbmcobnVtKSA6IFwiXCI7XG59XG5cbi8qIEFuIGlucHV0IGJveCB0aGF0IGFjY2VwdHMgb25seSBudW1iZXJzXG4gKlxuICogQ2FsbHMgb25DaGFuZ2Ugd2hlbiBhIHZhbGlkIG51bWJlciBpcyBlbnRlcmVkLlxuICogUmV2ZXJ0cyB0byB0aGUgY3VycmVudCB2YWx1ZSBvbkJsdXIgb3Igb24gW0VOVEVSXVxuICogT3B0aW9uYWxseSBhY2NlcHRzIGVtcHR5IGlucHV0IGFuZCBzZW5kcyBpdCB0b1xuICogb25DaGFuZ2UgYXMgbnVsbFxuICovXG52YXIgTnVtYmVySW5wdXQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdOdW1iZXJJbnB1dCcsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogbnVsbFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmlucHV0KF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibnVtYmVyLWlucHV0XCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLl9oYW5kbGVDaGFuZ2UsXG4gICAgICAgICAgICBvbkJsdXI6IHRoaXMuX2hhbmRsZUJsdXIsXG4gICAgICAgICAgICBvbktleVByZXNzOiB0aGlzLl9oYW5kbGVCbHVyLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzdHJpbmdGcm9tTnVtYmVyKHRoaXMucHJvcHMudmFsdWUpLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzKSB7XG4gICAgICAgIGlmICgha251bWJlci5lcXVhbCh0aGlzLmdldFZhbHVlKCksIHRoaXMucHJvcHMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZSh0aGlzLnByb3BzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZW1wdHkgc3RyaW5nIGlzIGEgdmFsaWQgdmFsdWUgZm9yIG91ciB0ZXh0IGlucHV0XG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIGlmIHByb3BzLmFsbG93RW1wdHkgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQsIG9yIGlmXG4gICAgICogYSBwbGFjZWhvbGRlciB2YWx1ZSBpcyBzcGVjaWZpZWQgKHdoaWNoIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZlxuICAgICAqIG51bGwgaW4gdGhlIGNhc2Ugb2YgYW4gZW1wdHkgdGV4dCBpbnB1dClcbiAgICAgKi9cbiAgICBfYWxsb3dFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmFsbG93RW1wdHkgfHwgdGhpcy5wcm9wcy5wbGFjZWhvbGRlciAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKiBSZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBpbnB1dFxuICAgICAqXG4gICAgICogVGFrZXMgaW50byBhY2NvdW50IHdoZXRoZXIgcHJvcHMuYWxsb3dFbXB0eSBpcyBzcGVjaWZpZWQgKGFsbG93aW5nIG51bGxcbiAgICAgKiB0byBiZSByZXR1cm5lZCBpbiB0aGUgY2FzZSBvZiBhbiBlbXB0eSBzdHJpbmcpLCBhbmQgcHJvcHMucGxhY2Vob2xkZXIsXG4gICAgICogd2hpY2ggd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgY2FzZSBvZiBhbiBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgdmFyIG51bSA9IG51bWJlckZyb21TdHJpbmcodGV4dCwgdGhpcy5wcm9wcy52YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChudW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5hbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnBsYWNlaG9sZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnBsYWNlaG9sZGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU2V0IHRleHQgaW5wdXQgZm9jdXMgdG8gdGhpcyBpbnB1dCAqL1xuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRET01Ob2RlKCkuZm9jdXMoKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZUNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdGV4dCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICBpZiAoaXNOdW1lcmljU3RyaW5nKHRleHQsIHRoaXMuX2FsbG93RW1wdHkoKSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUT0RPIChqYWNrKTogVGhpcyBzaG91bGQgcmV2ZXJ0IHRvIHRoZSBsYXN0IHZhbGlkIHN0cmluZ1xuICAgIC8vIHJhdGhlciB0aGFuIHRoZSBzdHJpbmcgb2YgdGhlIG51bWJlciwgdG8gYXZvaWQgc2l0dWF0aW9uc1xuICAgIC8vIGxpa2UgXCIyLzNhXCIgdHVybmluZyBpbnRvIFwiMC42NjY2NjY2NjY2Ni4uLlwiXG4gICAgX2hhbmRsZUJsdXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gT25seSBjb250aW51ZSBvbiBibHVyIG9yIFwiZW50ZXJcIlxuICAgICAgICBpZiAoZS50eXBlID09PSBcImtleXByZXNzXCIgJiYgZS5rZXlDb2RlICE9PSAxMykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgaWYgKCFpc051bWVyaWNTdHJpbmcodGV4dCwgdGhpcy5fYWxsb3dFbXB0eSgpKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWUodGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFZhbHVlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgJCh0aGlzLmdldERPTU5vZGUoKSkudmFsKHN0cmluZ0Zyb21OdW1iZXIodmFsKSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVySW5wdXQ7XG5cbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG5yZXF1aXJlKFwiLi4vY29yZS5qc1wiKTtcblxuLyogQSBjaGVja2JveCB0aGF0IHN5bmNzIGl0cyB2YWx1ZSB0byBwcm9wcyB1c2luZyB0aGVcbiAqIHJlbmRlcmVyJ3Mgb25DaGFuZ2UgbWV0aG9kLCBhbmQgZ2V0cyB0aGUgcHJvcCBuYW1lXG4gKiBkeW5hbWljYWxseSBmcm9tIGl0cyBwcm9wcyBsaXN0XG4gKi9cbnZhciBQcm9wQ2hlY2tCb3ggPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdQcm9wQ2hlY2tCb3gnLFxuICAgIERFRkFVTFRfUFJPUFM6IHtcbiAgICAgICAgbGFiZWw6IG51bGwsXG4gICAgICAgIG9uQ2hhbmdlOiBudWxsXG4gICAgfSxcblxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkRFRkFVTFRfUFJPUFM7XG4gICAgfSxcblxuICAgIHByb3BOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gXy5maW5kKF8ua2V5cyh0aGlzLnByb3BzKSwgZnVuY3Rpb24obG9jYWxQcm9wTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICFfLmhhcyh0aGlzLkRFRkFVTFRfUFJPUFMsIGxvY2FsUHJvcE5hbWUpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXByb3BOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gY3JlYXRlIGEgUHJvcENoZWNrQm94IHdpdGggbm8gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInByb3AhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BOYW1lO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSB0aGlzLnByb3BOYW1lKCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICB0aGlzLnByb3BzLmxhYmVsLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6dGhpcy5wcm9wc1twcm9wTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy50b2dnbGV9IClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gdGhpcy5wcm9wTmFtZSgpO1xuICAgICAgICB2YXIgY2hhbmdlcyA9IHt9O1xuICAgICAgICBjaGFuZ2VzW3Byb3BOYW1lXSA9ICF0aGlzLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShjaGFuZ2VzKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9wQ2hlY2tCb3g7XG5cbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5yZXF1aXJlKFwiLi4vcmVuZGVyZXIuanN4XCIpO1xuXG52YXIgUmVuZGVyZXIgPSBQZXJzZXVzLlJlbmRlcmVyO1xuXG52YXIgUFJFRklYID0gXCJwZXJzZXVzLXNvcnRhYmxlXCI7XG5cblxuLy8gQSBwbGFjZWhvbGRlciB0aGF0IGFwcGVhcnMgaW4gdGhlIHNvcnRhYmxlIHdoZW5ldmVyIGFuIGl0ZW0gaXMgZHJhZ2dlZC5cbnZhciBQbGFjZWhvbGRlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1BsYWNlaG9sZGVyJyxcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFtQUkVGSVggKyBcIi1jYXJkXCIsIFBSRUZJWCArIFwiLXBsYWNlaG9sZGVyXCJdLmpvaW4oXCIgXCIpO1xuICAgICAgICB2YXIgc3R5bGUgPSB7d2lkdGg6IHRoaXMucHJvcHMud2lkdGgsIGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHR9O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1hcmdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHlsZS5tYXJnaW4gPSB0aGlzLnByb3BzLm1hcmdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00ubGkoIHtjbGFzc05hbWU6Y2xhc3NOYW1lLCBzdHlsZTpzdHlsZX0gKTtcbiAgICB9XG59KTtcblxuXG52YXIgU1RBVElDID0gXCJzdGF0aWNcIixcbiAgICBEUkFHR0lORyA9IFwiZHJhZ2dpbmdcIixcbiAgICBBTklNQVRJTkcgPSBcImFuaW1hdGluZ1wiLFxuICAgIERJU0FCTEVEID0gXCJkaXNhYmxlZFwiO1xuXG4vLyBBIGRyYWdnYWJsZSBpdGVtIGluIHRoZSBzb3J0YWJsZS4gQ2FuIGJlIGluIG9uZSBvZiBmb3VyIHN0YXRlczpcbi8vICAgICBTdGF0aWM6ICAgIFRoZSBpdGVtIGlzIG5vdCBiZWluZyBpbnRlcmFjdGVkIHdpdGguXG4vLyAgICAgRHJhZ2dpbmc6ICBUaGUgaXRlbSBpcyBiZWluZyBkcmFnZ2VkLlxuLy8gICAgIEFuaW1hdGluZzogVGhlIGl0ZW0gaGFzIGJlZW4gcmVsZWFzZWQsIGFuZCBpcyBtb3ZpbmcgdG8gaXRzIGRlc3RpbmF0aW9uLlxuLy8gICAgIERpc2FibGVkOiAgVGhlIGl0ZW0gY2Fubm90IGJlIGludGVyYWN0ZWQgd2l0aC5cbi8vXG4vLyBVc3VhbCBmbG93OiAgICAgIFN0YXRpYyAtPiBEcmFnZ2luZyAtPiBBbmltYXRpbmcgLT4gU3RhdGljXG4vLyBbRGlzfGVuXWFibGluZzogIFN0YXRpY3xEcmFnZ2luZ3xBbmltYXRpbmcgLT4gRGlzYWJsZWQgLT4gU3RhdGljXG52YXIgRHJhZ2dhYmxlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnRHJhZ2dhYmxlJyxcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgdHlwZTogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFtTVEFUSUMsIERSQUdHSU5HLCBBTklNQVRJTkcsIERJU0FCTEVEXSksXG4gICAgICAgIGNvbnRlbnQ6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgZW5kUG9zaXRpb246IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICAgICAgb25SZW5kZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICAgIG9uTW91c2VEb3duOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgICBvbk1vdXNlTW92ZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgICAgb25Nb3VzZVVwOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgICBvbkFuaW1hdGlvbkVuZDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU1RBVElDXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uOiB7bGVmdDogMCwgdG9wOiAwfSxcbiAgICAgICAgICAgIHN0YXJ0TW91c2U6IHtsZWZ0OiAwLCB0b3A6IDB9LFxuICAgICAgICAgICAgbW91c2U6IHtsZWZ0OiAwLCB0b3A6IDB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEN1cnJlbnRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnN0YXRlLnN0YXJ0UG9zaXRpb24ubGVmdCArXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1vdXNlLmxlZnQgLVxuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGFydE1vdXNlLmxlZnQsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc3RhdGUuc3RhcnRQb3NpdGlvbi50b3AgK1xuICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1vdXNlLnRvcCAtXG4gICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhcnRNb3VzZS50b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFtcbiAgICAgICAgICAgICAgICBQUkVGSVggKyBcIi1jYXJkXCIsXG4gICAgICAgICAgICAgICAgUFJFRklYICsgXCItZHJhZ2dhYmxlXCIsXG4gICAgICAgICAgICAgICAgUFJFRklYICsgXCItXCIgKyB0aGlzLnByb3BzLnR5cGVcbiAgICAgICAgICAgIF0uam9pbihcIiBcIik7XG5cbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IFwic3RhdGljXCJcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy50eXBlID09PSBEUkFHR0lORyB8fCB0aGlzLnByb3BzLnR5cGUgPT09IEFOSU1BVElORykge1xuICAgICAgICAgICAgXy5leHRlbmQoc3R5bGUsIHtwb3NpdGlvbjogXCJhYnNvbHV0ZVwifSwgdGhpcy5nZXRDdXJyZW50UG9zaXRpb24oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy53aWR0aCkge1xuICAgICAgICAgICAgc3R5bGUud2lkdGggPSB0aGlzLnByb3BzLndpZHRoICsgMTsgLy8gRml4IGZvciBub24taW50ZWdlciB3aWR0aHNcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1hcmdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHlsZS5tYXJnaW4gPSB0aGlzLnByb3BzLm1hcmdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00ubGkoXG4gICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6Y2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTpzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd246dGhpcy5vbk1vdXNlRG93bixcbiAgICAgICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OnRoaXMub25Nb3VzZURvd259ICwgXG4gICAgICAgICAgICBSZW5kZXJlcihcbiAgICAgICAgICAgICAgICB7Y29udGVudDp0aGlzLnByb3BzLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgb25SZW5kZXI6dGhpcy5wcm9wcy5vblJlbmRlcn0gKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy50eXBlID09PSBwcmV2UHJvcHMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMudHlwZSA9PT0gQU5JTUFUSU5HKSB7XG4gICAgICAgICAgICAvLyBTdGFydCBhbmltYXRpbmdcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRDdXJyZW50UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IDE1ICogTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3codGhpcy5wcm9wcy5lbmRQb3NpdGlvbi5sZWZ0IC0gY3VycmVudC5sZWZ0LCAyKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHRoaXMucHJvcHMuZW5kUG9zaXRpb24udG9wIC0gY3VycmVudC50b3AsIDIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgJCh0aGlzLmdldERPTU5vZGUoKSkuYW5pbWF0ZSh0aGlzLnByb3BzLmVuZFBvc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgubWF4KGR1cmF0aW9uLCAxKSxcbiAgICAgICAgICAgICAgICAvLyBBbmltYXRpbmcgLT4gU3RhdGljXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IHRoaXMucHJvcHMub25BbmltYXRpb25FbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMudHlwZSA9PT0gU1RBVElDKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBhbnkgYW5pbWF0aW9ucyBhcmUgZG9uZVxuICAgICAgICAgICAgJCh0aGlzLmdldERPTU5vZGUoKSkuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Nb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnR5cGUgIT09IFNUQVRJQykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoZXZlbnQuYnV0dG9uID09PSAwIHx8XG4gICAgICAgICAgICAgICAgKGV2ZW50LnRvdWNoZXMgIT0gbnVsbCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgbm9ybWFsaXplZEV2ZW50ID0gZXZlbnQudG91Y2hlcyAhPSBudWxsID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuICAgICAgICB2YXIgbW91c2UgPSB7XG4gICAgICAgICAgICBsZWZ0OiBub3JtYWxpemVkRXZlbnQucGFnZVgsXG4gICAgICAgICAgICB0b3A6IG5vcm1hbGl6ZWRFdmVudC5wYWdlWVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjogJCh0aGlzLmdldERPTU5vZGUoKSkucG9zaXRpb24oKSxcbiAgICAgICAgICAgIHN0YXJ0TW91c2U6IG1vdXNlLFxuICAgICAgICAgICAgbW91c2U6IG1vdXNlXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJChkb2N1bWVudCkub24oXCJ2bW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgJChkb2N1bWVudCkub24oXCJ2bW91c2V1cFwiLCB0aGlzLm9uTW91c2VVcCk7XG5cbiAgICAgICAgICAgIC8vIFN0YXRpYyAtPiBEcmFnZ2luZ1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlRG93bigpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnR5cGUgIT09IERSQUdHSU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG1vdXNlOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICAgICAgdG9wOiBldmVudC5wYWdlWVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnByb3BzLm9uTW91c2VNb3ZlKTtcbiAgICB9LFxuXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy50eXBlICE9PSBEUkFHR0lORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKFwidm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKFwidm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXApO1xuXG4gICAgICAgIC8vIERyYWdnaW5nIC0+IEFuaW1hdGluZ1xuICAgICAgICB0aGlzLnByb3BzLm9uTW91c2VVcCgpO1xuICAgIH1cbn0pO1xuXG5cbnZhciBIT1JJWk9OVEFMID0gXCJob3Jpem9udGFsXCIsXG4gICAgVkVSVElDQUwgPSBcInZlcnRpY2FsXCI7XG5cbi8vIFRoZSBtYWluIHNvcnRhYmxlIGNvbXBvbmVudC5cbnZhciBTb3J0YWJsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1NvcnRhYmxlJyxcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgb3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gICAgICAgIGxheW91dDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFtIT1JJWk9OVEFMLCBWRVJUSUNBTF0pLFxuICAgICAgICBwYWRkaW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgICAgICBjb25zdHJhaW50czogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgb25NZWFzdXJlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbWFyZ2luOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgfSxcblxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXlvdXQ6IEhPUklaT05UQUwsXG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29uc3RyYWludHM6IHt9LFxuICAgICAgICAgICAgb25NZWFzdXJlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgbWFyZ2luOiA1XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtczogdGhpcy5pdGVtc0Zyb21Qcm9wcyh0aGlzLnByb3BzKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKCFfLmlzRXF1YWwobmV4dFByb3BzLm9wdGlvbnMsIHByZXZQcm9wcy5vcHRpb25zKSkge1xuXG4gICAgICAgICAgICAvLyBSZWdlbmVyYXRlIGl0ZW1zXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy5pdGVtc0Zyb21Qcm9wcyhuZXh0UHJvcHMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy5sYXlvdXQgIT09IHByZXZQcm9wcy5sYXlvdXQgfHwgXG4gICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLnBhZGRpbmcgIT09IHByZXZQcm9wcy5wYWRkaW5nIHx8XG4gICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLmRpc2FibGVkICE9PSBwcmV2UHJvcHMuZGlzYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAhXy5pc0VxdWFsKG5leHRQcm9wcy5jb25zdHJhaW50cywgcHJldlByb3BzLmNvbnN0cmFpbnRzKSkge1xuXG4gICAgICAgICAgICAvLyBDbGVhciBpdGVtIG1lYXN1cmVtZW50c1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHRoaXMuY2xlYXJJdGVtTWVhc3VyZW1lbnRzKHRoaXMuc3RhdGUuaXRlbXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcykge1xuICAgICAgICAvLyBNZWFzdXJlIGl0ZW1zIGlmIHRoZWlyIGRpbWVuc2lvbnMgaGF2ZSBiZWVuIHJlc2V0XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLml0ZW1zLmxlbmd0aCAmJiAhdGhpcy5zdGF0ZS5pdGVtc1swXS53aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlSXRlbXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpdGVtc0Zyb21Qcm9wczogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBwcm9wcy5kaXNhYmxlZCA/IERJU0FCTEVEIDogU1RBVElDO1xuICAgICAgICByZXR1cm4gXy5tYXAocHJvcHMub3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wdGlvbjogb3B0aW9uLFxuICAgICAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGVuZFBvc2l0aW9uOiB7fSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjbGVhckl0ZW1NZWFzdXJlbWVudHM6IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBfLm1hcChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbWVhc3VyZUl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTWVhc3VyZSBhbGwgaXRlbXMgYW5kIGNhY2hlIHdoYXQgdGhlaXIgZGltZW5zaW9ucyBzaG91bGQgYmUsIHRha2luZ1xuICAgICAgICAvLyBpbnRvIGFjY291bnQgY29uc3RyYWludHMgYW5kIHRoZSBjdXJyZW50IGxheW91dC4gVGhpcyBhbGxvd3Mgc3luY2luZ1xuICAgICAgICAvLyB3aWR0aHMgYW5kIGhlaWdodHMgZm9yIHByZXR0eSByb3dzL2NvbHVtbnMuIE5vdGUgdGhhdCBkaW1lbnNpb25zIGFyZVxuICAgICAgICAvLyBleHBsaWN0bHkgc2V0IG9uIERyYWdnYWJsZXMgLSB0aGlzIHByZXZlbnRzIHRoZW0gZnJvbSBjaGFuZ2luZyBzaXplXG4gICAgICAgIC8vIG9yIHNoYXBlIHdoaWxlIGJlaW5nIGRyYWdnZWQuXG5cbiAgICAgICAgdmFyIGl0ZW1zID0gXy5jbG9uZSh0aGlzLnN0YXRlLml0ZW1zKTtcbiAgICAgICAgdmFyICRpdGVtcyA9IF8ubWFwKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLnJlZnNbaXRlbS5rZXldLmdldERPTU5vZGUoKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHZhciB3aWR0aHMgPSBfLmludm9rZSgkaXRlbXMsIFwib3V0ZXJXaWR0aFwiKTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBfLmludm9rZSgkaXRlbXMsIFwib3V0ZXJIZWlnaHRcIik7XG5cbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5wcm9wcy5jb25zdHJhaW50cztcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMucHJvcHMubGF5b3V0O1xuXG4gICAgICAgIHZhciBzeW5jV2lkdGg7XG4gICAgICAgIGlmIChjb25zdHJhaW50cy53aWR0aCkge1xuICAgICAgICAgICAgLy8gSXRlbXMgbXVzdCBiZSBhdCBsZWFzdCBhcyB3aWRlIGFzIHRoZSBzcGVjaWZpZWQgY29uc3RyYWludFxuICAgICAgICAgICAgc3luY1dpZHRoID0gXy5tYXgod2lkdGhzLmNvbmNhdChjb25zdHJhaW50cy53aWR0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gVkVSVElDQUwpIHtcbiAgICAgICAgICAgIC8vIFN5bmMgd2lkdGhzIHRvIGdldCBhIGNsZWFuIGNvbHVtblxuICAgICAgICAgICAgc3luY1dpZHRoID0gXy5tYXgod2lkdGhzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzeW5jSGVpZ2h0O1xuICAgICAgICBpZiAoY29uc3RyYWludHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBJdGVtcyBtdXN0IGJlIGF0IGxlYXN0IGFzIGhpZ2ggYXMgdGhlIHNwZWNpZmllZCBjb25zdHJhaW50XG4gICAgICAgICAgICBzeW5jSGVpZ2h0ID0gXy5tYXgoaGVpZ2h0cy5jb25jYXQoY29uc3RyYWludHMuaGVpZ2h0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAvLyBTeW5jIHdpZHRocyB0byBnZXQgYSBjbGVhbiByb3dcbiAgICAgICAgICAgIHN5bmNIZWlnaHQgPSBfLm1heChoZWlnaHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zID0gXy5tYXAoaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGl0ZW0ud2lkdGggPSBzeW5jV2lkdGggfHwgd2lkdGhzW2ldO1xuICAgICAgICAgICAgaXRlbS5oZWlnaHQgPSBzeW5jSGVpZ2h0IHx8IGhlaWdodHNbaV07XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aXRlbXM6IGl0ZW1zfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTWVhc3VyZSh7d2lkdGhzOiB3aWR0aHMsIGhlaWdodHM6IGhlaWdodHN9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgcmVtZWFzdXJlSXRlbXM6IF8uZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgLy8gQ2xlYXIgaXRlbSBtZWFzdXJlbWVudHNcbiAgICAgICAgICAgIGl0ZW1zOiB0aGlzLmNsZWFySXRlbU1lYXN1cmVtZW50cyh0aGlzLnN0YXRlLml0ZW1zKVxuICAgICAgICB9LCB0aGlzLm1lYXN1cmVJdGVtcyk7XG4gICAgfSwgMjApLFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFtQUkVGSVgsIFwibGF5b3V0LVwiICsgdGhpcy5wcm9wcy5sYXlvdXRdLmpvaW4oXCIgXCIpO1xuICAgICAgICB2YXIgY2FyZHMgPSBbXTtcblxuICAgICAgICBjbGFzc05hbWUgKz0gdGhpcy5wcm9wcy5wYWRkaW5nID8gXCJcIiA6IFwiIHVucGFkZGVkXCI7XG5cbiAgICAgICAgXy5lYWNoKHRoaXMuc3RhdGUuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGksIGl0ZW1zKSB7XG4gICAgICAgICAgICB2YXIgaXNMYXN0ID0gKGkgPT09IGl0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgdmFyIGlzU3RhdGljID0gKGl0ZW0udHlwZSA9PT0gU1RBVElDIHx8IGl0ZW0udHlwZSA9PT0gRElTQUJMRUQpO1xuICAgICAgICAgICAgdmFyIG1hcmdpbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMubGF5b3V0ID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luID0gXCIwIFwiICsgdGhpcy5wcm9wcy5tYXJnaW4gKyBcInB4IDAgMFwiOyAvLyByaWdodFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmxheW91dCA9PT0gVkVSVElDQUwpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4gPSBcIjAgMCBcIiArIHRoaXMucHJvcHMubWFyZ2luICsgXCJweCAwXCI7IC8vIGJvdHRvbVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXJkcy5wdXNoKFxuICAgICAgICAgICAgICAgIERyYWdnYWJsZShcbiAgICAgICAgICAgICAgICAgICAge2NvbnRlbnQ6aXRlbS5vcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGtleTppdGVtLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTppdGVtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJlZjppdGVtLmtleSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6aXRlbS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0Oml0ZW0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46aXNMYXN0ICYmIGlzU3RhdGljID8gMCA6IG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9zaXRpb246aXRlbS5lbmRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb25SZW5kZXI6dGhpcy5yZW1lYXN1cmVJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd246Xy5iaW5kKHRoaXMub25Nb3VzZURvd24sIHRoaXMsIGl0ZW0ua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU6Xy5iaW5kKHRoaXMub25Nb3VzZU1vdmUsIHRoaXMsIGl0ZW0ua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZVVwOl8uYmluZCh0aGlzLm9uTW91c2VVcCwgdGhpcywgaXRlbS5rZXkpLFxuICAgICAgICAgICAgICAgICAgICBvbkFuaW1hdGlvbkVuZDpfLmJpbmQodGhpcy5vbkFuaW1hdGlvbkVuZCwgdGhpcywgXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmtleSl9IClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IERSQUdHSU5HIHx8IGl0ZW0udHlwZSA9PT0gQU5JTUFUSU5HKSB7XG4gICAgICAgICAgICAgICAgY2FyZHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgUGxhY2Vob2xkZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB7a2V5OlwicGxhY2Vob2xkZXJfXCIgKyBpdGVtLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcInBsYWNlaG9sZGVyX1wiICsgaXRlbS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDppdGVtLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0Oml0ZW0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOmlzTGFzdCA/IDAgOiBtYXJnaW59IClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLnVsKCB7Y2xhc3NOYW1lOmNsYXNzTmFtZX0sIFxuICAgICAgICAgICAgY2FyZHNcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgb25Nb3VzZURvd246IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvLyBTdGF0aWMgLT4gRHJhZ2dpbmdcbiAgICAgICAgdmFyIGl0ZW1zID0gXy5tYXAodGhpcy5zdGF0ZS5pdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSBEUkFHR0lORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtpdGVtczogaXRlbXN9KTtcbsKgICAgIH0sXG5cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIC8vIERyYWdnaW5nOiBSZWFycmFuZ2UgaXRlbXMgYmFzZWQgb24gZHJhZ2dhYmxlJ3MgcG9zaXRpb25cbiAgICAgICAgdmFyICRkcmFnZ2FibGUgPSAkKHRoaXMucmVmc1trZXldLmdldERPTU5vZGUoKSk7XG4gICAgICAgIHZhciAkc29ydGFibGUgPSAkKHRoaXMuZ2V0RE9NTm9kZSgpKTtcbiAgICAgICAgdmFyIGl0ZW1zID0gXy5jbG9uZSh0aGlzLnN0YXRlLml0ZW1zKTtcbiAgICAgICAgdmFyIGl0ZW0gPSBfLmZpbmRXaGVyZSh0aGlzLnN0YXRlLml0ZW1zLCB7a2V5OiBrZXl9KTtcbiAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMucHJvcHMubWFyZ2luO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gXy5pbmRleE9mKGl0ZW1zLCBpdGVtKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gMDtcblxuICAgICAgICBpdGVtcy5zcGxpY2UoY3VycmVudEluZGV4LCAxKTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5sYXlvdXQgPT09IEhPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHZhciBtaWRXaWR0aCA9ICRkcmFnZ2FibGUub2Zmc2V0KCkubGVmdCAtICRzb3J0YWJsZS5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICAgICAgdmFyIHN1bVdpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBjYXJkV2lkdGg7XG5cbiAgICAgICAgICAgIF8uZWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGNhcmRXaWR0aCA9IGl0ZW0ud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKG1pZFdpZHRoID4gc3VtV2lkdGggKyBjYXJkV2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bVdpZHRoICs9IGNhcmRXaWR0aCArIG1hcmdpbjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWlkSGVpZ2h0ID0gJGRyYWdnYWJsZS5vZmZzZXQoKS50b3AgLSAkc29ydGFibGUub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgdmFyIHN1bUhlaWdodCA9IDA7XG4gICAgICAgICAgICB2YXIgY2FyZEhlaWdodDtcblxuICAgICAgICAgICAgXy5lYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgY2FyZEhlaWdodCA9IGl0ZW0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChtaWRIZWlnaHQgPiBzdW1IZWlnaHQgKyBjYXJkSGVpZ2h0IC8gMikge1xuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW1IZWlnaHQgKz0gY2FyZEhlaWdodCArIG1hcmdpbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0luZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShuZXdJbmRleCwgMCwgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtpdGVtczogaXRlbXN9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvLyBEcmFnZ2luZyAtPiBBbmltYXRpbmdcbiAgICAgICAgdmFyIGl0ZW1zID0gXy5tYXAodGhpcy5zdGF0ZS5pdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSBBTklNQVRJTkc7XG4gICAgICAgICAgICAgICAgaXRlbS5lbmRQb3NpdGlvbiA9ICQodGhpcy5yZWZzW1wicGxhY2Vob2xkZXJfXCIgKyBrZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RE9NTm9kZSgpKS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2l0ZW1zOiBpdGVtc30pO1xuICAgIH0sXG5cbiAgICBvbkFuaW1hdGlvbkVuZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIC8vIEFuaW1hdGluZyAtPiBTdGF0aWNcbiAgICAgICAgdmFyIGl0ZW1zID0gXy5tYXAodGhpcy5zdGF0ZS5pdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPSBTVEFUSUM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aXRlbXM6IGl0ZW1zfSk7XG4gICAgfSxcblxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5wbHVjayh0aGlzLnN0YXRlLml0ZW1zLCBcIm9wdGlvblwiKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb3J0YWJsZTtcblxufSkoUGVyc2V1cyk7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cblxudmFyIHRleHRXaWR0aENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRUZXh0V2lkdGgodGV4dCkge1xuICAgIGlmICghdGV4dFdpZHRoQ2FjaGVbdGV4dF0pIHtcbiAgICAgICAgLy8gSGFja3kgd2F5IHRvIGd1ZXNzIHRoZSB3aWR0aCBvZiBhbiBpbnB1dCBib3hcbiAgICAgICAgdmFyICR0ZXN0ID0gJChcIjxzcGFuPlwiKS50ZXh0KHRleHQpLmFwcGVuZFRvKFwiYm9keVwiKTtcbiAgICAgICAgdGV4dFdpZHRoQ2FjaGVbdGV4dF0gPSAkdGVzdC53aWR0aCgpICsgNTtcbiAgICAgICAgJHRlc3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVt0ZXh0XTtcbn1cblxuXG52YXIgVGV4dExpc3RFZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdUZXh0TGlzdEVkaXRvcicsXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIG9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgbGF5b3V0OiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgICAgICBsYXlvdXQ6IFwiaG9yaXpvbnRhbFwiXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtczogdGhpcy5wcm9wcy5vcHRpb25zLmNvbmNhdChcIlwiKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gW1xuICAgICAgICAgICAgXCJwZXJzZXVzLXRleHQtbGlzdC1lZGl0b3JcIixcbiAgICAgICAgICAgIFwidWktaGVscGVyLWNsZWFyZml4XCIsXG4gICAgICAgICAgICBcImxheW91dC1cIiArIHRoaXMucHJvcHMubGF5b3V0XG4gICAgICAgIF0uam9pbihcIiBcIik7XG5cbiAgICAgICAgdmFyIGlucHV0cyA9IF8ubWFwKHRoaXMuc3RhdGUuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00ubGkoIHtrZXk6aX0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAge3JlZjpcImlucHV0X1wiICsgaSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6aXRlbSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMsIGkpLFxuICAgICAgICAgICAgICAgICAgICBvbktleURvd246dGhpcy5vbktleURvd24uYmluZCh0aGlzLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6e3dpZHRoOiBnZXRUZXh0V2lkdGgoaXRlbSl9fSApXG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLnVsKCB7Y2xhc3NOYW1lOmNsYXNzTmFtZX0sIGlucHV0cyk7XG4gICAgfSxcblxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihpbmRleCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gXy5jbG9uZSh0aGlzLnN0YXRlLml0ZW1zKTtcbiAgICAgICAgaXRlbXNbaW5kZXhdID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtpdGVtczogaXRlbXN9KTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShfLmNvbXBhY3QoaXRlbXMpKTtcbiAgICB9LFxuXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbihpbmRleCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHdoaWNoID0gZXZlbnQubmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICAgICAgICAvLyBCYWNrc3BhY2UgZGVsZXRlcyBhbiBlbXB0eSBpbnB1dC4uLlxuICAgICAgICBpZiAod2hpY2ggPT09IDggLyogYmFja3NwYWNlICovICYmIHRoaXMuc3RhdGUuaXRlbXNbaW5kZXhdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBfLmNsb25lKHRoaXMuc3RhdGUuaXRlbXMpO1xuICAgICAgICAgICAgdmFyIGZvY3VzSW5kZXggPSAoaW5kZXggPT09IDApID8gMCA6IGluZGV4IC0gMTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgIChpbmRleCA9PT0gMCB8fCBpdGVtc1tmb2N1c0luZGV4XSAhPT0gXCJcIikpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5leGNlcHQgZm9yIHRoZSBsYXN0IG9uZSwgaWZmIGl0IGlzIHRoZSBvbmx5IGVtcHR5XG4gICAgICAgICAgICAgICAgLy8gaW5wdXQgYXQgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnNbXCJpbnB1dF9cIiArIGZvY3VzSW5kZXhdLmdldERPTU5vZGUoKS5mb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2l0ZW1zOiBpdGVtc30sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnNbXCJpbnB1dF9cIiArIGZvY3VzSW5kZXhdLmdldERPTU5vZGUoKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0pOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAvLyBEZWxldGluZyB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gdGhlIHNlY29uZC10by1sYXN0IGlucHV0IHJlbW92ZXMgaXRcbiAgICAgICAgfSBlbHNlIGlmICh3aGljaCA9PT0gOCAvKiBiYWNrc3BhY2UgKi8gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLml0ZW1zW2luZGV4XS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICBpbmRleCA9PT0gdGhpcy5zdGF0ZS5pdGVtcy5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBfLmNsb25lKHRoaXMuc3RhdGUuaXRlbXMpO1xuICAgICAgICAgICAgaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2l0ZW1zOiBpdGVtc30pO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShfLmNvbXBhY3QoaXRlbXMpKTtcblxuICAgICAgICAvLyBFbnRlciBhZGRzIGFuIG9wdGlvbiBiZWxvdyB0aGUgY3VycmVudCBvbmUuLi5cbiAgICAgICAgfSBlbHNlIGlmICh3aGljaCA9PT0gMTMgLyogZW50ZXIgKi8pIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciBpdGVtcyA9IF8uY2xvbmUodGhpcy5zdGF0ZS5pdGVtcyk7XG4gICAgICAgICAgICB2YXIgZm9jdXNJbmRleCA9IGluZGV4ICsgMTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4udW5sZXNzIHRoZSBlbXB0eSBpbnB1dCBpcyBqdXN0IGJlbG93LlxuICAgICAgICAgICAgICAgIHRoaXMucmVmc1tcImlucHV0X1wiICsgZm9jdXNJbmRleF0uZ2V0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnNwbGljZShmb2N1c0luZGV4LCAwLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtpdGVtczogaXRlbXN9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW1wiaW5wdXRfXCIgKyBmb2N1c0luZGV4XS5nZXRET01Ob2RlKCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRMaXN0RWRpdG9yO1xuIiwiKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG5cbnZhciBQZXJzZXVzID0gd2luZG93LlBlcnNldXMgPSB7XG4gICAgVXRpbDogVXRpbFxufTtcblxuUGVyc2V1cy5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICAvLyBQYXNzIHNraXBNYXRoSmF4OiB0cnVlIGlmIE1hdGhKYXggaXMgYWxyZWFkeSBsb2FkZWQgYW5kIGNvbmZpZ3VyZWQuXG4gICAgICAgIHNraXBNYXRoSmF4OiBmYWxzZSxcbiAgICAgICAgLy8gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIGZpbGUgb2JqZWN0IChndWFyYW50ZWVkIHRvIGJlIGFuIGltYWdlKSBhbmRcbiAgICAgICAgLy8gYSBjYWxsYmFjaywgdGhlbiBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgdXJsIHdoZXJlIHRoZSBpbWFnZVxuICAgICAgICAvLyB3aWxsIGJlIGhvc3RlZC4gSW1hZ2UgZHJhZyBhbmQgZHJvcCBpcyBkaXNhYmxlZCB3aGVuIGltYWdlVXBsb2FkZXJcbiAgICAgICAgLy8gaXMgbnVsbC5cbiAgICAgICAgaW1hZ2VVcGxvYWRlcjogbnVsbFxuICAgIH0pO1xuXG4gICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuXG4gICAgbWFya2VkUmVhY3Quc2V0T3B0aW9ucyh7XG4gICAgICAgIHNhbml0aXplOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5za2lwTWF0aEpheCkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgTWF0aEpheC5IdWIuQ29uZmlnKHtcbiAgICAgICAgICAgIG1lc3NhZ2VTdHlsZTogXCJub25lXCIsXG4gICAgICAgICAgICBza2lwU3RhcnR1cFR5cGVzZXQ6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJIVE1MLUNTU1wiOiB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlRm9udHM6IFtcIlRlWFwiXSxcbiAgICAgICAgICAgICAgICBpbWFnZUZvbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc2NhbGU6IDEwMCxcbiAgICAgICAgICAgICAgICBzaG93TWF0aE1lbnU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE1hdGhKYXguSHViLkNvbmZpZ3VyZWQoKTtcbiAgICAgICAgTWF0aEpheC5IdWIuUXVldWUoZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgfVxuXG4gICAgUGVyc2V1cy5pbWFnZVVwbG9hZGVyID0gb3B0aW9ucy5pbWFnZVVwbG9hZGVyO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xufTtcblxufSkoKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG5yZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xucmVxdWlyZShcIi4vaXRlbS1lZGl0b3IuanN4XCIpO1xucmVxdWlyZShcIi4vaXRlbS1yZW5kZXJlci5qc3hcIik7XG5yZXF1aXJlKFwiLi9oaW50LWVkaXRvci5qc3hcIik7XG5cbnZhciBCbHVySW5wdXQgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2JsdXItaW5wdXQuanN4XCIpO1xudmFyIFByb3BDaGVja0JveCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcHJvcC1jaGVjay1ib3guanN4XCIpO1xuXG52YXIgSXRlbUVkaXRvciA9IFBlcnNldXMuSXRlbUVkaXRvcjtcbnZhciBJdGVtUmVuZGVyZXIgPSBQZXJzZXVzLkl0ZW1SZW5kZXJlcjtcbnZhciBDb21iaW5lZEhpbnRzRWRpdG9yID0gUGVyc2V1cy5Db21iaW5lZEhpbnRzRWRpdG9yO1xuXG52YXIgSnNvbkVkaXRvciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0pzb25FZGl0b3InLFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wcy52YWx1ZSwgbnVsbCwgNCksXG4gICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHNob3VsZFJlcGxhY2VDb250ZW50ID0gIXRoaXMuc3RhdGUudmFsaWQgfHxcbiAgICAgICAgICAgICFfLmlzRXF1YWwoXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICAgIEpTT04ucGFyc2UodGhpcy5zdGF0ZS5jdXJyZW50VmFsdWUpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGlmIChzaG91bGRSZXBsYWNlQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmdldEluaXRpYWxTdGF0ZSgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IFwicGVyc2V1cy1qc29uLWVkaXRvciBcIiArXG4gICAgICAgICAgICAodGhpcy5zdGF0ZS52YWxpZCA/IFwidmFsaWRcIiA6IFwiaW52YWxpZFwiKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLnRleHRhcmVhKFxuICAgICAgICAgICAge2NsYXNzTmFtZTpjbGFzc2VzLFxuICAgICAgICAgICAgdmFsdWU6dGhpcy5zdGF0ZS5jdXJyZW50VmFsdWUsXG4gICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmhhbmRsZUNoYW5nZSxcbiAgICAgICAgICAgIG9uQmx1cjp0aGlzLmhhbmRsZUJsdXJ9ICk7XG4gICAgfSxcblxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbmV4dFN0cmluZyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgLy8gU29tZSBleHRyYSBoYW5kbGluZyB0byBhbGxvdyBjb3B5LXBhc3RpbmcgZnJvbSAvYXBpL3ZpXG4gICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhqc29uKSkge1xuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBjYWxsYmFjayB1bmZvcnR1bmF0ZWx5IGNhdXNlcyBtdWx0aXBsZSByZW5kZXJzLFxuICAgICAgICAgICAgLy8gYnV0IHNlZW1zIHRvIGJlIG5lY2Vzc2FyeSB0byBhdm9pZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgICAgICAgICAvLyBiZWluZyBjYWxsZWQgYmVmb3JlIHNldFN0YXRlIGhhcyBnb25lIHRocm91Z2hcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogbmV4dFN0cmluZyxcbiAgICAgICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShqc29uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBuZXh0U3RyaW5nLFxuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlQmx1cjogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbmV4dFN0cmluZyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgLy8gU29tZSBleHRyYSBoYW5kbGluZyB0byBhbGxvdyBjb3B5LXBhc3RpbmcgZnJvbSAvYXBpL3ZpXG4gICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhqc29uKSkge1xuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBjYWxsYmFjayB1bmZvcnR1bmF0ZWx5IGNhdXNlcyBtdWx0aXBsZSByZW5kZXJzLFxuICAgICAgICAgICAgLy8gYnV0IHNlZW1zIHRvIGJlIG5lY2Vzc2FyeSB0byBhdm9pZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgICAgICAgICAvLyBiZWluZyBjYWxsZWQgYmVmb3JlIHNldFN0YXRlIGhhcyBnb25lIHRocm91Z2hcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgNCksXG4gICAgICAgICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoanNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wcy52YWx1ZSwgbnVsbCwgNCksXG4gICAgICAgICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblBlcnNldXMuRWRpdG9yUGFnZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGV2ZWxvcGVyTW9kZTogZmFsc2UsXG4gICAgICAgICAgICBqc29uTW9kZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBxdWVzdGlvbjogdGhpcy5wcm9wcy5xdWVzdGlvbixcbiAgICAgICAgICAgICAgICBhbnN3ZXI6IHRoaXMucHJvcHMuYW5zd2VyQXJlYSxcbiAgICAgICAgICAgICAgICBoaW50czogdGhpcy5wcm9wcy5oaW50c1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7aWQ6XCJwZXJzZXVzXCIsIGNsYXNzTmFtZTpcImZyYW1ld29yay1wZXJzZXVzXCJ9LCBcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZGV2ZWxvcGVyTW9kZSAmJlxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIERldmVsb3BlciBKU09OIE1vZGU6IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDp0aGlzLnByb3BzLmpzb25Nb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy50b2dnbGVKc29uTW9kZX0gKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLmRldmVsb3Blck1vZGUgJiYgdGhpcy5wcm9wcy5qc29uTW9kZSAmJlxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIEpzb25FZGl0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB7bXVsdGlMaW5lOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnN0YXRlLmpzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmNoYW5nZUpTT059IClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICghdGhpcy5wcm9wcy5kZXZlbG9wZXJNb2RlIHx8ICF0aGlzLnByb3BzLmpzb25Nb2RlKSAmJlxuICAgICAgICAgICAgICAgIEl0ZW1FZGl0b3IoXG4gICAgICAgICAgICAgICAgICAgIHtyZWY6XCJpdGVtRWRpdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyT25seTp0aGlzLnByb3BzLmpzb25Nb2RlLFxuICAgICAgICAgICAgICAgICAgICBxdWVzdGlvbjp0aGlzLnByb3BzLnF1ZXN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhbnN3ZXJBcmVhOnRoaXMucHJvcHMuYW5zd2VyQXJlYSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5oYW5kbGVDaGFuZ2V9ICksXG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgKCF0aGlzLnByb3BzLmRldmVsb3Blck1vZGUgfHwgIXRoaXMucHJvcHMuanNvbk1vZGUpICYmXG4gICAgICAgICAgICAgICAgQ29tYmluZWRIaW50c0VkaXRvcihcbiAgICAgICAgICAgICAgICAgICAge3JlZjpcImhpbnRzRWRpdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGhpbnRzOnRoaXMucHJvcHMuaGludHMsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuaGFuZGxlQ2hhbmdlfSApXG4gICAgICAgICAgICBcbiAgICAgICAgKTtcblxuICAgIH0sXG5cbiAgICB0b2dnbGVKc29uTW9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAganNvbjogdGhpcy50b0pTT04odHJ1ZSlcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICBqc29uTW9kZTogIXRoaXMucHJvcHMuanNvbk1vZGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyTW91bnROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVSZW5kZXJlcigpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcmVyKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlbmRlcmVyOiBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5qc29uTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW5kZXJlckNvbmZpZyA9IF8oe1xuICAgICAgICAgICAgaXRlbTogdGhpcy50b0pTT04odHJ1ZSksXG4gICAgICAgICAgICBpbml0aWFsSGludHNWaXNpYmxlOiAwICAvKiBub25lOyB0byBiZSBkaXNwbGF5ZWQgYmVsb3cgKi9cbiAgICAgICAgfSkuZXh0ZW5kKFxuICAgICAgICAgICAgXyh0aGlzLnByb3BzKS5waWNrKFwid29ya0FyZWFTZWxlY3RvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic29sdXRpb25BcmVhU2VsZWN0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhpbnRzQXJlYVNlbGVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcm9ibGVtTnVtXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IFJlYWN0LnJlbmRlckNvbXBvbmVudChcbiAgICAgICAgICAgIFBlcnNldXMuSXRlbVJlbmRlcmVyKHJlbmRlcmVyQ29uZmlnKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJNb3VudE5vZGUsXG4gICAgICAgICAgICBjYik7XG4gICAgfSxcblxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24odG9DaGFuZ2UsIGNiKSB7XG4gICAgICAgIHZhciBuZXdQcm9wcyA9IF8odGhpcy5wcm9wcykucGljayhcInF1ZXN0aW9uXCIsIFwiaGludHNcIiwgXCJhbnN3ZXJBcmVhXCIpO1xuICAgICAgICBfKG5ld1Byb3BzKS5leHRlbmQodG9DaGFuZ2UpO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG5ld1Byb3BzLCBjYik7XG4gICAgfSxcblxuICAgIGNoYW5nZUpTT046IGZ1bmN0aW9uKG5ld0pzb24pIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBqc29uOiBuZXdKc29uLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShuZXdKc29uKTtcbiAgICB9LFxuXG4gICAgc2NvcmVQcmV2aWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnNjb3JlSW5wdXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuanNvbk1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmpzb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXy5leHRlbmQodGhpcy5yZWZzLml0ZW1FZGl0b3IudG9KU09OKHNraXBWYWxpZGF0aW9uKSwge1xuICAgICAgICAgICAgICAgIGhpbnRzOiB0aGlzLnJlZnMuaGludHNFZGl0b3IudG9KU09OKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuLyogUmVuZGVycyBhbiBFZGl0b3JQYWdlIGFzIGEgbm9uLWNvbnRyb2xsZWQgY29tcG9uZW50LlxuICpcbiAqIE5vcm1hbGx5IHRoZSBwYXJlbnQgb2YgRWRpdG9yUGFnZSBtdXN0IHBhc3MgaXQgYW4gb25DaGFuZ2UgY2FsbGJhY2sgYW5kIHRoZW5cbiAqIHJlc3BvbmQgdG8gYW55IGNoYW5nZXMgYnkgbW9kaWZ5aW5nIHRoZSBFZGl0b3JQYWdlIHByb3BzIHRvIHJlZmxlY3QgdGhvc2VcbiAqIGNoYW5nZXMuIFdpdGggU3RhdGVmdWxFZGl0b3JQYWdlIGNoYW5nZXMgYXJlIHN0b3JlZCBpbiBzdGF0ZSBzbyB5b3UgY2FuXG4gKiBxdWVyeSB0aGVtIHdpdGggdG9KU09OLlxuICovXG5QZXJzZXVzLlN0YXRlZnVsRWRpdG9yUGFnZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGVyc2V1cy5FZGl0b3JQYWdlKHRoaXMuc3RhdGUpO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8oe30pLmV4dGVuZCh0aGlzLnByb3BzLCB7XG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UsXG4gICAgICAgICAgICByZWY6IFwiZWRpdG9yXCJcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBnZXRJbml0aWFsU3RhdGUgaXNuJ3QgY2FsbGVkIGlmIHRoZSByZWFjdCBjb21wb25lbnQgaXMgcmUtcmVuZGVyZWRcbiAgICAvLyBpbi1wbGFjZSBvbiB0aGUgZG9tLCBpbiB3aGljaCBjYXNlIHRoaXMgaXMgY2FsbGVkIGluc3RlYWQsIHNvIHdlXG4gICAgLy8gbmVlZCB0byB1cGRhdGUgdGhlIHN0YXRlIGhlcmUuXG4gICAgLy8gKFRoaXMgY29tcG9uZW50IGlzIGN1cnJlbnRseSByZS1yZW5kZXJlZCBieSB0aGUgXCJBZGQgaW1hZ2VcIiBidXR0b24uKVxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKG5leHRQcm9wcyk7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmVkaXRvci50b0pTT04oKTtcbiAgICB9LFxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24obmV3U3RhdGUsIGNiKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUsIGNiKTtcbiAgICB9LFxuICAgIHNjb3JlUHJldmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMuZWRpdG9yLnNjb3JlUHJldmlldygpO1xuICAgIH1cbn0pO1xuXG5cbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcblxudmFyIFdpZGdldHMgPSByZXF1aXJlKFwiLi93aWRnZXRzLmpzXCIpO1xudmFyIFByb3BDaGVja0JveCA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvcHJvcC1jaGVjay1ib3guanN4XCIpO1xuXG4vLyBsaWtlIFtbc25vd21hbiBpbnB1dC1udW1iZXIgMV1dXG52YXIgcldpZGdldFNwbGl0ID0gLyhcXFtcXFtcXHUyNjAzIFthLXotXSsgWzAtOV0rXFxdXFxdKS9nO1xuXG4vKiBUaGlzIGNvbXBvbmVudCBtYWtlcyBpdHMgY2hpbGRyZW4gYSBkcmFnIHRhcmdldC4gRXhhbXBsZTpcbiAqXG4gKiAgICAgPERyYWdUYXJnZXQgb25Ecm9wPXt0aGlzLmhhbmRsZURyb3B9PkRyYWcgdG8gbWU8L0RyYWdUYXJnZXQ+XG4gKlxuICogICAgIC4uLlxuICpcbiAqICAgICBoYW5kbGVEcm9wOiBmdW5jdGlvbihlKSB7XG4gKiAgICAgICAgIHRoaXMuYWRkSW1hZ2VzKGUubmF0aXZlRXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAqICAgICB9XG4gKlxuICogTm93IFwiRHJhZyB0byBtZVwiIHdpbGwgYmUgYSBkcmFnIHRhcmdldCAtIHdoZW4gc29tZXRoaW5nIGlzIGRyYWdnZWQgb3ZlciBpdCxcbiAqIHRoZSBlbGVtZW50IHdpbGwgYmVjb21lIHBhcnRpYWxseSB0cmFuc3BhcmVudCBhcyBhIHZpc3VhbCBpbmRpY2F0b3IgdGhhdFxuICogaXQncyBhIHRhcmdldC5cbiAqL1xuLy8gVE9ETyhqb2VsKSAtIGluZGljYXRlIGJlZm9yZSB0aGUgaG92ZXIgaXMgb3ZlciB0aGUgdGFyZ2V0IHRoYXQgaXQncyBwb3NzaWJsZVxuLy8gdG8gZHJhZyBpbnRvIHRoZSB0YXJnZXQuIFRoaXMgd291bGQgKEkgdGhpbmspIHJlcXVpcmUgYSBoaWdoIGxldmVsIGhhbmRsZXIgLVxuLy8gbGlrZSBvbiBQZXJzZXVzIGl0c2VsZiwgd2FpdGluZyBmb3Igb25EcmFnRW50ZXIsIHRoZW4gcGFzc2luZyBkb3duIHRoZVxuLy8gZXZlbnQuIFNvdW5kcyBsaWtlIGEgcGFpbi4gUG9zc2libGUgd29ya2Fyb3VuZCAtIGNyZWF0ZSBhIGRpdiBjb3ZlcmluZyB0aGVcbi8vIGVudGlyZSBwYWdlLi4uXG4vL1xuLy8gT3RoZXIgZXh0ZW5zaW9uczpcbi8vICogY3VzdG9tIHN0eWxlcyBmb3IgZ2xvYmFsIGRyYWcgYW5kIGRyYWdPdmVyXG4vLyAqIG9ubHkgcmVzcG9uZCB0byBjZXJ0YWluIHR5cGVzIG9mIGRyYWdzIChvbmx5IGltYWdlcyBmb3IgaW5zdGFuY2UpIVxudmFyIERyYWdUYXJnZXQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdEcmFnVGFyZ2V0JyxcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgb25Ecm9wOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgICBjb21wb25lbnQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCBjb21wb25lbnQgd2UgbmVlZCB0b1xuICAgICAgICAvLyBjYWxjdWxhdGUgaGVyZSBiZWNhdXNlIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdHJhbnNmZXJQcm9wc1RvLlxuICAgICAgICB2YXIgb3BhY2l0eSA9IHRoaXMuc3RhdGUuZHJhZ0hvdmVyID8geyBcIm9wYWNpdHlcIjogMC4zIH0gOiB7fTtcbiAgICAgICAgdmFyIHN0eWxlID0gXyhvcGFjaXR5KS5leHRlbmQodGhpcy5wcm9wcy5zdHlsZSk7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucHJvcHMuY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2ZlclByb3BzVG8oXG4gICAgICAgICAgICBjb21wb25lbnQoIHtzdHlsZTpzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgb25Ecm9wOnRoaXMuaGFuZGxlRHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgb25EcmFnRW5kOnRoaXMuaGFuZGxlRHJhZ0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgb25EcmFnT3Zlcjp0aGlzLmhhbmRsZURyYWdPdmVyLFxuICAgICAgICAgICAgICAgICAgICAgICBvbkRyYWdFbnRlcjp0aGlzLmhhbmRsZURyYWdFbnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgb25EcmFnTGVhdmU6dGhpcy5oYW5kbGVEcmFnTGVhdmV9LCBcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBkcmFnSG92ZXI6IGZhbHNlIH07XG4gICAgfSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBjb21wb25lbnQ6IFJlYWN0LkRPTS5kaXYgfTtcbiAgICB9LFxuICAgIGhhbmRsZURyb3A6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZHJhZ0hvdmVyOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkRyb3AoZSk7XG4gICAgfSxcbiAgICBoYW5kbGVEcmFnRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRyYWdIb3ZlcjogZmFsc2UgfSk7XG4gICAgfSxcbiAgICBoYW5kbGVEcmFnT3ZlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBoYW5kbGVEcmFnTGVhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZHJhZ0hvdmVyOiBmYWxzZSB9KTtcbiAgICB9LFxuICAgIGhhbmRsZURyYWdFbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBkcmFnSG92ZXI6IHRydWUgfSk7XG4gICAgfVxufSk7XG5cblxudmFyIFdpZGdldEVkaXRvciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1dpZGdldEVkaXRvcicsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyYWRlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xzID0gV2lkZ2V0cy5nZXQodGhpcy5wcm9wcy50eXBlICsgXCItZWRpdG9yXCIpO1xuXG4gICAgICAgIHZhciBpc1VuZ3JhZGVkRW5hYmxlZCA9ICh0aGlzLnByb3BzLnR5cGUgPT09IFwidHJhbnNmb3JtZXJcIik7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zdHJvbmcobnVsbCwgdGhpcy5wcm9wcy5pZClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIGlzVW5ncmFkZWRFbmFibGVkICYmXG4gICAgICAgICAgICAgICAgICAgIFByb3BDaGVja0JveChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtsYWJlbDpcIkdyYWRlZDpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRlZDp0aGlzLnByb3BzLmdyYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMucHJvcHMub25DaGFuZ2V9IClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjbHMoXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgIHJlZjogXCJ3aWRnZXRcIixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5faGFuZGxlV2lkZ2V0Q2hhbmdlXG4gICAgICAgICAgICB9LCB0aGlzLnByb3BzLm9wdGlvbnMpKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBfaGFuZGxlV2lkZ2V0Q2hhbmdlOiBmdW5jdGlvbihuZXdQcm9wcywgY2IpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICBvcHRpb25zOiBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy5vcHRpb25zLCBuZXdQcm9wcylcbiAgICAgICAgfSwgY2IpO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnByb3BzLnR5cGUsXG4gICAgICAgICAgICBncmFkZWQ6IHRoaXMucHJvcHMuZ3JhZGVkLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5yZWZzLndpZGdldC50b0pTT04oc2tpcFZhbGlkYXRpb24pXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbnZhciBFZGl0b3IgPSBQZXJzZXVzLkVkaXRvciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgIHdpZGdldHM6IHt9LFxuICAgICAgICAgICAgd2lkZ2V0RW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGltbXV0YWJsZVdpZGdldHM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzLCBwcmV2U3RhdGUsIHJvb3ROb2RlKSB7XG4gICAgICAgIC8vIFRPRE8oYWxwZXJ0KTogTWF5YmUgZml4IFJlYWN0IHNvIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IHRoaXMucmVmcy50ZXh0YXJlYS5nZXRET01Ob2RlKCk7XG4gICAgICAgIHRleHRhcmVhLnZhbHVlID0gdGhpcy5wcm9wcy5jb250ZW50O1xuICAgIH0sXG5cbiAgICBnZXRXaWRnZXRFZGl0b3I6IGZ1bmN0aW9uKGlkLCB0eXBlKSB7XG4gICAgICAgIGlmICghV2lkZ2V0cy5nZXQodHlwZSArIFwiLWVkaXRvclwiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXaWRnZXRFZGl0b3IoXy5leHRlbmQoe1xuICAgICAgICAgICAgcmVmOiBpZCxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBvbkNoYW5nZTogXy5iaW5kKHRoaXMuX2hhbmRsZVdpZGdldEVkaXRvckNoYW5nZSwgdGhpcywgaWQpXG4gICAgICAgIH0sIHRoaXMucHJvcHMud2lkZ2V0c1tpZF0pKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZVdpZGdldEVkaXRvckNoYW5nZTogZnVuY3Rpb24oaWQsIG5ld1Byb3BzLCBjYikge1xuICAgICAgICB2YXIgd2lkZ2V0cyA9IF8uY2xvbmUodGhpcy5wcm9wcy53aWRnZXRzKTtcbiAgICAgICAgd2lkZ2V0c1tpZF0gPSBfLmV4dGVuZCh7fSwgd2lkZ2V0c1tpZF0sIG5ld1Byb3BzKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7d2lkZ2V0czogd2lkZ2V0c30sIGNiKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBpZWNlcztcbiAgICAgICAgdmFyIHdpZGdldHM7XG4gICAgICAgIHZhciB1bmRlcmxheVBpZWNlcztcbiAgICAgICAgdmFyIHdpZGdldHNEcm9wRG93bjtcbiAgICAgICAgdmFyIHRlbXBsYXRlc0Ryb3BEb3duO1xuICAgICAgICB2YXIgd2lkZ2V0c0FuZFRlbXBsYXRlcztcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy53aWRnZXRFbmFibGVkKSB7XG4gICAgICAgICAgICBwaWVjZXMgPSBVdGlsLnNwbGl0KHRoaXMucHJvcHMuY29udGVudCwgcldpZGdldFNwbGl0KTtcbiAgICAgICAgICAgIHdpZGdldHMgPSB7fTtcbiAgICAgICAgICAgIHVuZGVybGF5UGllY2VzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBpICUgMjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgdGV4dFxuICAgICAgICAgICAgICAgICAgICB1bmRlcmxheVBpZWNlcy5wdXNoKHBpZWNlc1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lkZ2V0IHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBVdGlsLnJXaWRnZXRQYXJ0cy5leGVjKHBpZWNlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzJdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGFscGVydCk6XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBzZWxlY3RlZCA9IGZvY3VzZWQgJiYgc2VsU3RhcnQgPT09IHNlbEVuZCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIG9mZnNldCA8PSBzZWxTdGFydCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHNlbFN0YXJ0IDwgb2Zmc2V0ICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgc2VsZWN0ZWRXaWRnZXQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkdXBsaWNhdGUgPSBpZCBpbiB3aWRnZXRzO1xuXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHNbaWRdID0gdGhpcy5nZXRXaWRnZXRFZGl0b3IoaWQsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IChkdXBsaWNhdGUgfHwgIXdpZGdldHNbaWRdID8gXCJlcnJvciBcIiA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VsZWN0ZWQgPyBcInNlbGVjdGVkIFwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVybGF5UGllY2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmIoIHtjbGFzc05hbWU6Y2xhc3Nlc30sIHBpZWNlc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyhhbHBlcnQpOiBNb3ZlIHRoaXMgdG8gdGhlIGNvbnRlbnQtY2hhbmdlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIC8vIF8uZWFjaChfLmtleXModGhpcy5wcm9wcy53aWRnZXRzKSwgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoIShpZCBpbiB3aWRnZXRzKSkge1xuICAgICAgICAgICAgLy8gICAgICAgICAvLyBJdCdzIHN0cmFuZ2UgaWYgdGhlc2UgcHJlbG9hZGVkIG9wdGlvbnMgc3RpY2sgYXJvdW5kXG4gICAgICAgICAgICAvLyAgICAgICAgIC8vIHNpbmNlIGl0J3MgaW5jb25zaXN0ZW50IHdpdGggaG93IHRoaW5ncyB3b3JrIGlmIHlvdVxuICAgICAgICAgICAgLy8gICAgICAgICAvLyBkb24ndCBoYXZlIHRoZSBzZXJpYWxpemUvZGVzZXJpYWxpemUgc3RlcCBpbiB0aGVcbiAgICAgICAgICAgIC8vICAgICAgICAgLy8gbWlkZGxlXG4gICAgICAgICAgICAvLyAgICAgICAgIC8vIFRPRE8oYWxwZXJ0KTogU2F2ZSBvcHRpb25zIGluIGEgY29uc2lzdGVudCBtYW5uZXIgc29cbiAgICAgICAgICAgIC8vICAgICAgICAgLy8gdGhhdCB5b3UgY2FuIHVuZG8gdGhlIGRlbGV0aW9uIG9mIGEgd2lkZ2V0XG4gICAgICAgICAgICAvLyAgICAgICAgIGRlbGV0ZSB0aGlzLnByb3BzLndpZGdldHNbaWRdO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLndpZGdldElkcyA9IF8ua2V5cyh3aWRnZXRzKTtcbiAgICAgICAgICAgIHdpZGdldHNEcm9wRG93biA9ICBSZWFjdC5ET00uc2VsZWN0KCB7b25DaGFuZ2U6dGhpcy5hZGRXaWRnZXR9LCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJcIn0sIFwiQWRkIGEgd2lkZ2V0XCIsXCJcXHUyMDI2XCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHtkaXNhYmxlZDp0cnVlfSwgXCItLVwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJpbnB1dC1udW1iZXJcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgVGV4dCBpbnB1dCAobnVtYmVyKVwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJleHByZXNzaW9uXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEV4cHJlc3Npb24gLyBFcXVhdGlvblwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJyYWRpb1wifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBNdWx0aXBsZSBjaG9pY2VcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiaW50ZXJhY3RpdmUtZ3JhcGhcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgSW50ZXJhY3RpdmUgZ3JhcGhcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiaW50ZXJhY3RpdmUtbnVtYmVyLWxpbmVcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgSW50ZXJhY3RpdmUgbnVtYmVyIGxpbmVcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiY2F0ZWdvcml6YXRpb25cIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgQ2F0ZWdvcml6YXRpb25cIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwicGxvdHRlclwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBQbG90dGVyXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcInRhYmxlXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFRhYmxlIG9mIHZhbHVlc1wiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJkcm9wZG93blwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBEcm9wIGRvd25cIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwib3JkZXJlclwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBPcmRlcmVyXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcInByb3RyYWN0b3JcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgUHJvdHJhY3RvclwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJ0cmFuc2Zvcm1lclwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBUcmFuc2Zvcm1lclwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJtYXRjaGVyXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFR3byBjb2x1bW4gbWF0Y2hlclwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJzb3J0ZXJcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgU29ydGVyXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0ZW1wbGF0ZXNEcm9wRG93biA9IFJlYWN0LkRPTS5zZWxlY3QoIHtvbkNoYW5nZTp0aGlzLmFkZFRlbXBsYXRlfSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiXCJ9LCBcIkluc2VydCB0ZW1wbGF0ZVwiLFwiXFx1MjAyNlwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7ZGlzYWJsZWQ6dHJ1ZX0sIFwiLS1cIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwidGFibGVcIn0sIFwiVGFibGVcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiYWxpZ25tZW50XCJ9LCBcIkFsaWduZWQgZXF1YXRpb25zXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcInBpZWNld2lzZVwifSwgXCJQaWVjZXdpc2UgZnVuY3Rpb25cIilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5pbW11dGFibGVXaWRnZXRzKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0c0FuZFRlbXBsYXRlcyA9IFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci13aWRnZXRzXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldHNEcm9wRG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlc0Ryb3BEb3duXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldHNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5kZXJsYXlQaWVjZXMgPSBbdGhpcy5wcm9wcy5jb250ZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdpdGhvdXQgdGhpcywgdGhlIHVuZGVybGF5IGlzbid0IHRoZSBwcm9wZXIgc2l6ZSB3aGVuIHRoZSB0ZXh0IGVuZHNcbiAgICAgICAgLy8gd2l0aCBhIG5ld2xpbmUuXG4gICAgICAgIHVuZGVybGF5UGllY2VzLnB1c2goUmVhY3QuRE9NLmJyKG51bGwgKSk7XG5cbiAgICAgICAgLy8gSWYgYW4gaW1hZ2UgdXBsb2FkZXIgd2FzIHN1cHBsaWVkIGluIHRoZSBjb25maWcsIG1ha2UgdGhlIGVkaXRvciBhXG4gICAgICAgIC8vIGRyYWcgdGFyZ2V0LCBvdGhlcndpc2UgaXQncyBqdXN0IGEgZGl2LlxuICAgICAgICB2YXIgY29udGFpbmVyID0gUGVyc2V1cy5pbWFnZVVwbG9hZGVyID8gRHJhZ1RhcmdldCA6IFJlYWN0LkRPTS5kaXY7XG5cbiAgICAgICAgdmFyIGNvbXBsZXRlVGV4dGFyZWEgPSBbXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtdGV4dGFyZWEtdW5kZXJsYXlcIiwgcmVmOlwidW5kZXJsYXlcIn0sIFxuICAgICAgICAgICAgICAgICAgICB1bmRlcmxheVBpZWNlc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnRleHRhcmVhKCB7cmVmOlwidGV4dGFyZWFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25JbnB1dDp0aGlzLmhhbmRsZUlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmNvbnRlbnR9IClcbiAgICAgICAgICAgIF07XG4gICAgICAgIHZhciB0ZXh0YXJlYVdyYXBwZXI7XG4gICAgICAgIGlmIChQZXJzZXVzLmltYWdlVXBsb2FkZXIpIHtcbiAgICAgICAgICAgIHRleHRhcmVhV3JhcHBlciA9IERyYWdUYXJnZXQoIHtvbkRyb3A6dGhpcy5oYW5kbGVEcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTpcInBlcnNldXMtdGV4dGFyZWEtcGFpclwifSwgXG4gICAgICAgICAgICAgICAgY29tcGxldGVUZXh0YXJlYVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRhcmVhV3JhcHBlciA9IFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLXRleHRhcmVhLXBhaXJcIn0sIFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlVGV4dGFyZWFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtc2luZ2xlLWVkaXRvciBcIiArXG4gICAgICAgICAgICAgICAgKHRoaXMucHJvcHMuY2xhc3NOYW1lIHx8IFwiXCIpfSwgXG4gICAgICAgICAgICB0ZXh0YXJlYVdyYXBwZXIsXG4gICAgICAgICAgICB3aWRnZXRzQW5kVGVtcGxhdGVzXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGhhbmRsZURyb3A6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gZS5uYXRpdmVFdmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5wcm9wcy5jb250ZW50O1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLyogRm9yIGVhY2ggZmlsZSB3ZSBtYWtlIHN1cmUgaXQncyBhbiBpbWFnZSwgdGhlbiBjcmVhdGUgYSBzZW50aW5lbCAtXG4gICAgICAgICAqIHNub3dtYW4gKyBpZGVudGlmaWVyIHRvIGluc2VydCBpbnRvIHRoZSBjdXJyZW50IHRleHQuIFRoZSBzZW50aW5lbFxuICAgICAgICAgKiBvbmx5IGxpdmVzIHRoZXJlIHRlbXBvcmFyaWx5IHVudGlsIHdlIGdldCBhIHJlc3BvbnNlIGJhY2sgZnJvbSB0aGVcbiAgICAgICAgICogc2VydmVyIHRoYXQgdGhlIGltYWdlIGlzIG5vdyBob3N0ZWQgb24gQVdTLCBhdCB3aGljaCB0aW1lIHdlIHJlcGxhY2VcbiAgICAgICAgICogdGhlIHRlbXBvcmFyeSBzZW50aW5lbCB3aXRoIHRoZSBwZXJtYW5lbnQgdXJsIGZvciB0aGUgaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXJlIGlzIGFuIGFidXNlIG9mIHRhcCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwaXBlbGluZSB0byBtYWtlIHN1cmVcbiAgICAgICAgICogZXZlcnl0aGluZyBpcyBzZXF1ZW5jZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdlIHdhbnQgdG8gbW9kaWZ5IHRoZVxuICAgICAgICAgKiBjb250ZW50IChnaXZlbiBhbnkgbnVtYmVyIG9mIGltYWdlcykgYXQgdGhlIHNhbWUgdGltZSwgaS5lLiBvbmx5XG4gICAgICAgICAqIG9uY2UsIHNvIHdlIGRvIHRoYXQgc3RlcCB3aXRoIHRoZSB0YXAuIEFmdGVyIHRoZSBjb250ZW50IGhhcyBiZWVuXG4gICAgICAgICAqIGNoYW5nZWQgd2Ugc2VuZCBvZmYgdGhlIHJlcXVlc3QgZm9yIGVhY2ggaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgc25vd21hbiBkb2Vzbid0IGRvIGFueXRoaW5nIHNwZWNpYWwgaW4gdGhpcyBjYXNlIC1cbiAgICAgICAgICogaXQncyBlZmZlY3RpdmVseSBqdXN0IHBhcnQgb2YgYSBicm9rZW4gbGluay4gUGVyc2V1cyBjb3VsZCBiZVxuICAgICAgICAgKiBleHRlbmRlZCB0byByZWNvZ25pemUgdGhpcyBzZW50aW5lbCBhbmQgaGlnaGxpZ2h0IGl0IGxpa2UgZm9yXG4gICAgICAgICAqIHdpZGdldHMuXG4gICAgICAgICAqL1xuICAgICAgICBfKGZpbGVzKVxuICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGlmICghZmlsZS50eXBlLm1hdGNoKCdpbWFnZS4qJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNlbnRpbmVsID0gXCJcXHUyNjAzIFwiICsgXy51bmlxdWVJZChcImltYWdlX1wiKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGpvZWwpIC0gZmlndXJlIG91dCBob3cgdG8gdGVtcG9yYXJpbHkgaW5jbHVkZSB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGhlIHNlcnZlciByZXR1cm5zLlxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCJcXG5cXG4hW10oXCIgKyBzZW50aW5lbCArIFwiKVwiO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZmlsZTogZmlsZSwgc2VudGluZWw6IHNlbnRpbmVsIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlamVjdChfLmlzTnVsbClcbiAgICAgICAgICAgIC50YXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcm9wcy5vbkNoYW5nZSh7IGNvbnRlbnQ6IGNvbnRlbnQgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZmlsZUFuZFNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgUGVyc2V1cy5pbWFnZVVwbG9hZGVyKGZpbGVBbmRTZW50aW5lbC5maWxlLCBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzZWxmLnByb3BzLmNvbnRlbnQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlQW5kU2VudGluZWwuc2VudGluZWwsIHVybClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaGFuZGxlSW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLnJlZnMudGV4dGFyZWEuZ2V0RE9NTm9kZSgpO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtjb250ZW50OiB0ZXh0YXJlYS52YWx1ZX0pO1xuICAgIH0sXG5cbiAgICBhZGRXaWRnZXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHdpZGdldFR5cGUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKHdpZGdldFR5cGUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oYWxwZXJ0KTogTm90IHN1cmUgaWYgY2hhbmdlIHdpbGwgdHJpZ2dlciBoZXJlXG4gICAgICAgICAgICAvLyBidXQgbWlnaHQgYXMgd2VsbCBiZSBzYWZlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS50YXJnZXQudmFsdWUgPSBcIlwiO1xuXG4gICAgICAgIHZhciBvbGRDb250ZW50ID0gdGhpcy5wcm9wcy5jb250ZW50O1xuXG4gICAgICAgIC8vIEFkZCBuZXdsaW5lcyBiZWZvcmUgXCJiaWdcIiB3aWRnZXRzIGxpa2UgZ3JhcGhzXG4gICAgICAgIGlmICh3aWRnZXRUeXBlICE9PSBcImlucHV0LW51bWJlclwiICYmIHdpZGdldFR5cGUgIT09IFwiZHJvcGRvd25cIikge1xuICAgICAgICAgICAgb2xkQ29udGVudCA9IG9sZENvbnRlbnQucmVwbGFjZSgvXFxuKiQvLCBcIlxcblxcblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBvbGRDb250ZW50LmluZGV4T2YoXCJbW1xcdTI2MDMgXCIgKyB3aWRnZXRUeXBlICsgXCIgXCIgKyBpICtcbiAgICAgICAgICAgICAgICBcIl1dXCIpID4gLTE7IGkrKykge1xuICAgICAgICAgICAgLy8gcGFzc1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gd2lkZ2V0VHlwZSArIFwiIFwiICsgaTtcbiAgICAgICAgdmFyIG5ld0NvbnRlbnQgPSBvbGRDb250ZW50ICsgXCJbW1xcdTI2MDMgXCIgKyBpZCArIFwiXV1cIjtcblxuICAgICAgICB2YXIgd2lkZ2V0cyA9IF8uY2xvbmUodGhpcy5wcm9wcy53aWRnZXRzKTtcbiAgICAgICAgd2lkZ2V0c1tpZF0gPSB7dHlwZTogd2lkZ2V0VHlwZX07XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgY29udGVudDogbmV3Q29udGVudCxcbiAgICAgICAgICAgIHdpZGdldHM6IHdpZGdldHNcbiAgICAgICAgfSwgdGhpcy5mb2N1c0FuZE1vdmVUb0VuZCk7XG4gICAgfSxcblxuICAgIGFkZFRlbXBsYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVR5cGUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUudGFyZ2V0LnZhbHVlID0gXCJcIjtcblxuICAgICAgICB2YXIgb2xkQ29udGVudCA9IHRoaXMucHJvcHMuY29udGVudDtcblxuICAgICAgICAvLyBGb3JjZSB0ZW1wbGF0ZXMgdG8gaGF2ZSBhIGJsYW5rIGxpbmUgYmVmb3JlIHRoZW0sXG4gICAgICAgIC8vIGFzIHRoZXkgYXJlIHVzdWFsbHkgdXNlZCBhcyBibG9jayBlbGVtZW50c1xuICAgICAgICAvLyAoZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIHRhYmxlcylcbiAgICAgICAgb2xkQ29udGVudCA9IG9sZENvbnRlbnQucmVwbGFjZSgvXFxuKiQvLCBcIlxcblxcblwiKTtcblxuICAgICAgICB2YXIgdGVtcGxhdGU7XG4gICAgICAgIGlmICh0ZW1wbGF0ZVR5cGUgPT09IFwidGFibGVcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSBcImhlYWRlciAxIHwgaGVhZGVyIDIgfCBoZWFkZXIgM1xcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgXCItIHwgLSB8IC1cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YSAxIHwgZGF0YSAyIHwgZGF0YSAzXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICBcImRhdGEgNCB8IGRhdGEgNSB8IGRhdGEgNlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhIDcgfCBkYXRhIDggfCBkYXRhIDlcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZVR5cGUgPT09IFwiYWxpZ25tZW50XCIpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gXCIkXFxcXGJlZ2lue2FsaWdufSB4KzUgJj0gMzAgXFxcXFxcXFxcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgIFwieCs1LTUgJj0gMzAtNSBcXFxcXFxcXFxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgXCJ4ICY9IDI1IFxcXFxlbmR7YWxpZ259JFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlVHlwZSA9PT0gXCJwaWVjZXdpc2VcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSBcIiRmKHgpID0gXFxcXGJlZ2lue2Nhc2VzfVxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgXCI3ICYgXFxcXHRleHR7aWYgJHg9MSR9IFxcXFxcXFxcXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICBcImYoeC0xKSs1ICYgXFxcXHRleHR7aWYgJHggPiAxJH1cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgIFwiXFxcXGVuZHtjYXNlc30kXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRlbXBsYXRlIHR5cGU6IFwiICsgdGVtcGxhdGVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdDb250ZW50ID0gb2xkQ29udGVudCArIHRlbXBsYXRlO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2NvbnRlbnQ6IG5ld0NvbnRlbnR9LCB0aGlzLmZvY3VzQW5kTW92ZVRvRW5kKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICAvLyBDb3VsZCBiZSBfLnBpY2sodGhpcy5wcm9wcywgXCJjb250ZW50XCIsIFwid2lkZ2V0c1wiKTsgYnV0IHZhbGlkYXRpb24hXG4gICAgICAgIHZhciB3aWRnZXRzID0ge307XG4gICAgICAgIHZhciB3aWRnZXRJZHMgPSBfLmludGVyc2VjdGlvbih0aGlzLndpZGdldElkcywgXy5rZXlzKHRoaXMucmVmcykpO1xuXG4gICAgICAgIF8uZWFjaCh3aWRnZXRJZHMsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB3aWRnZXRzW2lkXSA9IHRoaXMucmVmc1tpZF0udG9KU09OKHNraXBWYWxpZGF0aW9uKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucHJvcHMuY29udGVudCxcbiAgICAgICAgICAgIHdpZGdldHM6IHdpZGdldHNcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnMudGV4dGFyZWEuZ2V0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgfSxcblxuICAgIGZvY3VzQW5kTW92ZVRvRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLnJlZnMudGV4dGFyZWEuZ2V0RE9NTm9kZSgpO1xuICAgICAgICB0ZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA9IHRleHRhcmVhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGV4dGFyZWEuc2VsZWN0aW9uRW5kID0gdGV4dGFyZWEudmFsdWUubGVuZ3RoO1xuICAgIH1cbn0pO1xufSkoUGVyc2V1cyk7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbihmdW5jdGlvbihQZXJzZXVzKSB7XG5cbi8qIENvbGxlY3Rpb24gb2YgY2xhc3NlcyBmb3IgcmVuZGVyaW5nIHRoZSBoaW50IGVkaXRvciBhcmVhLFxuICogaGludCBlZGl0b3IgYm94ZXMsIGFuZCBoaW50IHByZXZpZXdzXG4gKi9cblxucmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbnJlcXVpcmUoXCIuL3JlbmRlcmVyLmpzeFwiKTtcbnJlcXVpcmUoXCIuL2VkaXRvci5qc3hcIik7XG5cbnZhciBSZW5kZXJlciA9IFBlcnNldXMuUmVuZGVyZXI7XG52YXIgRWRpdG9yID0gUGVyc2V1cy5FZGl0b3I7XG5cbi8qIFJlbmRlcnMganVzdCBhIGhpbnQgcHJldmlldyAqL1xudmFyIEhpbnRSZW5kZXJlciA9IFBlcnNldXMuSGludFJlbmRlcmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaG91bGRCb2xkID0gdGhpcy5wcm9wcy5ib2xkO1xuICAgICAgICB2YXIgaGludCA9IHRoaXMucHJvcHMuaGludDtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXM7XG4gICAgICAgIGlmIChzaG91bGRCb2xkKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gXCJwZXJzZXVzLWhpbnQtcmVuZGVyZXIgbGFzdC1oaW50XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gXCJwZXJzZXVzLWhpbnQtcmVuZGVyZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpjbGFzc05hbWVzfSwgXG4gICAgICAgICAgICBSZW5kZXJlcigge2NvbnRlbnQ6dGhpcy5wcm9wcy5oaW50LmNvbnRlbnQgfHwgXCJcIn0gKVxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG4vKiBSZW5kZXJzIGEgaGludCBlZGl0b3IgYm94XG4gKlxuICogVGhpcyBpbmNsdWRlczpcbiAqICB+IHRoZSB0ZXh0YXJlYSBmb3IgdGhlIGhpbnRcbiAqICB+IHRoZSBcInJlbW92ZSB0aGlzIGhpbnRcIiBib3hcbiAqICB+IHRoZSBtb3ZlIGhpbnQgdXAvZG93biBhcnJvd3NcbiAqL1xudmFyIEhpbnRFZGl0b3IgPSBQZXJzZXVzLkhpbnRFZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWhpbnQtZWRpdG9yIHBlcnNldXMtZWRpdG9yLWxlZnQtY2VsbFwifSwgXG4gICAgICAgICAgICBFZGl0b3IoIHtyZWY6XCJlZGl0b3JcIiwgY29udGVudDp0aGlzLnByb3BzLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMucHJvcHMub25DaGFuZ2UsIHdpZGdldEVuYWJsZWQ6ZmFsc2V9ICksXG5cbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJoaW50LWNvbnRyb2xzLWNvbnRhaW5lciBjbGVhcmZpeFwifSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJyZW9yZGVyLWhpbnRzXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmEoIHtocmVmOlwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOnRoaXMucHJvcHMuaXNMYXN0ICYmIFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Nb3ZlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKX0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJpY29uLWNpcmNsZS1hcnJvdy1kb3duXCJ9IClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgJyAnLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uYSgge2hyZWY6XCIjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6dGhpcy5wcm9wcy5pc0ZpcnN0ICYmIFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Nb3ZlKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyl9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwiaWNvbi1jaXJjbGUtYXJyb3ctdXBcIn0gKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uYSgge2hyZWY6XCIjXCIsIGNsYXNzTmFtZTpcInJlbW92ZS1oaW50IHNpbXBsZS1idXR0b24gb3JhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyl9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJpY29uLXRyYXNoXCJ9ICksIFwiIFJlbW92ZSB0aGlzIGhpbnQgXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWZzLmVkaXRvci5mb2N1cygpO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMuZWRpdG9yLnRvSlNPTihza2lwVmFsaWRhdGlvbik7XG4gICAgfVxufSk7XG5cblxuLyogQSBzaW5nbGUgaGludC1yb3cgY29udGFpbmluZyBhIGhpbnQgZWRpdG9yIGFuZCBwcmV2aWV3ICovXG52YXIgQ29tYmluZWRIaW50RWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnQ29tYmluZWRIaW50RWRpdG9yJyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2hvdWxkQm9sZCA9IHRoaXMucHJvcHMuaXNMYXN0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgISgvXFwqXFwqLykudGVzdCh0aGlzLnByb3BzLmhpbnQuY29udGVudCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwicGVyc2V1cy1jb21iaW5lZC1oaW50LWVkaXRvciBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicGVyc2V1cy1lZGl0b3Itcm93XCJ9LCBcbiAgICAgICAgICAgIEhpbnRFZGl0b3IoXG4gICAgICAgICAgICAgICAge3JlZjpcImVkaXRvclwiLFxuICAgICAgICAgICAgICAgIGlzRmlyc3Q6dGhpcy5wcm9wcy5pc0ZpcnN0LFxuICAgICAgICAgICAgICAgIGlzTGFzdDp0aGlzLnByb3BzLmlzTGFzdCxcbiAgICAgICAgICAgICAgICBjb250ZW50OnRoaXMucHJvcHMuaGludC5jb250ZW50LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMucHJvcHMub25DaGFuZ2UsXG4gICAgICAgICAgICAgICAgb25SZW1vdmU6dGhpcy5wcm9wcy5vblJlbW92ZSxcbiAgICAgICAgICAgICAgICBvbk1vdmU6dGhpcy5wcm9wcy5vbk1vdmV9ICksXG5cbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci1yaWdodC1jZWxsXCJ9LCBcbiAgICAgICAgICAgICAgICBIaW50UmVuZGVyZXIoIHtoaW50OnRoaXMucHJvcHMuaGludCwgYm9sZDpzaG91bGRCb2xkfSApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5lZGl0b3IudG9KU09OKHNraXBWYWxpZGF0aW9uKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnMuZWRpdG9yLmZvY3VzKCk7XG4gICAgfVxufSk7XG5cblxuLyogQSBjZWxsIGluIHRoZSBoaW50cyB0YWJsZSB3aXRoIGNvbnRlbnQgYXBwZWFyaW5nIGluIHRoZSBsZWZ0IGNvbHVtblxuICpcbiAqIFNpbXBsaWZpZXMgaGF2aW5nIHRvIHNldCB1cCB0aGUgdGFibGUgcm93cyBhbmQgY2VsbHMgbWFudWFsbHlcbiAqIFVzZWQgZm9yIHRoZSBcIkhpbnRzOlwiIHByb21wdCBhbmQgXCJBZGQgYSBoaW50XCIgYnV0dG9uXG4gKi9cbnZhciBMZWZ0Q29sdW1uSGludHNUYWJsZUNlbGwgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdMZWZ0Q29sdW1uSGludHNUYWJsZUNlbGwnLFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiXCJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci1yb3dcIn0sIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTp0aGlzLnByb3BzLmNsYXNzTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiIHBlcnNldXMtZWRpdG9yLWxlZnQtY2VsbFwifSwgXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci1yaWdodC1jZWxsXCJ9IClcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuXG4vKiBUaGUgZW50aXJlIGhpbnRzIGVkaXRpbmcvcHJldmlldyBhcmVhXG4gKlxuICogSW5jbHVkZXM6XG4gKiAgfiBUaGUgXCJIaW50czpcIiBwcm9tcHRcbiAqICB+IEFsbCB0aGUgaGludCBlZGl0IGJveGVzLCBtb3ZlIGFuZCByZW1vdmUgYnV0dG9uc1xuICogIH4gQWxsIHRoZSBoaW50IHByZXZpZXdzXG4gKiAgfiBUaGUgXCJhZGQgYSBoaW50XCIgYnV0dG9uXG4gKi9cbnZhciBDb21iaW5lZEhpbnRzRWRpdG9yID0gUGVyc2V1cy5Db21iaW5lZEhpbnRzRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIGhpbnRzOiBbXVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGludHMgPSB0aGlzLnByb3BzLmhpbnRzO1xuICAgICAgICB2YXIgaGludEVsZW1zID0gXy5tYXAoaGludHMsIGZ1bmN0aW9uKGhpbnQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBDb21iaW5lZEhpbnRFZGl0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwiaGludEVkaXRvclwiICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTpcImhpbnRFZGl0b3JcIiArIGksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0OmkgPT09IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xhc3Q6aSArIDEgPT09IGhpbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6aGludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuaGFuZGxlSGludENoYW5nZS5iaW5kKHRoaXMsIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZW1vdmU6dGhpcy5oYW5kbGVIaW50UmVtb3ZlLmJpbmQodGhpcywgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1vdmU6dGhpcy5oYW5kbGVIaW50TW92ZS5iaW5kKHRoaXMsIGkpfSApO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtaGludHMtY29udGFpbmVyIHBlcnNldXMtZWRpdG9yLXRhYmxlXCJ9LCBcbiAgICAgICAgICAgIExlZnRDb2x1bW5IaW50c1RhYmxlQ2VsbCgge2NsYXNzTmFtZTpcInBlcnNldXMtaGludHMtdGl0bGVcIn0sIFxuICAgICAgICAgICAgICAgIFwiIEhpbnRzOiBcIlxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgaGludEVsZW1zLFxuXG4gICAgICAgICAgICBMZWZ0Q29sdW1uSGludHNUYWJsZUNlbGwoIHtjbGFzc05hbWU6XCJhZGQtaGludC1jb250YWluZXJcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5hKCB7aHJlZjpcIiNcIiwgY2xhc3NOYW1lOlwic2ltcGxlLWJ1dHRvbiBvcmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy5hZGRIaW50fSwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwiaWNvbi1wbHVzXCJ9ICksXG4gICAgICAgICAgICAgICAgICAgIFwiIEFkZCBhIGhpbnQgXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGhhbmRsZUhpbnRDaGFuZ2U6IGZ1bmN0aW9uKGksIG5ld1Byb3BzLCBjYikge1xuICAgICAgICB2YXIgaGludHMgPSBfKHRoaXMucHJvcHMuaGludHMpLmNsb25lKCk7XG4gICAgICAgIF8oaGludHNbaV0pLmV4dGVuZChuZXdQcm9wcyk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2hpbnRzOiBoaW50c30sIGNiKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlSGludFJlbW92ZTogZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaGludHMgPSBfKHRoaXMucHJvcHMuaGludHMpLmNsb25lKCk7XG4gICAgICAgIGhpbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7aGludHM6IGhpbnRzfSk7XG4gICAgfSxcblxuICAgIGhhbmRsZUhpbnRNb3ZlOiBmdW5jdGlvbihpLCBkaXIpIHtcbiAgICAgICAgdmFyIGhpbnRzID0gXyh0aGlzLnByb3BzLmhpbnRzKS5jbG9uZSgpO1xuICAgICAgICB2YXIgaGludCA9IGhpbnRzLnNwbGljZShpLCAxKVswXTtcbiAgICAgICAgaGludHMuc3BsaWNlKGkgKyBkaXIsIDAsIGhpbnQpO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtoaW50czogaGludHN9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVmc1tcImhpbnRFZGl0b3JcIiArIChpICsgZGlyKV0uZm9jdXMoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgYWRkSGludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoaW50cyA9IF8odGhpcy5wcm9wcy5oaW50cykuY2xvbmUoKS5jb25jYXQoW3sgY29udGVudDogXCJcIiB9XSk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2hpbnRzOiBoaW50c30sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBoaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5yZWZzW1wiaGludEVkaXRvclwiICsgaV0uZm9jdXMoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBUT0RPKGpvZWwpIC0gaXMgdGhpcyBkb2luZyBhbnl0aGluZz9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmhpbnRzLm1hcChmdW5jdGlvbihoaW50LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZzW1wiaGludEVkaXRvclwiICsgaV0udG9KU09OKHNraXBWYWxpZGF0aW9uKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufSk7XG5cbn0pKFBlcnNldXMpO1xuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG4oZnVuY3Rpb24oUGVyc2V1cykge1xuXG5yZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xucmVxdWlyZShcIi4vZWRpdG9yLmpzeFwiKTtcbnJlcXVpcmUoXCIuL2Fuc3dlci1hcmVhLWVkaXRvci5qc3hcIik7XG5cbnZhciBFZGl0b3IgPSBQZXJzZXVzLkVkaXRvcjtcblxudmFyIEFuc3dlckFyZWFFZGl0b3IgPSBQZXJzZXVzLkFuc3dlckFyZWFFZGl0b3I7XG5cbnZhciBJdGVtRWRpdG9yID0gUGVyc2V1cy5JdGVtRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIHF1ZXN0aW9uOiB7fSxcbiAgICAgICAgICAgIGFuc3dlckFyZWE6IHt9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIE5vdGlmeSB0aGUgcGFyZW50IHRoYXQgdGhlIHF1ZXN0aW9uIG9yIGFuc3dlciBhcmVhIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgdXBkYXRlUHJvcHM6IGZ1bmN0aW9uKG5ld1Byb3BzLCBjYikge1xuICAgICAgICB2YXIgcHJvcHMgPSBfKHRoaXMucHJvcHMpLnBpY2soXCJxdWVzdGlvblwiLCBcImFuc3dlckFyZWFcIik7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoXyhwcm9wcykuZXh0ZW5kKG5ld1Byb3BzKSwgY2IpO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtZWRpdG9yLXRhYmxlXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci1yb3cgcGVyc2V1cy1xdWVzdGlvbi1jb250YWluZXJcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci1sZWZ0LWNlbGxcIn0sIFxuICAgICAgICAgICAgICAgICAgICBFZGl0b3IoXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBcInF1ZXN0aW9uRWRpdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwicGVyc2V1cy1xdWVzdGlvbi1lZGl0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihuZXdQcm9wcywgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVlc3Rpb24gPSBfLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucXVlc3Rpb24sIG5ld1Byb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByb3BzKHtxdWVzdGlvbjogcXVlc3Rpb259LCBjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5wcm9wcy5xdWVzdGlvbikpXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci1yaWdodC1jZWxsXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2lkOlwicHJvYmxlbWFyZWFcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2lkOlwid29ya2FyZWFcIiwgY2xhc3NOYW1lOlwid29ya2FyZWFcIn0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtpZDpcImhpbnRzYXJlYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6XCJoaW50c2FyZWFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6e2Rpc3BsYXk6IFwibm9uZVwifX0gKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtZWRpdG9yLXJvdyBwZXJzZXVzLWFuc3dlci1jb250YWluZXJcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLWVkaXRvci1sZWZ0LWNlbGxcIn0sIFxuICAgICAgICAgICAgICAgICAgICBBbnN3ZXJBcmVhRWRpdG9yKF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogXCJhbnN3ZXJBcmVhRWRpdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24obmV3UHJvcHMsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuc3dlckFyZWEgPSBfLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuYW5zd2VyQXJlYSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvcHMoe2Fuc3dlckFyZWE6IGFuc3dlckFyZWF9LCBjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5wcm9wcy5hbnN3ZXJBcmVhKSlcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtZWRpdG9yLXJpZ2h0LWNlbGxcIn0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7aWQ6XCJhbnN3ZXJfYXJlYVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge2lkOlwiZXhhbXBsZXMtc2hvd1wiLCBzdHlsZTp7ZGlzcGxheTogXCJub25lXCJ9fSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgQWNjZXB0YWJsZSBmb3JtYXRzIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2lkOlwic29sdXRpb25hcmVhXCIsIGNsYXNzTmFtZTpcInNvbHV0aW9uYXJlYVwifSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImFuc3dlci1idXR0b25zXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOlwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTpcInNpbXBsZS1idXR0b24gZGlzYWJsZWQgZ3JlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6XCJDaGVjayBBbnN3ZXJcIn0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVzdGlvbjogdGhpcy5yZWZzLnF1ZXN0aW9uRWRpdG9yLnRvSlNPTihza2lwVmFsaWRhdGlvbiksXG4gICAgICAgICAgICBhbnN3ZXJBcmVhOiB0aGlzLnJlZnMuYW5zd2VyQXJlYUVkaXRvci50b0pTT04oc2tpcFZhbGlkYXRpb24pXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5xdWVzdGlvbkVkaXRvci5mb2N1cygpO1xuICAgIH1cbn0pO1xuXG59KShQZXJzZXVzKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbnJlcXVpcmUoXCIuL2Fuc3dlci1hcmVhLWVkaXRvci5qc3hcIik7XG5yZXF1aXJlKFwiLi9oaW50LWVkaXRvci5qc3hcIik7XG5yZXF1aXJlKFwiLi9yZW5kZXJlci5qc3hcIik7XG5yZXF1aXJlKFwiLi9hbGwtd2lkZ2V0cy5qc1wiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcblxudmFyIEFuc3dlckFyZWFSZW5kZXJlciA9IFBlcnNldXMuQW5zd2VyQXJlYVJlbmRlcmVyO1xuXG52YXIgSGludFJlbmRlcmVyID0gUGVyc2V1cy5IaW50UmVuZGVyZXI7XG5cbnZhciBIaW50c1JlbmRlcmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnSGludHNSZW5kZXJlcicsXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhpbnRzVmlzaWJsZSA9IHRoaXMucHJvcHMuaGludHNWaXNpYmxlO1xuICAgICAgICB2YXIgaGludHMgPSB0aGlzLnByb3BzLmhpbnRzXG4gICAgICAgICAgICAuc2xpY2UoMCwgaGludHNWaXNpYmxlID09PSAtMSA/IHVuZGVmaW5lZCA6IGhpbnRzVmlzaWJsZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaGludCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGRCb2xkID0gaSA9PT0gdGhpcy5wcm9wcy5oaW50cy5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKC9cXCpcXCovKS50ZXN0KGhpbnQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEhpbnRSZW5kZXJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9sZDpzaG91bGRCb2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6aGludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6XCJoaW50UmVuZGVyZXJcIiArIGl9ICk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdihudWxsLCBoaW50cyk7XG4gICAgfVxufSk7XG5cbnZhciBJdGVtUmVuZGVyZXIgPSBQZXJzZXVzLkl0ZW1SZW5kZXJlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5pdGlhbEhpbnRzVmlzaWJsZTogMCxcblxuICAgICAgICAgICAgLy8gVE9ETyhqb2VsKSAtIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5LiBQYXNzIGFyb3VuZCBub2RlcyBvclxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIGhhbGYgcmVhc29uYWJsZS5cbiAgICAgICAgICAgIHdvcmtBcmVhU2VsZWN0b3I6IFwiI3dvcmthcmVhXCIsXG4gICAgICAgICAgICBzb2x1dGlvbkFyZWFTZWxlY3RvcjogXCIjc29sdXRpb25hcmVhXCIsXG4gICAgICAgICAgICBoaW50c0FyZWFTZWxlY3RvcjogXCIjaGludHNhcmVhXCJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpbnRzVmlzaWJsZTogdGhpcy5wcm9wcy5pbml0aWFsSGludHNWaXNpYmxlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU2luY2UgdGhlIGl0ZW0gcmVuZGVyZXIgd29ya3MgYnkgcmVuZGVyaW5nIHRoaW5ncyBpbnRvIHRocmVlIGRpdnNcbiAgICAgICAgLy8gdGhhdCBoYXZlIGNvbXBsZXRlbHkgZGlmZmVyZW50IHBsYWNlcyBpbiB0aGUgRE9NLCB3ZSBoYXZlIHRvIGRvIHRoaXNcbiAgICAgICAgLy8gc3RyYW5nZW5lc3MgaW5zdGVhZCBvZiByZWx5aW5nIG9uIFJlYWN0J3Mgbm9ybWFsIHJlbmRlcigpIG1ldGhvZC5cbiAgICAgICAgLy8gVE9ETyhhbHBlcnQpOiBGaWd1cmUgb3V0IGhvdyB0byBjbGVhbiB0aGlzIHVwIHNvbWVob3dcbiAgICAgICAgdGhpcy5xdWVzdGlvblJlbmRlcmVyID0gUmVhY3QucmVuZGVyQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIFBlcnNldXMuUmVuZGVyZXIoXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBwcm9ibGVtTnVtOiB0aGlzLnByb3BzLnByb2JsZW1OdW1cbiAgICAgICAgICAgICAgICB9LCB0aGlzLnByb3BzLml0ZW0ucXVlc3Rpb24pKSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMucHJvcHMud29ya0FyZWFTZWxlY3RvcikpO1xuXG4gICAgICAgIHRoaXMuYW5zd2VyQXJlYVJlbmRlcmVyID0gUmVhY3QucmVuZGVyQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIEFuc3dlckFyZWFSZW5kZXJlcih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMucHJvcHMuaXRlbS5hbnN3ZXJBcmVhLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMucHJvcHMuaXRlbS5hbnN3ZXJBcmVhLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0b3I6IHRoaXMucHJvcHMuaXRlbS5hbnN3ZXJBcmVhLmNhbGN1bGF0b3IgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHByb2JsZW1OdW06IHRoaXMucHJvcHMucHJvYmxlbU51bVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5wcm9wcy5zb2x1dGlvbkFyZWFTZWxlY3RvcikpO1xuXG4gICAgICAgIHRoaXMuaGludHNSZW5kZXJlciA9IFJlYWN0LnJlbmRlckNvbXBvbmVudChcbiAgICAgICAgICAgICAgICBIaW50c1JlbmRlcmVyKHtcbiAgICAgICAgICAgICAgICAgICAgaGludHM6IHRoaXMucHJvcHMuaXRlbS5oaW50cyxcbiAgICAgICAgICAgICAgICAgICAgaGludHNWaXNpYmxlOiB0aGlzLnN0YXRlLmhpbnRzVmlzaWJsZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5wcm9wcy5oaW50c0FyZWFTZWxlY3RvcikpO1xuXG4gICAgICAgIGlmIChLaGFuLnNjcmF0Y2hwYWQpIHtcbiAgICAgICAgICAgIGlmIChfLmlzRW1wdHkodGhpcy5wcm9wcy5pdGVtLnF1ZXN0aW9uLndpZGdldHMpKSB7XG4gICAgICAgICAgICAgICAgS2hhbi5zY3JhdGNocGFkLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBLaGFuLnNjcmF0Y2hwYWQuZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KG51bGwgKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVzdGlvblJlbmRlcmVyLmZvY3VzKCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmFuc3dlckFyZWFSZW5kZXJlci5mb2N1cygpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFJlYWN0LnVubW91bnRDb21wb25lbnRBdE5vZGUoXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnByb3BzLndvcmtBcmVhU2VsZWN0b3IpKTtcbiAgICAgICAgUmVhY3QudW5tb3VudENvbXBvbmVudEF0Tm9kZShcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMucHJvcHMuc29sdXRpb25BcmVhU2VsZWN0b3IpKTtcbiAgICAgICAgUmVhY3QudW5tb3VudENvbXBvbmVudEF0Tm9kZShcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMucHJvcHMuaGludHNBcmVhU2VsZWN0b3IpKTtcbiAgICB9LFxuXG4gICAgc2hvd0hpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5oaW50c1Zpc2libGUgPCB0aGlzLmdldE51bUhpbnRzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGhpbnRzVmlzaWJsZTogdGhpcy5zdGF0ZS5oaW50c1Zpc2libGUgKyAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXROdW1IaW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLml0ZW0uaGludHMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBzY29yZUlucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHFHdWVzc0FuZFNjb3JlID0gdGhpcy5xdWVzdGlvblJlbmRlcmVyLmd1ZXNzQW5kU2NvcmUoKTtcbiAgICAgICAgdmFyIGFHdWVzc0FuZFNjb3JlID0gdGhpcy5hbnN3ZXJBcmVhUmVuZGVyZXIuZ3Vlc3NBbmRTY29yZSgpO1xuXG4gICAgICAgIHZhciBxR3Vlc3MgPSBxR3Vlc3NBbmRTY29yZVswXSwgcVNjb3JlID0gcUd1ZXNzQW5kU2NvcmVbMV07XG4gICAgICAgIHZhciBhR3Vlc3MgPSBhR3Vlc3NBbmRTY29yZVswXSwgYVNjb3JlID0gYUd1ZXNzQW5kU2NvcmVbMV07XG5cbiAgICAgICAgdmFyIGd1ZXNzLCBzY29yZTtcbiAgICAgICAgaWYgKHFHdWVzcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIHdpZGdldHMgaW4gcXVlc3Rpb24uIEZvciBjb21wYXRhYmlsaXR5IHdpdGggb2xkIGd1ZXNzIGZvcm1hdCxcbiAgICAgICAgICAgIC8vIGxlYXZlIGl0IG91dCBoZXJlIGNvbXBsZXRlbHkuXG4gICAgICAgICAgICBndWVzcyA9IGFHdWVzcztcbiAgICAgICAgICAgIHNjb3JlID0gYVNjb3JlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3Vlc3MgPSBbcUd1ZXNzLCBhR3Vlc3NdO1xuICAgICAgICAgICAgc2NvcmUgPSBVdGlsLmNvbWJpbmVTY29yZXMocVNjb3JlLCBhU2NvcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjb3JlLnR5cGUgPT09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvcnJlY3Q6IHNjb3JlLmVhcm5lZCA+PSBzY29yZS50b3RhbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY29yZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGd1ZXNzOiBndWVzc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzY29yZS50eXBlID09PSBcImludmFsaWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb3JyZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY29yZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGd1ZXNzOiBndWVzc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG59KShQZXJzZXVzKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcblxudmFyIFRlWCA9IHJlcXVpcmUoXCIuL3RleC5qc3hcIik7XG52YXIgV2lkZ2V0cyA9IHJlcXVpcmUoXCIuL3dpZGdldHMuanNcIik7XG5cbnZhciBSZW5kZXJlciA9IFBlcnNldXMuUmVuZGVyZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSkge1xuICAgICAgICAgICAgLy8gVE9ETyhqYWNrKTogSW52ZXN0aWdhdGUgd2h5IHRoaXMgaXMgaGFwcGVuaW5nIHdoZW5cbiAgICAgICAgICAgIC8vIGEgaGludCBpcyB0YWtlbiwgYW5kIHN0b3AgcmVzZXR0aW5nIHRoZSB3aWRnZXRzIGluXG4gICAgICAgICAgICAvLyB0aGF0IGNpcmN1bXN0YW5jZSwgZWl0aGVyIGJ5IG1ha2luZyB0aGlzIGNoZWNrIG1vcmVcbiAgICAgICAgICAgIC8vIGxlbmllbnQsIG9yIGJ5IG5vdCBtb2RpZnlpbmcgdGhlIGFuc3dlciBhcmVhJ3NcbiAgICAgICAgICAgIC8vIHJlbmRlcmVyIHByb3BzIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7d2lkZ2V0czoge319KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgIGlnbm9yZU1pc3NpbmdXaWRnZXRzOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9uUmVuZGVyIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgcGVyIHJlbmRlciwgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBpbWFnZXMgb3IgVGVYIHBpZWNlcyB3aXRoaW4gYGNvbnRlbnRgLlxuICAgICAgICAgICAgLy8gSXQgaXMgYSBnb29kIGlkZWEgdG8gZGVib3VuY2UgYW55IGZ1bmN0aW9ucyBwYXNzZWQgaGVyZS5cbiAgICAgICAgICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHt9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE8oYWxwZXJ0KTogTW92ZSB1cCB0byBwYXJlbnQgcHJvcHM/XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWRnZXRzOiB7fVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIHZhciBzdGF0ZUNoYW5nZWQgPSAhXy5pc0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgIHZhciBwcm9wc0NoYW5nZWQgPSAhXy5pc0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG4gICAgICAgIHJldHVybiBwcm9wc0NoYW5nZWQgfHwgc3RhdGVDaGFuZ2VkO1xuICAgIH0sXG5cbiAgICBnZXRQaWVjZTogZnVuY3Rpb24oc2F2ZWQsIHdpZGdldElkcykge1xuICAgICAgICBpZiAoc2F2ZWQuY2hhckF0KDApID09PSBcIkBcIikge1xuICAgICAgICAgICAgLy8gSnVzdCB0ZXh0XG4gICAgICAgICAgICByZXR1cm4gc2F2ZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2F2ZWQuY2hhckF0KDApID09PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gTWF0aFxuICAgICAgICAgICAgdmFyIHRleCA9IHNhdmVkLnNsaWNlKDEsIHNhdmVkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIFRlWCgge29uUmVuZGVyOnRoaXMucHJvcHMub25SZW5kZXJ9LCB0ZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNhdmVkLmNoYXJBdCgwKSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgIC8vIFdpZGdldFxuICAgICAgICAgICAgdmFyIG1hdGNoID0gVXRpbC5yV2lkZ2V0UGFydHMuZXhlYyhzYXZlZCk7XG4gICAgICAgICAgICB2YXIgaWQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMl07XG5cbiAgICAgICAgICAgIHZhciB3aWRnZXRJbmZvID0gKHRoaXMucHJvcHMud2lkZ2V0cyB8fCB7fSlbaWRdO1xuICAgICAgICAgICAgaWYgKHdpZGdldEluZm8gfHwgdGhpcy5wcm9wcy5pZ25vcmVNaXNzaW5nV2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIHdpZGdldElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xzID0gV2lkZ2V0cy5nZXQodHlwZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2xzKF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKG5ld1Byb3BzLCBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGdldHMgPSBfLmNsb25lKHRoaXMuc3RhdGUud2lkZ2V0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXRzW2lkXSA9IF8uZXh0ZW5kKHt9LCB3aWRnZXRzW2lkXSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7d2lkZ2V0czogd2lkZ2V0c30sIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfSwgKHdpZGdldEluZm8gfHwge30pLm9wdGlvbnMsIHRoaXMuc3RhdGUud2lkZ2V0c1tpZF0sXG4gICAgICAgICAgICAgICAgXy5waWNrKHRoaXMucHJvcHMsIFwicHJvYmxlbU51bVwiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGV4dHJhY3RlZCA9IGV4dHJhY3RNYXRoQW5kV2lkZ2V0cyh0aGlzLnByb3BzLmNvbnRlbnQpO1xuICAgICAgICB2YXIgbWFya2Rvd24gPSBleHRyYWN0ZWRbMF07XG4gICAgICAgIHZhciBzYXZlZE1hdGggPSBleHRyYWN0ZWRbMV07XG4gICAgICAgIHZhciB3aWRnZXRJZHMgPSB0aGlzLndpZGdldElkcyA9IFtdO1xuXG4gICAgICAgIC8vIFhYWChhbHBlcnQpOiBzbWFydHlwYW50cyBnZXRzIGNhbGxlZCBvbiBlYWNoIHRleHQgbm9kZSBiZWZvcmUgaXQnc1xuICAgICAgICAvLyBhZGRlZCB0byB0aGUgRE9NIHRyZWUsIHNvIHdlIG92ZXJyaWRlIGl0IHRvIGluc2VydCB0aGUgbWF0aCBhbmRcbiAgICAgICAgLy8gd2lkZ2V0cy5cbiAgICAgICAgdmFyIHNtYXJ0eXBhbnRzID0gbWFya2VkUmVhY3QuSW5saW5lTGV4ZXIucHJvdG90eXBlLnNtYXJ0eXBhbnRzO1xuICAgICAgICBtYXJrZWRSZWFjdC5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcGllY2VzID0gVXRpbC5zcGxpdCh0ZXh0LCAvQEAoXFxkKylAQC9nKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBpICUgMjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXNbaV0gPSBzbWFydHlwYW50cy5jYWxsKHRoaXMsIHBpZWNlc1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc2F2ZWQgbWF0aC1vci13aWRnZXQgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIHBpZWNlc1tpXSA9IHNlbGYuZ2V0UGllY2Uoc2F2ZWRNYXRoW3BpZWNlc1tpXV0sIHdpZGdldElkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBpZWNlcztcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYobnVsbCwgbWFya2VkUmVhY3QobWFya2Rvd24pKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSUU4IHJlcXVpcmVzIGBjYXRjaGAgaW4gb3JkZXIgdG8gdXNlIGBmaW5hbGx5YFxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIG1hcmtlZFJlYWN0LklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IHNtYXJ0eXBhbnRzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvblJlbmRlciA9IHRoaXMucHJvcHMub25SZW5kZXI7XG5cbiAgICAgICAgLy8gRmlyZSBjYWxsYmFjayBvbiBpbWFnZSBsb2FkLi4uXG4gICAgICAgICQodGhpcy5nZXRET01Ob2RlKCkpLmZpbmQoXCJpbWdcIikub24oXCJsb2FkXCIsIG9uUmVuZGVyKTtcblxuICAgICAgICAvLyAuLi5hcyB3ZWxsIGFzIHJpZ2h0IG5vdyAobm9uLWltYWdlLCBub24tVGVYIG9yIGltYWdlIGZyb20gY2FjaGUpXG4gICAgICAgIG9uUmVuZGVyKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVSZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVSZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgXy5zb21lIHRvIGJyZWFrIGlmIGFueSB3aWRnZXQgZ2V0cyBmb2N1c2VkXG4gICAgICAgIHZhciBmb2N1c2VkID0gXy5zb21lKHRoaXMud2lkZ2V0SWRzLCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICByZXR1cm4gd2lkZ2V0LmZvY3VzICYmIHdpZGdldC5mb2N1cygpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICAgICAgXy5lYWNoKHRoaXMucHJvcHMud2lkZ2V0cywgZnVuY3Rpb24ocHJvcHMsIGlkKSB7XG4gICAgICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5yZWZzW2lkXTtcbiAgICAgICAgICAgIHZhciBzID0gd2lkZ2V0LnRvSlNPTihza2lwVmFsaWRhdGlvbik7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlW2lkXSA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcblxuICAgIGd1ZXNzQW5kU2NvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2lkZ2V0UHJvcHMgPSB0aGlzLnByb3BzLndpZGdldHM7XG5cbiAgICAgICAgdmFyIHRvdGFsR3Vlc3MgPSBfLm1hcCh0aGlzLndpZGdldElkcywgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnNbaWRdLnRvSlNPTigpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB2YXIgdG90YWxTY29yZSA9IF8uY2hhaW4odGhpcy53aWRnZXRJZHMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB3aWRnZXRQcm9wc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BzLmdyYWRlZCBpcyB1bnNldCBvciB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5ncmFkZWQgPT0gbnVsbCB8fCBwcm9wcy5ncmFkZWQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHdpZGdldFByb3BzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aWRnZXQuc2ltcGxlVmFsaWRhdGUocHJvcHMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgICAgICAucmVkdWNlKFV0aWwuY29tYmluZVNjb3JlcywgVXRpbC5ub1Njb3JlKVxuICAgICAgICAgICAgICAgIC52YWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiBbdG90YWxHdWVzcywgdG90YWxTY29yZV07XG4gICAgfSxcblxuICAgIGV4YW1wbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdpZGdldHMgPSBfLnZhbHVlcyh0aGlzLnJlZnMpO1xuICAgICAgICB2YXIgZXhhbXBsZXMgPSBfLmNvbXBhY3QoXy5tYXAod2lkZ2V0cywgZnVuY3Rpb24od2lkZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkZ2V0LmV4YW1wbGVzID8gd2lkZ2V0LmV4YW1wbGVzKCkgOiBudWxsO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gbm8gd2lkZ2V0cyB3aXRoIGV4YW1wbGVzXG4gICAgICAgIGlmICghZXhhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGxFcXVhbCA9IF8uYWxsKGV4YW1wbGVzLCBmdW5jdGlvbihleGFtcGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pc0VxdWFsKGV4YW1wbGVzWzBdLCBleGFtcGxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc29tZSB3aWRnZXRzIGhhdmUgZGlmZmVyZW50IGV4YW1wbGVzXG4gICAgICAgIC8vIFRPRE8oYWxleCk6IGhhbmRsZSB0aGlzIGJldHRlclxuICAgICAgICBpZiAoIWFsbEVxdWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGFtcGxlc1swXTtcbiAgICB9XG59KTtcblxudmFyIHJJbnRlcmVzdGluZyA9XG4gICAgICAgIC8oXFwkfFt7fV18XFxcXFtcXFxcJHt9XXxcXG57Mix9fFxcW1xcW1xcdTI2MDMgW2Etei1dKyBbMC05XStcXF1cXF18QEBcXGQrQEApL2c7XG5cbmZ1bmN0aW9uIGV4dHJhY3RNYXRoQW5kV2lkZ2V0cyh0ZXh0KSB7XG4gICAgLy8gXCIkeCQgaXMgYSBjb29sIG51bWJlciwganVzdCBsaWtlICQ2ICogNyQhXCIgZ2l2ZXNcbiAgICAvLyAgICAgW1wiQEAwQEAgaXMgYSBjb29sIG51bWJlciwganVzdCBsaWtlIEBAMUBAIVwiLCBbXCIkeCRcIiwgXCIkNiAqIDckXCJdXVxuICAgIC8vXG4gICAgLy8gSW5zcGlyZWQgYnkgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTEyMzEwMzAuXG4gICAgdmFyIHNhdmVkTWF0aCA9IFtdO1xuICAgIHZhciBibG9ja3MgPSBVdGlsLnNwbGl0KHRleHQsIHJJbnRlcmVzdGluZyk7XG5cbiAgICB2YXIgbWF0aFBpZWNlcyA9IFtdLCBsID0gYmxvY2tzLmxlbmd0aCwgYmxvY2ssIGJyYWNlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBibG9jayA9IGJsb2Nrc1tpXTtcblxuICAgICAgICBpZiAobWF0aFBpZWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIExvb2tpbmcgZm9yIGFuIGVuZCBkZWxpbWV0ZXJcbiAgICAgICAgICAgIG1hdGhQaWVjZXMucHVzaChibG9jayk7XG4gICAgICAgICAgICBibG9ja3NbaV0gPSBcIlwiO1xuXG4gICAgICAgICAgICBpZiAoYmxvY2sgPT09IFwiJFwiICYmIGJyYWNlcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2ldID0gc2F2ZU1hdGgobWF0aFBpZWNlcy5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICBtYXRoUGllY2VzID0gW107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLnNsaWNlKDAsIDIpID09PSBcIlxcblxcblwiIHx8IGkgPT09IGwgLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuLi4ganVzdCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oYWxwZXJ0KTogRXJyb3Igc29tZWhvdz9cbiAgICAgICAgICAgICAgICBibG9ja3NbaV0gPSBtYXRoUGllY2VzLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgbWF0aFBpZWNlcyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jayA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2VzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIExvb2tpbmcgZm9yIGEgc3RhcnQgZGVsaW1ldGVyXG4gICAgICAgICAgICB2YXIgdHdvID0gYmxvY2sgJiYgYmxvY2suc2xpY2UoMCwgMik7XG4gICAgICAgICAgICBpZiAodHdvID09PSBcIltbXCIgfHwgdHdvID09PSBcIkBAXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHdpZGdldCBvciBhbiBAQG5AQCB0aGluZyAod2hpY2ggd2UgcHVsbCBvdXQgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBnZXQgY29uZnVzZWQgbGF0ZXIpLlxuICAgICAgICAgICAgICAgIGJsb2Nrc1tpXSA9IHNhdmVNYXRoKGJsb2NrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sgPT09IFwiJFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ290IG9uZSEgU2F2ZSBpdCBmb3IgbGF0ZXIgYW5kIGJsYW5rIG91dCBpdHMgc3BhY2UuXG4gICAgICAgICAgICAgICAgbWF0aFBpZWNlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBibG9ja3NbaV0gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGJyYWNlcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbHNlLCBqdXN0IG5vcm1hbCB0ZXh0LiBNb3ZlIGFsb25nLCBtb3ZlIGFsb25nLlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtibG9ja3Muam9pbihcIlwiKSwgc2F2ZWRNYXRoXTtcblxuICAgIGZ1bmN0aW9uIHNhdmVNYXRoKG1hdGgpIHtcbiAgICAgICAgc2F2ZWRNYXRoLnB1c2gobWF0aCk7XG4gICAgICAgIHJldHVybiBcIkBAXCIgKyAoc2F2ZWRNYXRoLmxlbmd0aCAtIDEpICsgXCJAQFwiO1xuICAgIH1cbn1cblxuUmVuZGVyZXIuZXh0cmFjdE1hdGhBbmRXaWRnZXRzID0gZXh0cmFjdE1hdGhBbmRXaWRnZXRzO1xuXG59KShQZXJzZXVzKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuLyoqXG4gKiBGb3IgbWF0aCByZW5kZXJlZCB1c2luZyBNYXRoSmF4LiBVc2UgbWUgbGlrZSA8VGVYPjJ4ICsgMzwvVGVYPi5cbiAqL1xuXG5yZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xuXG4vLyBUT0RPKGphY2spOiBSZW1vdmUgdGhpcyBjbG9zdXJlIG5vdyB0aGF0IHRoaXMgaXMgaW4gaXQncyBvd24gZmlsZVxudmFyIFRlWCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgcGVuZGluZ1NjcmlwdHMgPSBbXTtcbiAgICB2YXIgbmVlZHNQcm9jZXNzID0gZmFsc2U7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gcHJvY2VzcyhzY3JpcHQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHBlbmRpbmdTY3JpcHRzLnB1c2goc2NyaXB0KTtcbiAgICAgICAgaWYgKCFuZWVkc1Byb2Nlc3MpIHtcbiAgICAgICAgICAgIG5lZWRzUHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkb1Byb2Nlc3MsIDAsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvUHJvY2VzcyhjYWxsYmFjaykge1xuICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvbGRFbGVtZW50U2NyaXB0cyA9IE1hdGhKYXguSHViLmVsZW1lbnRTY3JpcHRzO1xuICAgICAgICAgICAgTWF0aEpheC5IdWIuZWxlbWVudFNjcmlwdHMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBwZW5kaW5nU2NyaXB0cztcbiAgICAgICAgICAgICAgICBwZW5kaW5nU2NyaXB0cyA9IFtdO1xuICAgICAgICAgICAgICAgIG5lZWRzUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aEpheC5IdWIuUHJvY2VzcyhudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gSUU4IHJlcXVpcmVzIGBjYXRjaGAgaW4gb3JkZXIgdG8gdXNlIGBmaW5hbGx5YFxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIE1hdGhKYXguSHViLmVsZW1lbnRTY3JpcHRzID0gb2xkRWxlbWVudFNjcmlwdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIENhbGxlZCBhZnRlciBtYXRoIGlzIHJlbmRlcmVkIG9yIHJlLXJlbmRlcmVkXG4gICAgICAgICAgICAgICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00uc3BhbihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge3JlZjpcIm1hdGhqYXhcIn0gKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge3JlZjpcImthdGV4XCJ9IClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKHNwYW4pIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBvblJlbmRlciA9IHRoaXMucHJvcHMub25SZW5kZXI7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRXhlcmNpc2VzID09PSBcInVuZGVmaW5lZFwiIHx8IEV4ZXJjaXNlcy51c2VLYXRleCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrYXRleEhvbGRlciA9IHRoaXMucmVmcy5rYXRleC5nZXRET01Ob2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGthdGV4LnByb2Nlc3ModGV4dCwga2F0ZXhIb2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICBvblJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcxMDMgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuX19wcm90b19fICE9PSBrYXRleC5QYXJzZUVycm9yLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgK1cxMDMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U2NyaXB0VGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIHByb2Nlc3ModGhpcy5zY3JpcHQsIG9uUmVuZGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcywgcHJldlN0YXRlLCBzcGFuKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IHByZXZQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBuZXdUZXh0ID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBvblJlbmRlciA9IHRoaXMucHJvcHMub25SZW5kZXI7XG5cbiAgICAgICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFeGVyY2lzZXMgPT09IFwidW5kZWZpbmVkXCIgfHwgRXhlcmNpc2VzLnVzZUthdGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2F0ZXhIb2xkZXIgPSB0aGlzLnJlZnMua2F0ZXguZ2V0RE9NTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2F0ZXgucHJvY2VzcyhuZXdUZXh0LCBrYXRleEhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgamF4ID0gTWF0aEpheC5IdWIuZ2V0SmF4Rm9yKHRoaXMuc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoamF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpheC5SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcxMDMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLl9fcHJvdG9fXyAhPT0ga2F0ZXguUGFyc2VFcnJvci5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCArVzEwMyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMucmVmcy5rYXRleC5nZXRET01Ob2RlKCkpLmVtcHR5KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIE1hdGhKYXguSHViLlF1ZXVlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpheCA9IE1hdGhKYXguSHViLmdldEpheEZvcihjb21wb25lbnQuc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gamF4LlRleHQobmV3VGV4dCwgb25SZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuc2V0U2NyaXB0VGV4dChuZXdUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGNvbXBvbmVudC5zY3JpcHQsIG9uUmVuZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTY3JpcHRUZXh0KG5ld1RleHQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHRoaXMuc2NyaXB0LCBvblJlbmRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNjcmlwdFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JpcHQudHlwZSA9IFwibWF0aC90ZXhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnMubWF0aGpheC5nZXRET01Ob2RlKCkuYXBwZW5kQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwidGV4dFwiIGluIHRoaXMuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgLy8gSUU4LCBldGNcbiAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdC50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JpcHQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHZhciBqYXggPSBNYXRoSmF4Lkh1Yi5nZXRKYXhGb3IodGhpcy5zY3JpcHQpO1xuICAgICAgICAgICAgICAgIGlmIChqYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgamF4LlJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZVg7XG5cbiIsInZhciBVdGlsID0ge1xuICAgIHJXaWRnZXRQYXJ0czogL15cXFtcXFtcXHUyNjAzICgoW2Etei1dKykgKFswLTldKykpXFxdXFxdJC8sXG5cbiAgICBub1Njb3JlOiB7XG4gICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgIGVhcm5lZDogMCxcbiAgICAgICAgdG90YWw6IDAsXG4gICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICB9LFxuXG4gICAgc2VlZGVkUk5HOiBmdW5jdGlvbihzZWVkKSB7XG4gICAgICAgIHZhciByYW5kb21TZWVkID0gc2VlZDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSb2JlcnQgSmVua2lucycgMzIgYml0IGludGVnZXIgaGFzaCBmdW5jdGlvbi5cbiAgICAgICAgICAgIHZhciBzZWVkID0gcmFuZG9tU2VlZDtcbiAgICAgICAgICAgIHNlZWQgPSAoKHNlZWQgKyAweDdlZDU1ZDE2KSArIChzZWVkIDw8IDEyKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgc2VlZCA9ICgoc2VlZCBeIDB4Yzc2MWMyM2MpIF4gKHNlZWQgPj4+IDE5KSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgc2VlZCA9ICgoc2VlZCArIDB4MTY1NjY3YjEpICsgKHNlZWQgPDwgNSkpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIHNlZWQgPSAoKHNlZWQgKyAweGQzYTI2NDZjKSBeIChzZWVkIDw8IDkpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBzZWVkID0gKChzZWVkICsgMHhmZDcwNDZjNSkgKyAoc2VlZCA8PCAzKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgc2VlZCA9ICgoc2VlZCBeIDB4YjU1YTRmMDkpIF4gKHNlZWQgPj4+IDE2KSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgcmV0dXJuIChyYW5kb21TZWVkID0gKHNlZWQgJiAweGZmZmZmZmYpKSAvIDB4MTAwMDAwMDA7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIFNodWZmbGUgYW4gYXJyYXkgdXNpbmcgYSBnaXZlbiByYW5kb20gc2VlZCBvciBmdW5jdGlvbi5cbiAgICAvLyBJZiBgZW5zdXJlUGVybXV0ZWRgIGlzIHRydWUsIHRoZSBpbnB1dCBhbmQgb3VwdXQgYXJlIGd1YXJhbnRlZWQgdG8gYmVcbiAgICAvLyBkaXN0aW5jdCBwZXJtdXRhdGlvbnMuXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyYXksIHJhbmRvbVNlZWQsIGVuc3VyZVBlcm11dGVkKSB7XG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnB1dCBhcnJheVxuICAgICAgICB2YXIgc2h1ZmZsZWQgPSBfLmNsb25lKGFycmF5KTtcblxuICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlcyAoaW5wdXQgYXJyYXkgaXMgZW1wdHkgb3IgdW5pZm9ybSlcbiAgICAgICAgaWYgKCFzaHVmZmxlZC5sZW5ndGggfHwgXy5hbGwoc2h1ZmZsZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5pc0VxdWFsKHZhbHVlLCBzaHVmZmxlZFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZG9tO1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHJhbmRvbVNlZWQpKSB7XG4gICAgICAgICAgICByYW5kb20gPSByYW5kb21TZWVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZG9tID0gVXRpbC5zZWVkZWRSTkcocmFuZG9tU2VlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBGaXNjaGVyLVlhdGVzIHNodWZmbGVcbiAgICAgICAgICAgIGZvciAodmFyIHRvcCA9IHNodWZmbGVkLmxlbmd0aDsgdG9wID4gMDsgdG9wLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RW5kID0gTWF0aC5mbG9vcihyYW5kb20oKSAqIHRvcCksXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBzaHVmZmxlZFtuZXdFbmRdO1xuXG4gICAgICAgICAgICAgICAgc2h1ZmZsZWRbbmV3RW5kXSA9IHNodWZmbGVkW3RvcCAtIDFdO1xuICAgICAgICAgICAgICAgIHNodWZmbGVkW3RvcCAtIDFdID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZW5zdXJlUGVybXV0ZWQgJiYgXy5pc0VxdWFsKGFycmF5LCBzaHVmZmxlZCkpO1xuXG4gICAgICAgIHJldHVybiBzaHVmZmxlZDtcbiAgICB9LFxuXG4gICAgLy8gSW4gSUU4LCBzcGxpdCBkb2Vzbid0IHdvcmsgcmlnaHQuIEltcGxlbWVudCBpdCBvdXJzZWx2ZXMuXG4gICAgc3BsaXQ6IFwieFwiLnNwbGl0KC8oLikvZykubGVuZ3RoID9cbiAgICAgICAgZnVuY3Rpb24oc3RyLCByKSB7IHJldHVybiBzdHIuc3BsaXQocik7IH0gOlxuICAgICAgICBmdW5jdGlvbihzdHIsIHIpIHtcbiAgICAgICAgICAgIC8vIEJhc2VkIG9uIFN0ZXZlbiBMZXZpdGhhbidzIE1JVC1saWNlbnNlZCBzcGxpdCwgYXZhaWxhYmxlIGF0XG4gICAgICAgICAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHIubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHIuZXhlYyhzdHIpKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0d28gc2NvcmUgb2JqZWN0cyBmb3IgdHdvIGRpZmZlcmVudCB3aWRnZXRzLCBjb21iaW5lIHRoZW0gc28gdGhhdFxuICAgICAqIGlmIG9uZSBpcyB3cm9uZywgdGhlIHRvdGFsIHNjb3JlIGlzIHdyb25nLCBldGMuXG4gICAgICovXG4gICAgY29tYmluZVNjb3JlczogZnVuY3Rpb24oc2NvcmVBLCBzY29yZUIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKHNjb3JlQS50eXBlID09PSBcInBvaW50c1wiICYmIHNjb3JlQi50eXBlID09PSBcInBvaW50c1wiKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmVBLm1lc3NhZ2UgJiYgc2NvcmVCLm1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVBLm1lc3NhZ2UgIT09IHNjb3JlQi5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbHBlcnQpOiBGaWd1cmUgb3V0IGhvdyB0byBjb21iaW5lIG1lc3NhZ2VzIHVzZWZ1bGx5XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzY29yZUEubWVzc2FnZSB8fCBzY29yZUIubWVzc2FnZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgIGVhcm5lZDogc2NvcmVBLmVhcm5lZCArIHNjb3JlQi5lYXJuZWQsXG4gICAgICAgICAgICAgICAgdG90YWw6IHNjb3JlQS50b3RhbCArIHNjb3JlQi50b3RhbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2NvcmVBLnR5cGUgPT09IFwicG9pbnRzXCIgJiYgc2NvcmVCLnR5cGUgPT09IFwiaW52YWxpZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcmVCO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2NvcmVBLnR5cGUgPT09IFwiaW52YWxpZFwiICYmIHNjb3JlQi50eXBlID09PSBcInBvaW50c1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcmVBO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2NvcmVBLnR5cGUgPT09IFwiaW52YWxpZFwiICYmIHNjb3JlQi50eXBlID09PSBcImludmFsaWRcIikge1xuICAgICAgICAgICAgaWYgKHNjb3JlQS5tZXNzYWdlICYmIHNjb3JlQi5tZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlQS5tZXNzYWdlICE9PSBzY29yZUIubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oYWxwZXJ0KTogRmlndXJlIG91dCBob3cgdG8gY29tYmluZSBtZXNzYWdlcyB1c2VmdWxseVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gc2NvcmVBLm1lc3NhZ2UgfHwgc2NvcmVCLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGZpcnN0IHZhbGlkIGludGVycHJldGF0aW9uIG9mICd0ZXh0JyBhcyBhIG51bWJlciwgaW4gdGhlIGZvcm1cbiAgICAgKiB7dmFsdWU6IDIuMywgZXhhY3Q6IHRydWV9LlxuICAgICAqL1xuICAgIGZpcnN0TnVtZXJpY2FsUGFyc2U6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgLy8gVE9ETyhhbHBlcnQpOiBUaGlzIGlzIHNvcnQgb2YgaGFja3kuLi5cbiAgICAgICAgdmFyIGZpcnN0O1xuICAgICAgICB2YXIgdmFsID0gS2hhbi5hbnN3ZXJUeXBlcy5wcmVkaWNhdGUuY3JlYXRlVmFsaWRhdG9yRnVuY3Rpb25hbChcbiAgICAgICAgICAgIGZ1bmN0aW9uKGFucykge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gYW5zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgLyogYnJlYWsgKi9cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzaW1wbGlmeTogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgIGluZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgZm9ybXM6IFwiaW50ZWdlciwgcHJvcGVyLCBpbXByb3BlciwgcGksIGxvZywgbWl4ZWQsIGRlY2ltYWxcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsKHRleHQpO1xuICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfSxcblxuICAgIHN0cmluZ0FycmF5T2ZTaXplOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiBfKHNpemUpLnRpbWVzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgYSBncmFwaCdzIHggb3IgeSBkaW1lbnNpb24sIGdpdmVuIHRoZSB0aWNrIHN0ZXAsXG4gICAgICogdGhlIHJhbmdlcyBleHRlbnQgKGUuZy4gWy0xMCwgMTBdKSwgdGhlIHBpeGVsIGRpbWVuc2lvbiBjb25zdHJhaW50LFxuICAgICAqIGFuZCB0aGUgZ3JpZCBzdGVwLCByZXR1cm4gYSBidW5jaCBvZiBjb25maWd1cmF0aW9ucyBmb3IgdGhhdCBkaW1lbnNpb24uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICAgZ3JpZERpbWVuc2lvbkNvbmZpZygxMCwgWy01MCwgNTBdLCA0MDAsIDUpXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOiB7XG4gICAgICogICAgICBzY2FsZTogNCxcbiAgICAgKiAgICAgIHNuYXA6IDIuNSxcbiAgICAgKiAgICAgIHRpY2tTdGVwOiAyLFxuICAgICAqICAgICAgdW5pdHlMYWJlbDogdHJ1ZVxuICAgICAqIH07XG4gICAgICovXG4gICAgZ3JpZERpbWVuc2lvbkNvbmZpZzogZnVuY3Rpb24oYWJzVGlja1N0ZXAsIGV4dGVudCwgZGltZW5zaW9uQ29uc3RyYWludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkU3RlcCkge1xuICAgICAgICB2YXIgc2NhbGUgPSBVdGlsLnNjYWxlRnJvbUV4dGVudChleHRlbnQsIGRpbWVuc2lvbkNvbnN0cmFpbnQpO1xuICAgICAgICB2YXIgc3RlcFB4ID0gYWJzVGlja1N0ZXAgKiBzY2FsZTtcbiAgICAgICAgdmFyIHVuaXR5TGFiZWwgPSBzdGVwUHggPiAzMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIHRpY2tTdGVwOiBhYnNUaWNrU3RlcCAvIGdyaWRTdGVwLFxuICAgICAgICAgICAgdW5pdHlMYWJlbDogdW5pdHlMYWJlbFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgcmFuZ2UsIHN0ZXAsIGFuZCBib3hTaXplLCBjYWxjdWxhdGUgdGhlIHJlYXNvbmFibGUgZ3JpZFN0ZXAuXG4gICAgICogVXNlZCBmb3Igd2hlbiBvbmUgd2FzIG5vdCBnaXZlbiBleHBsaWNpdGx5LlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgIGdldEdyaWRTdGVwKFtbLTEwLCAxMF0sIFstMTAsIDEwXV0sIFsxLCAxXSwgMzQwKVxuICAgICAqXG4gICAgICogUmV0dXJuczogWzEsIDFdXG4gICAgICovXG4gICAgZ2V0R3JpZFN0ZXA6IGZ1bmN0aW9uKHJhbmdlLCBzdGVwLCBib3hTaXplKSB7XG4gICAgICAgIHJldHVybiBfKDIpLnRpbWVzKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IFV0aWwuc2NhbGVGcm9tRXh0ZW50KHJhbmdlW2ldLCBib3hTaXplKTtcbiAgICAgICAgICAgIHZhciBncmlkU3RlcCA9IFV0aWwuZ3JpZFN0ZXBGcm9tVGlja1N0ZXAoc3RlcFtpXSwgc2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGdyaWRTdGVwO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc25hcFN0ZXBGcm9tR3JpZFN0ZXA6IGZ1bmN0aW9uKGdyaWRTdGVwKSB7XG4gICAgICAgIHJldHVybiBfLm1hcChncmlkU3RlcCwgZnVuY3Rpb24oc3RlcCkgeyByZXR1cm4gc3RlcCAvIDI7IH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgcmFuZ2UgYW5kIGEgZGltZW5zaW9uLCBjb21lIHVwIHdpdGggdGhlIGFwcHJvcHJpYXRlXG4gICAgICogc2NhbGUuXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgIHNjYWxlRnJvbUV4dGVudChbLTI1LCAyNV0sIDUwMCkgLy8gcmV0dXJucyAxMFxuICAgICAqL1xuICAgIHNjYWxlRnJvbUV4dGVudDogZnVuY3Rpb24oZXh0ZW50LCBkaW1lbnNpb25Db25zdHJhaW50KSB7XG4gICAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICB2YXIgc2NhbGUgPSBkaW1lbnNpb25Db25zdHJhaW50IC8gc3BhbjtcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWFzb25hYmxlIHRpY2sgc3RlcCBnaXZlbiBleHRlbnQgYW5kIGRpbWVuc2lvbi5cbiAgICAgKiAoZXh0ZW50IGlzIFtiZWdpbiwgZW5kXSBvZiB0aGUgZG9tYWluLilcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICAgdGlja1N0ZXBGcm9tRXh0ZW50KFstMTAsIDEwXSwgMzAwKSAvLyByZXR1cm5zIDJcbiAgICAgKi9cbiAgICB0aWNrU3RlcEZyb21FeHRlbnQ6IGZ1bmN0aW9uKGV4dGVudCwgZGltZW5zaW9uQ29uc3RyYWludCkge1xuICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcblxuICAgICAgICB2YXIgdGlja0ZhY3RvcjtcbiAgICAgICAgLy8gSWYgc2luZ2xlIG51bWJlciBkaWdpdHNcbiAgICAgICAgaWYgKDE1IDwgc3BhbiAmJiBzcGFuIDw9IDIwKSB7XG4gICAgICAgICAgICB0aWNrRmFjdG9yID0gMjM7XG5cbiAgICAgICAgLy8gdHJpcGxlIGRpZ2l0IG9yIGRlY2ltYWxcbiAgICAgICAgfSBlbHNlIGlmIChzcGFuID4gMTAwIHx8IHNwYW4gPCA1KSB7XG4gICAgICAgICAgICB0aWNrRmFjdG9yID0gMTA7XG5cbiAgICAgICAgLy8gZG91YmxlIGRpZ2l0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrRmFjdG9yID0gMTY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnN0cmFpbnRGYWN0b3IgPSBkaW1lbnNpb25Db25zdHJhaW50IC8gNTAwO1xuICAgICAgICB2YXIgZGVzaXJlZE51bVRpY2tzID0gdGlja0ZhY3RvciAqIGNvbnN0cmFpbnRGYWN0b3I7XG4gICAgICAgIHJldHVybiBVdGlsLnRpY2tTdGVwRnJvbU51bVRpY2tzKHNwYW4sIGRlc2lyZWROdW1UaWNrcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSB0aWNrU3RlcCBhbmQgdGhlIGdyYXBoJ3Mgc2NhbGUsIGZpbmQgYVxuICAgICAqIGdyaWQgc3RlcC5cbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICAgZ3JpZFN0ZXBGcm9tVGlja1N0ZXAoMjAwLCAwLjIpIC8vIHJldHVybnMgMTAwXG4gICAgICovXG4gICAgZ3JpZFN0ZXBGcm9tVGlja1N0ZXA6IGZ1bmN0aW9uKHRpY2tTdGVwLCBzY2FsZSkge1xuICAgICAgICB2YXIgdGlja1dpZHRoID0gdGlja1N0ZXAgKiBzY2FsZTtcbiAgICAgICAgdmFyIHggPSB0aWNrU3RlcDtcbiAgICAgICAgdmFyIHkgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyh4KSAvIE1hdGguTE4xMCkpO1xuICAgICAgICB2YXIgbGVhZGluZ0RpZ2l0ID0gTWF0aC5mbG9vcih4IC8geSk7XG4gICAgICAgIGlmICh0aWNrV2lkdGggPCAyNSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpY2tTdGVwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aWNrV2lkdGggPCA1MCkge1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdEaWdpdCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWNrU3RlcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpY2tTdGVwIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0RpZ2l0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlja1N0ZXAgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nRGlnaXQgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWNrU3RlcCAvIDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdEaWdpdCA9PT0gNSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpY2tTdGVwIC8gNTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgZ29vZCB0aWNrIHN0ZXAgZm9yIHRoZSBkZXNpcmVkIG51bWJlciBvZiB0aWNrcyBpbiB0aGUgcmFuZ2VcbiAgICAgKiBNb2RpZmllZCBmcm9tIGQzLnNjYWxlLmxpbmVhcjogZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlLlxuICAgICAqIFRoYW5rcywgbWJvc3RvY2shXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgIHRpY2tTdGVwRnJvbU51bVRpY2tzKDUwLCA2KSAvLyByZXR1cm5zIDEwXG4gICAgICovXG4gICAgdGlja1N0ZXBGcm9tTnVtVGlja3M6IGZ1bmN0aW9uKHNwYW4sIG51bVRpY2tzKSB7XG4gICAgICAgIHZhciBzdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3BhbiAvIG51bVRpY2tzKSAvIE1hdGguTE4xMCkpO1xuICAgICAgICB2YXIgZXJyID0gbnVtVGlja3MgLyBzcGFuICogc3RlcDtcblxuICAgICAgICAvLyBGaWx0ZXIgdGlja3MgdG8gZ2V0IGNsb3NlciB0byB0aGUgZGVzaXJlZCBjb3VudC5cbiAgICAgICAgaWYgKGVyciA8PSAwLjE1KSB7XG4gICAgICAgICAgICBzdGVwICo9IDEwO1xuICAgICAgICB9IGVsc2UgaWYgKGVyciA8PSAwLjM1KSB7XG4gICAgICAgICAgICBzdGVwICo9IDU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyIDw9IDAuNzUpIHtcbiAgICAgICAgICAgIHN0ZXAgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJvdW5kIHN0YXJ0IGFuZCBzdG9wIHZhbHVlcyB0byBzdGVwIGludGVydmFsLlxuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNwYXJlbnRseSB1cGRhdGUgZGVwcmVjYXRlZCBwcm9wcyBzbyB0aGF0IHRoZSBjb2RlIHRvIGRlYWxcbiAgICAgKiB3aXRoIHRoZW0gb25seSBsaXZlcyBpbiBvbmUgcGxhY2U6IChXaWRnZXQpLmRlcHJlY2F0ZWRQcm9wc1xuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlLCBpZiBhIGJvb2xlYW4gYGZvb2Agd2FzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYVxuICAgICAqIG51bWJlciAnYmFyJzpcbiAgICAgKiAgICAgIGRlcHJlY2F0ZWRQcm9wczoge1xuICAgICAqICAgICAgICAgIGZvbzogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHtiYXI6IHByb3BzLmZvbyA/IDEgOiAwfTtcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9XG4gICAgICovXG4gICAgRGVwcmVjYXRpb25NaXhpbjoge1xuICAgICAgICAvLyBUaGlzIGxpZmVjeWNsZSBzdGFnZSBpcyBvbmx5IGNhbGxlZCBiZWZvcmUgZmlyc3QgcmVuZGVyXG4gICAgICAgIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgICAgICAgICAgXy5lYWNoKHRoaXMuZGVwcmVjYXRlZFByb3BzLCBmdW5jdGlvbihmdW5jLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uaGFzKHRoaXMucHJvcHMsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZXh0ZW5kKG5ld1Byb3BzLCBmdW5jKHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHkobmV3UHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IG5ldyBwcm9wcyBkaXJlY3RseSBzbyB0aGF0IHdpZGdldCByZW5kZXJzIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gaXQgZmlyc3QgbW91bnRzLCBldmVuIHRob3VnaCB0aGVzZSB3aWxsIGJlIG92ZXJ3cml0dGVuXG4gICAgICAgICAgICAgICAgLy8gYWxtb3N0IGltbWVkaWF0ZWx5IGFmdGVyd2FyZHMuLi5cbiAgICAgICAgICAgICAgICBfLmV4dGVuZCh0aGlzLnByb3BzLCBuZXdQcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAvLyAuLi53aGVuIHdlIHByb3BhZ2F0ZSB0aGUgbmV3IHByb3BzIHVwd2FyZHMgYW5kIHRoZXkgY29tZVxuICAgICAgICAgICAgICAgIC8vIGJhY2sgZG93biBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMucHJvcHMub25DaGFuZ2UsIDAsIG5ld1Byb3BzKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwcm94aW1hdGUgZXF1YWxpdHkgb24gbnVtYmVycyBhbmQgcHJpbWl0aXZlcy5cbiAgICAgKi9cbiAgICBlcTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAoXy5pc051bWJlcih4KSAmJiBfLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgMWUtOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSB5O1xuICAgICAgICB9XG4gICAgfSwgXG5cbiAgICAvKipcbiAgICAgKiBEZWVwIGFwcHJveGltYXRlIGVxdWFsaXR5IG9uIHByaW1pdGl2ZXMsIG51bWJlcnMsIGFycmF5cywgYW5kIG9iamVjdHMuXG4gICAgICovXG4gICAgZGVlcEVxOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmIChfLmlzQXJyYXkoeCkgJiYgXy5pc0FycmF5KHkpKSB7XG4gICAgICAgICAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFVdGlsLmRlZXBFcSh4W2ldLCB5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHgpIHx8IF8uaXNBcnJheSh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoeCkgJiYgXy5pc09iamVjdCh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uYWxsKHgsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5kZWVwRXEoeVtrZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KSAmJiBfLmFsbCh5LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuZGVlcEVxKHhba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh4KSB8fCBfLmlzT2JqZWN0KHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbC5lcSh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblV0aWwucmFuZG9tID0gVXRpbC5zZWVkZWRSTkcobmV3IERhdGUoKS5nZXRUaW1lKCkgJiAweGZmZmZmZmZmKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuXG4iLCJyZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xuXG52YXIgd2lkZ2V0VHlwZXMgPSB7fTtcblxudmFyIFdpZGdldHMgPSBQZXJzZXVzLldpZGdldHMgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB3aWRnZXRUeXBlc1t0eXBlXTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHR5cGUsIHdpZGdldENsYXNzKSB7XG4gICAgICAgIHdpZGdldFR5cGVzW3R5cGVdID0gd2lkZ2V0Q2xhc3M7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaWRnZXRzO1xuXG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbihmdW5jdGlvbihQZXJzZXVzKSB7XG5cbnJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xucmVxdWlyZShcIi4uL3JlbmRlcmVyLmpzeFwiKTtcblxudmFyIEluZm9UaXAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9pbmZvLXRpcC5qc3hcIik7XG52YXIgV2lkZ2V0cyA9IHJlcXVpcmUoXCIuLi93aWRnZXRzLmpzXCIpO1xuXG52YXIgZGVmYXVsdE51bUNhdGVnb3JpZXMgPSAyO1xuXG5mdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyYXksIGl0ZW0pIHtcbiAgICB2YXIgaW5kZXggPSBfLmluZGV4T2YoYXJyYXksIGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb29yZHNSZWxhdGl2ZVRvKGNvb3JkcywgZGl2KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9mZnNldFRvQ29vcmRzKCQoZGl2KS5vZmZzZXQoKSksIGZ1bmN0aW9uKG9mZnNldCwgaSkge1xuICAgICAgICByZXR1cm4gY29vcmRzW2ldIC0gb2Zmc2V0O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQpIHtcbiAgICByZXR1cm4gW29mZnNldC5sZWZ0LCBvZmZzZXQudG9wXTtcbn1cblxuZnVuY3Rpb24gZ2V0TW91c2VDb29yZHMoZSkge1xuICAgIGlmIChfLmhhcyhlLCBcIm5hdGl2ZUV2ZW50XCIpKSB7XG4gICAgICAgIGUgPSBlLm5hdGl2ZUV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gW2UucGFnZVgsIGUucGFnZVldO1xufVxuXG5mdW5jdGlvbiBvZmZzZXRDb29yZHNCeShjb29yZHMsIG9mZnNldCkge1xuICAgIHJldHVybiBfLm1hcChjb29yZHMsIGZ1bmN0aW9uKGNvb3JkLCBpKSB7XG4gICAgICAgIHJldHVybiBjb29yZCAtIG9mZnNldFtpXTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygkZWxlKSB7XG4gICAgcmV0dXJuIFskZWxlLm91dGVyV2lkdGgoKSwgJGVsZS5vdXRlckhlaWdodCgpXTtcbn1cblxuZnVuY3Rpb24gZmluZERpbWVuc2lvbnNGb3Iocm9vdCwgZWxlKSB7XG4gICAgdmFyICRlbGUgPSAkKGVsZSk7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldFRvQ29vcmRzKCRlbGUub2Zmc2V0KCkpO1xuICAgIHJldHVybiBnZXRBbGxDb29yZFR5cGVzKG9mZnNldCwgJGVsZSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbkJveChib3gsIG1pZGRsZSkge1xuICAgIHJldHVybiBfLmV2ZXJ5KG1pZGRsZSwgZnVuY3Rpb24oY29vcmQsIGkpIHtcbiAgICAgICAgdmFyIGMgPSBib3gudG9wTGVmdFtpXTtcbiAgICAgICAgcmV0dXJuIGMgPD0gY29vcmQgJiYgY29vcmQgPD0gYyArIGJveC5kaW1lbnNpb25zW2ldO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbGxDb29yZFR5cGVzKGNvb3JkcywgJGVsZSwgcm9vdCkge1xuICAgIHZhciB0b3BMZWZ0ID0gY29vcmRzUmVsYXRpdmVUbyhjb29yZHMsIHJvb3QpO1xuICAgIHZhciBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucygkZWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgICB0b3BMZWZ0OiB0b3BMZWZ0LFxuICAgICAgICBtaWRkbGU6IF8ubWFwKGRpbWVuc2lvbnMsIGZ1bmN0aW9uKGRpbSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvcExlZnRbaV0gKyBkaW0gLyAyO1xuICAgICAgICB9KVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNsb25lTWF0cml4KG1hdHJpeCkge1xuICAgIHJldHVybiBfLm1hcChtYXRyaXgsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gcm93LnNsaWNlKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJsYW5rSXRlbShwb3NpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICBjYXRlZ29yeTogMCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbiB8fCAwXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgdmFyIGl0ZW0gPSBibGFua0l0ZW0oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0VkaXRvcjogZmFsc2UsXG4gICAgICAgIGl0ZW1zOiBbaXRlbV0sXG4gICAgICAgIGNvcnJlY3RMb2NhdGlvbnM6IFtpdGVtLmxvY2F0aW9uXSxcbiAgICAgICAgY2F0ZWdvcnlIZWFkZXJzOiBbXCJcIl1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc0JhbmsoY2F0ZWdvcnkpIHtcbiAgICByZXR1cm4gY2F0ZWdvcnkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIG5leHRQb3NpdGlvbihpdGVtcykge1xuICAgIHZhciBpdGVtID0gXy5tYXgoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmxvY2F0aW9uLnBvc2l0aW9uO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVtLmxvY2F0aW9uLnBvc2l0aW9uICsgMTtcbn1cblxuZnVuY3Rpb24gbmV4dFBvc2l0aW9uQ29ycmVjdExvY2F0aW9ucyhjb3JyZWN0TG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIF8ubWF4KF8ucGx1Y2soY29ycmVjdExvY2F0aW9ucywgXCJwb3NpdGlvblwiKSkgKyAxO1xufVxuXG4vLyBUaGlzIGlzIGFkYXB0ZWQgZnJvbSB0aGUgY2FsY3VsYXRpb24gaW4gb3JkZXJlci5cbi8vIEl0IGdpdmVzIGFuIGFuaW1hdGlvbiB0aW1lIHRoYXQgaXMgZGlzdGFuY2UgZGVwZW5kZW50LFxuLy8gYmFzZWQgb24gdGhlIHNxdWFyZSByb290IG9mIHRoZSBkaXN0YW5jZS5cbmZ1bmN0aW9uIGRyYWdSZXR1cm5BbmltYXRpb25UaW1lKGZyb21Db29yZHMsIHRvQ29vcmRzKSB7XG4gICAgdmFyIHNxdWFyZURpc3RhbmNlID0gXy5yZWR1Y2UoZnJvbUNvb3JkcywgZnVuY3Rpb24oc3F1YXJlRCwgY29vcmQsIGkpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB0b0Nvb3Jkc1tpXSAtIGNvb3JkO1xuICAgICAgICByZXR1cm4gc3F1YXJlRCArIGRpZmYgKiBkaWZmO1xuICAgIH0sIDApO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChzcXVhcmVEaXN0YW5jZSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KDE1ICogTWF0aC5zcXJ0KGRpc3RhbmNlKSwgMSk7XG59XG5cbnZhciBDYXRlZ29yaXphdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0NhdGVnb3JpemF0aW9uJyxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGdldERlZmF1bHRQcm9wcyxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaG93RHJhZ0hpbnQ6IHRydWUsXG4gICAgICAgICAgICBkcmFnZ2luZzogbnVsbFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRBbGxNb3VzZUNvb3JkVHlwZXM6IGZ1bmN0aW9uKG1vdXNlQ29vcmRzLCAkZWxlKSB7XG4gICAgICAgIHZhciBvZmZzZXRNb3VzZSA9IG9mZnNldENvb3Jkc0J5KFxuICAgICAgICAgICAgICAgIG1vdXNlQ29vcmRzLCB0aGlzLnN0YXRlLmRyYWdnaW5nLm9mZnNldCk7XG4gICAgICAgIHZhciBjID0gZ2V0QWxsQ29vcmRUeXBlcyhvZmZzZXRNb3VzZSwgJGVsZSwgJCh0aGlzLmdldERPTU5vZGUoKSkpO1xuICAgICAgICBjLm1vdXNlID0gbW91c2VDb29yZHM7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICBnZXRJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLm1hcCh0aGlzLnByb3BzLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtpbmRleDogaW5kZXh9LCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHN0YXJ0RHJhZzogZnVuY3Rpb24oaXRlbUluZGV4LCBldmVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChpdGVtSW5kZXggPT0gbnVsbCB8fCBzZWxmLnN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zID0gc2VsZi5nZXRJdGVtcygpO1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2l0ZW1JbmRleF07XG5cbiAgICAgICAgdmFyIGNhcmREaXYgPSAkKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHdoaWxlICghY2FyZERpdi5oYXNDbGFzcyhcImNhcmRcIikpIHtcbiAgICAgICAgICAgIGNhcmREaXYgPSBjYXJkRGl2LnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb29yZHMgPSBnZXRNb3VzZUNvb3JkcyhldmVudCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBjb29yZHNSZWxhdGl2ZVRvKGNvb3JkcywgY2FyZERpdik7XG4gICAgICAgIHZhciByb290ID0gJChzZWxmLmdldERPTU5vZGUoKSk7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gcm9vdC5maW5kKFwiLmNhdGVnb3JpZXMgLmNhdGVnb3J5XCIpO1xuICAgICAgICB2YXIgZmluZERpbXMgPSBfLnBhcnRpYWwoZmluZERpbWVuc2lvbnNGb3IsIHJvb3QpO1xuICAgICAgICBzZWxmLmNhdGVnb3J5RGltZW5zaW9ucyA9IF8ubWFwKGNhdGVnb3JpZXMsIGZpbmREaW1zKTtcbiAgICAgICAgaWYgKHNlbGYucHJvcHMuaXNFZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBkZWxldGVJdGVtID0gcm9vdC5maW5kKFwiLmRlbGV0ZS1pdGVtLWFyZWFcIik7XG4gICAgICAgICAgICBzZWxmLmRlbGV0ZUl0ZW1EaW1lbnNpb25zID0gZmluZERpbWVuc2lvbnNGb3Iocm9vdCwgZGVsZXRlSXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiB7XG4gICAgICAgICAgICAgICAgaXRlbUluZGV4OiBpdGVtSW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXy5iaW5kKHNlbGYudXBkYXRlRHJhZywgc2VsZiwgY29vcmRzKSk7XG5cbiAgICAgICAgJChkb2N1bWVudClcbiAgICAgICAgLm9uKFwidm1vdXNlbW92ZS5jYXRlZ29yaXphdGlvblwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZURyYWcoZ2V0TW91c2VDb29yZHMoZSkpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJ2bW91c2V1cC5jYXRlZ29yaXphdGlvblwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZERyYWcoZ2V0TW91c2VDb29yZHMoZSkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmluZERyYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzLmdldERPTU5vZGUoKSkuZmluZChcIi5jYXJkLmRyYWdnaW5nXCIpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVEcmFnOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgJGRyYWcgPSB0aGlzLmZpbmREcmFnKCk7XG5cbiAgICAgICAgdmFyIGMgPSBzZWxmLmdldEFsbE1vdXNlQ29vcmRUeXBlcyhjb29yZHMsICRkcmFnKTtcbiAgICAgICAgdmFyIG1pZGRsZSA9IGMubWlkZGxlO1xuICAgICAgICAkZHJhZ1xuICAgICAgICAgICAgLmNzcyhcImxlZnRcIiwgYy50b3BMZWZ0WzBdKVxuICAgICAgICAgICAgLmNzcyhcInRvcFwiLCBjLnRvcExlZnRbMV0pO1xuICAgICAgICB2YXIgdGFyZ2V0Q2F0ZWdvcnkgPSBzZWxmLmZpbmRUYXJnZXRDYXRlZ29yeShtaWRkbGUpO1xuICAgICAgICBzZWxmLnNldFN0YXRlKHt0YXJnZXRDYXRlZ29yeTogdGFyZ2V0Q2F0ZWdvcnl9KTtcbiAgICB9LFxuXG4gICAgZmluZFRhcmdldENhdGVnb3J5OiBmdW5jdGlvbihtaWRkbGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY2F0ZWdvcnlJbmRleDtcbiAgICAgICAgaWYgKHNlbGYucHJvcHMuaXNFZGl0b3IpIHtcbiAgICAgICAgICAgIGlmICh3aXRoaW5Cb3goc2VsZi5kZWxldGVJdGVtRGltZW5zaW9ucywgbWlkZGxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImRlbGV0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpbkNhdGVnb3J5ID0gXy5maW5kKHNlbGYuY2F0ZWdvcnlEaW1lbnNpb25zLCBmdW5jdGlvbihjb2wsIGluZGV4KSB7XG4gICAgICAgICAgICBjYXRlZ29yeUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gd2l0aGluQm94KGNvbCwgbWlkZGxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gMHRoIGNhdGVnb3J5IGlzIGJhbmtcbiAgICAgICAgaWYgKCFpbkNhdGVnb3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB0cnVlIGNhdGVnb3JpZXMgZ2V0IGluY3JlbWVudGVkIGluZGljaWVzLlxuICAgICAgICByZXR1cm4gY2F0ZWdvcnlJbmRleCArIDE7XG4gICAgfSxcblxuICAgIGVuZERyYWc6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkcmFnZ2luZyA9IHNlbGYuc3RhdGUuZHJhZ2dpbmc7XG4gICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgJGRyYWcgPSBzZWxmLmZpbmREcmFnKCk7XG4gICAgICAgIHZhciBpdGVtcyA9IHNlbGYuZ2V0SXRlbXMoKTtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IGRyYWdnaW5nLml0ZW1JbmRleDtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpdGVtSW5kZXhdO1xuXG4gICAgICAgICQoZG9jdW1lbnQpXG4gICAgICAgICAgICAub2ZmKFwidm1vdXNlbW92ZS5jYXRlZ29yaXphdGlvblwiKVxuICAgICAgICAgICAgLm9mZihcInZtb3VzZXVwLmNhdGVnb3JpemF0aW9uXCIpO1xuXG4gICAgICAgIHZhciBjID0gc2VsZi5nZXRBbGxNb3VzZUNvb3JkVHlwZXMoY29vcmRzLCAkZHJhZyk7XG4gICAgICAgIHZhciB0YXJnZXRDYXRlZ29yeSA9IHNlbGYuZmluZFRhcmdldENhdGVnb3J5KGMubWlkZGxlKTtcblxuICAgICAgICBpZiAodGFyZ2V0Q2F0ZWdvcnkgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlTG9jYXRpb24odGFyZ2V0Q2F0ZWdvcnkpO1xuICAgICAgICAgICAgc2VsZi5wcm9wcy5kZWxldGVJdGVtKGl0ZW1JbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdCA9ICQoc2VsZi5nZXRET01Ob2RlKCkpO1xuICAgICAgICB2YXIgcmV0dXJuZWRUb1NhbWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKF8uaXNFcXVhbCh0YXJnZXRDYXRlZ29yeSwgaXRlbS5sb2NhdGlvbi5jYXRlZ29yeSkpIHtcbiAgICAgICAgICAgIHJldHVybmVkVG9TYW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2xvdENsYXNzO1xuICAgICAgICBpZiAocmV0dXJuZWRUb1NhbWUpIHtcbiAgICAgICAgICAgIHNsb3RDbGFzcyA9IFwiLmNhcmQucGxhY2Vob2xkZXJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNsb3RDbGFzcyA9IFwiLmNhcmQtZW1wdHktc2xvdFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXRUb3AgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNsb3QgPSByb290LmZpbmQoXG4gICAgICAgICAgICAgICAgXCIuY2F0ZWdvcnktXCIgKyB0YXJnZXRDYXRlZ29yeSArIFwiIFwiICsgc2xvdENsYXNzKTtcbiAgICAgICAgaWYgKCFyZXR1cm5lZFRvU2FtZSkge1xuICAgICAgICAgICAgaWYgKCFpc0JhbmsoaXRlbS5sb2NhdGlvbi5jYXRlZ29yeSkgJiZcbiAgICAgICAgICAgICAgICBpdGVtLmxvY2F0aW9uLmNhdGVnb3J5IDwgdGFyZ2V0Q2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkaW1zID0gZmluZERpbWVuc2lvbnNGb3Iocm9vdCwgc2xvdCk7XG4gICAgICAgIHZhciB0b3BMZWZ0ID0ge2xlZnQ6IGRpbXMudG9wTGVmdFswXSwgdG9wOiBkaW1zLnRvcExlZnRbMV19O1xuICAgICAgICBpZiAob2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByb290LmZpbmQoXCIuY2F0ZWdvcnktXCIgK1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmxvY2F0aW9uLmNhdGVnb3J5ICsgXCIgLmNhcmQucGxhY2Vob2xkZXJcIik7XG4gICAgICAgICAgICB2YXIgcGFyZW50RGltcyA9IGdldERpbWVuc2lvbnMocGxhY2Vob2xkZXIucGFyZW50KCkpO1xuICAgICAgICAgICAgdG9wTGVmdC50b3AgLT0gcGFyZW50RGltc1sxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0aW9uVGltZSA9IGRyYWdSZXR1cm5BbmltYXRpb25UaW1lKFxuICAgICAgICAgICAgICAgIGMudG9wTGVmdCwgZGltcy50b3BMZWZ0KTtcbiAgICAgICAgJGRyYWcuYW5pbWF0ZSh0b3BMZWZ0LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uVGltZSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBfLmJpbmQoc2VsZi51cGRhdGVMb2NhdGlvbiwgc2VsZiwgdGFyZ2V0Q2F0ZWdvcnkpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVMb2NhdGlvbjogZnVuY3Rpb24odGFyZ2V0Q2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgaXRlbXMgPSBzZWxmLmdldEl0ZW1zKCk7XG4gICAgICAgIHZhciBpdGVtSW5kZXggPSBzZWxmLnN0YXRlLmRyYWdnaW5nLml0ZW1JbmRleDtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpdGVtSW5kZXhdO1xuXG4gICAgICAgIHZhciBjaGFuZ2UgPSB7XG4gICAgICAgICAgICB0YXJnZXRDYXRlZ29yeTogbnVsbCxcbiAgICAgICAgICAgIGRyYWdnaW5nOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpdGVtLmxvY2F0aW9uLmNhdGVnb3J5ICE9PSB0YXJnZXRDYXRlZ29yeSkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV4dFBvc2l0aW9uKGl0ZW1zKTtcbiAgICAgICAgICAgIGl0ZW0ubG9jYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHRhcmdldENhdGVnb3J5LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoYW5nZS5zaG93RHJhZ0hpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zZXRTdGF0ZShjaGFuZ2UpO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBpdGVtcyA9IHNlbGYuZ2V0SXRlbXMoKTtcbiAgICAgICAgdmFyIHRhcmdldENhdGVnb3J5ID0gc2VsZi5zdGF0ZS50YXJnZXRDYXRlZ29yeTtcbiAgICAgICAgdmFyIGRyYWdnaW5nID0gc2VsZi5zdGF0ZS5kcmFnZ2luZztcbiAgICAgICAgdmFyIGlzRWRpdG9yID0gc2VsZi5wcm9wcy5pc0VkaXRvcjtcblxuICAgICAgICB2YXIgZHJhZ0l0ZW07XG4gICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgICAgZHJhZ0l0ZW0gPSBDYXRlZ29yeUl0ZW0oe1xuICAgICAgICAgICAgICAgIGlzRHJhZ0l0ZW06IHRydWUsXG4gICAgICAgICAgICAgICAgaXRlbTogZHJhZ2dpbmcgPyBpdGVtc1tkcmFnZ2luZy5pdGVtSW5kZXhdIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpc0VkaXRvcjogdGhpcy5wcm9wcy5pc0VkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYW5rXG4gICAgICAgIHZhciBiYW5rID0gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImJhbmtcIn0sIFxuICAgICAgICAgICAgQ2F0ZWdvcnkoXG4gICAgICAgICAgICAgICAge3JlZjpcImJhbmtcIixcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTowLFxuICAgICAgICAgICAgICAgIGl0ZW1zOml0ZW1zLFxuICAgICAgICAgICAgICAgIGlzRWRpdG9yOmlzRWRpdG9yLFxuICAgICAgICAgICAgICAgIHRhcmdldENhdGVnb3J5OnRhcmdldENhdGVnb3J5LFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOmRyYWdnaW5nLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ29udGVudDpzZWxmLnByb3BzLm9uQ2hhbmdlQ29udGVudCxcbiAgICAgICAgICAgICAgICBzdGFydERyYWc6c2VsZi5zdGFydERyYWd9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBkZWxldGVJdGVtO1xuICAgICAgICBpZiAoaXNFZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBkZWxldGVJdGVtQ2xhc3MgPSBcImRlbGV0ZS1pdGVtLWFyZWFcIjtcbiAgICAgICAgICAgIGlmICh0YXJnZXRDYXRlZ29yeSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1DbGFzcyArPSBcIiB0YXJnZXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZUl0ZW0gPSBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOmRlbGV0ZUl0ZW1DbGFzc30sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwiaWNvbi10cmFzaFwifSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYXRlZ29yaWVzXG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImNhdGVnb3JpZXMgY2xlYXJmaXhcIn0sIFxuICAgICAgICAgICAgXy5tYXAoc2VsZi5wcm9wcy5jYXRlZ29yeUhlYWRlcnMsIGZ1bmN0aW9uKGhlYWRlciwgYykge1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeSA9IGMgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBDYXRlZ29yeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwiY2F0ZWdvcnktXCIgKyBjYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTpjYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6Y2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlIZWFkZXI6aGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRWRpdG9yOmlzRWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOml0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVGFyZ2V0OnRhcmdldENhdGVnb3J5ID09PSBjYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzpkcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93RHJhZ0hpbnQ6c2VsZi5zdGF0ZS5zaG93RHJhZ0hpbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2VDb250ZW50OnNlbGYucHJvcHMub25DaGFuZ2VDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlSGVhZGVyOnNlbGYucHJvcHMub25DaGFuZ2VIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2F0ZWdvcnk6c2VsZi5wcm9wcy5yZW1vdmVDYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERyYWc6c2VsZi5zdGFydERyYWd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY29udGFpbmVyXG4gICAgICAgIHZhciBjb250YWluZXJOYW1lID0gXCJkcmFnZ3ktYm94eS10aGluZyBjYXRlZ29yaXphdGlvbi1jb250YWluZXJcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgY2xlYXJmaXhcIjtcbiAgICAgICAgaWYgKGlzRWRpdG9yKSB7XG4gICAgICAgICAgICBjb250YWluZXJOYW1lICs9IFwiIGNhdGVnb3JpemF0aW9uLWNvbnRhaW5lci1lZGl0b3JcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lck5hbWUgKz0gXCIgY3VycmVudGx5LWRyYWdnaW5nXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpjb250YWluZXJOYW1lfSwgXG4gICAgICAgICAgICBkcmFnSXRlbSxcbiAgICAgICAgICAgIGJhbmssXG4gICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgZGVsZXRlSXRlbVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbXMgPSBfLm1hcCh0aGlzLnByb3BzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIF8ucGljayhpdGVtLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtpdGVtczogaXRlbXN9O1xuICAgIH0sXG5cbiAgICBzaW1wbGVWYWxpZGF0ZTogZnVuY3Rpb24ocnVicmljKSB7XG4gICAgICAgIHJldHVybiBDYXRlZ29yaXphdGlvbi52YWxpZGF0ZSh0aGlzLnRvSlNPTigpLCBydWJyaWMpO1xuICAgIH0sXG5cbiAgICBmb2N1c0FkZGVkSXRlbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVmcy5iYW5rLmZvY3VzQWRkZWRJdGVtKCk7XG4gICAgfSxcblxuICAgIGZvY3VzQWRkZWRDYXRlZ29yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXRlZ29yeSA9IHRoaXMucHJvcHMuY2F0ZWdvcnlIZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yZWZzW1wiY2F0ZWdvcnktXCIgKyBjYXRlZ29yeV0uZm9jdXMoKTtcbiAgICB9LFxufSk7XG5cbl8uZXh0ZW5kKENhdGVnb3JpemF0aW9uLCB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHN0YXRlLCBydWJyaWMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFsbENvcnJlY3QgPSB0cnVlO1xuICAgICAgICBfLmVhY2goc3RhdGUuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIHZhciBjb3JyZWN0TG9jYXRpb24gPSBydWJyaWMuY29ycmVjdExvY2F0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBsb2MgPSBpdGVtLmxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKCFpc0JhbmsobG9jLmNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvYy5jYXRlZ29yeSAhPT0gY29ycmVjdExvY2F0aW9uLmNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgYWxsQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQXQgbGVhc3Qgb25lIGl0ZW0gbXVzdCBiZSBjYXRlZ29yaXplZC5cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgIGVhcm5lZDogYWxsQ29ycmVjdCA/IDEgOiAwLFxuICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbnZhciBDYXRlZ29yeSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0NhdGVnb3J5JyxcblxuICAgIHJlbmRlckNhdGVnb3J5SXRlbTogZnVuY3Rpb24oaXRlbSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLnByb3BzLmRyYWdnaW5nO1xuICAgICAgICBpZiAoZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuaXRlbUluZGV4ID09PSBpdGVtLmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUGxhY2Vob2xkZXJJdGVtKCB7aXRlbTppdGVtfSApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBcImNhdGVnb3J5LWl0ZW0tXCIgKyBpdGVtLmluZGV4O1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcnlJdGVtKHtcbiAgICAgICAgICAgIHJlZjoga2V5LFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgaXNFZGl0b3I6IHRoaXMucHJvcHMuaXNFZGl0b3IsXG4gICAgICAgICAgICBvbk1vdXNlRG93bjogXy5wYXJ0aWFsKHRoaXMucHJvcHMuc3RhcnREcmFnLCBpdGVtLmluZGV4KSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBfLnBhcnRpYWwodGhpcy5wcm9wcy5vbkNoYW5nZUNvbnRlbnQsIGl0ZW0uaW5kZXgpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNFZGl0b3I6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0RyYWdIaW50OiBmYWxzZSxcbiAgICAgICAgICAgIGNhdGVnb3J5SGVhZGVyOiBudWxsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNhdGVnb3J5SXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xJdGVtcyA9IF8uZmlsdGVyKHNlbGYucHJvcHMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxvY2F0aW9uLmNhdGVnb3J5ID09PSBzZWxmLnByb3BzLmNhdGVnb3J5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF8uc29ydEJ5KGNvbEl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sb2NhdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oY2F0ZWdvcnlIZWFkZXIsIGMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY2F0ZWdvcnkgPSBzZWxmLnByb3BzLmNhdGVnb3J5O1xuICAgICAgICB2YXIgaXRlbXMgPSBzZWxmLmNhdGVnb3J5SXRlbXMoKTtcblxuICAgICAgICB2YXIgY2FyZExpc3QgPSBSZWFjdC5ET00udWwoIHtjbGFzc05hbWU6XCJjbGVhcmZpeFwifSwgXG4gICAgICAgICAgICBfLm1hcChpdGVtcywgc2VsZi5yZW5kZXJDYXRlZ29yeUl0ZW0sIHNlbGYpLFxuICAgICAgICAgICAgc2VsZi5wcm9wcy5zaG93RHJhZ0hpbnQgPyBEcmFnSGludEl0ZW0obnVsbCApIDogSW52aXNpYmxlSXRlbShudWxsIClcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgaGVhZGVyID0gc2VsZi5yZW5kZXJIZWFkZXIoKTtcblxuICAgICAgICAvLyBjb250YWluZXIgY2xhc3NcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFwiY2F0ZWdvcnkgY2xlYXJmaXggY2F0ZWdvcnktXCIgKyBjYXRlZ29yeTtcbiAgICAgICAgaWYgKHNlbGYucHJvcHMuaXNUYXJnZXQpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBcIiB0YXJnZXRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLnByb3BzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gXCIgbm9uLXRhcmdldFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3RDbGFzcyA9IFwiY2FyZHMtbGlzdFwiO1xuICAgICAgICBpZiAoIWlzQmFuayhjYXRlZ29yeSkpIHtcbiAgICAgICAgICAgIGxpc3RDbGFzcyArPSBcIiBjYXJkcy1hcmVhXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpjbGFzc05hbWV9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6bGlzdENsYXNzfSwgXG4gICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgIGNhcmRMaXN0XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHJlbmRlckhlYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGlzQmFuayhzZWxmLnByb3BzLmNhdGVnb3J5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgaWYgKHNlbGYucHJvcHMuaXNFZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBvbkNoYW5nZUhlYWRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gc2VsZi5yZWZzLmhlYWRlcjtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXIuZ2V0RE9NTm9kZSgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIHNlbGYucHJvcHMub25DaGFuZ2VIZWFkZXIoc2VsZi5wcm9wcy5jYXRlZ29yeSwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZW1vdmVDYXRlZ29yeSA9IF8ucGFydGlhbChcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wcy5yZW1vdmVDYXRlZ29yeSwgc2VsZi5wcm9wcy5jYXRlZ29yeSk7XG5cbiAgICAgICAgICAgIGhlYWRlciA9IFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6XCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6cmVtb3ZlQ2F0ZWdvcnl9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJpY29uLXJlbW92ZVwifSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJoZWFkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0Om9uQ2hhbmdlSGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6c2VsZi5wcm9wcy5jYXRlZ29yeUhlYWRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXIgPSBQZXJzZXVzLlJlbmRlcmVyKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBzZWxmLnByb3BzLmNhdGVnb3J5SGVhZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImhlYWRlclwifSwgaGVhZGVyKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnMuaGVhZGVyLmdldERPTU5vZGUoKS5mb2N1cygpO1xuICAgIH0sXG5cbiAgICBmb2N1c0FkZGVkSXRlbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnByb3BzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnByb3BzLml0ZW1zW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIHJlZiA9IHRoaXMucmVmc1tcImNhdGVnb3J5LWl0ZW0tXCIgKyBpdGVtLmluZGV4XTtcbiAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICByZWYuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxudmFyIFBsYWNlaG9sZGVySXRlbSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1BsYWNlaG9sZGVySXRlbScsXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5saSgge2NsYXNzTmFtZTpcImNhcmQtY29udGFpbmVyXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJjYXJkIHBsYWNlaG9sZGVyXCJ9LCBcbiAgICAgICAgICAgICAgICBQZXJzZXVzLlJlbmRlcmVyKHtjb250ZW50OiB0aGlzLnByb3BzLml0ZW0uY29udGVudH0pXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbnZhciBEcmFnSGludEl0ZW0gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdEcmFnSGludEl0ZW0nLFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00ubGkoIHtjbGFzc05hbWU6XCJjYXJkLWNvbnRhaW5lclwifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiY2FyZCBjYXJkLWVtcHR5LXNsb3QgZHJhZy1oaW50XCJ9KVxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG52YXIgSW52aXNpYmxlSXRlbSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0ludmlzaWJsZUl0ZW0nLFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00ubGkoIHtjbGFzc05hbWU6XCJjYXJkLWNvbnRhaW5lclwifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiY2FyZCBjYXJkLWVtcHR5LXNsb3QgY2FyZC1oaWRkZW5cIn0pXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbnZhciBDYXRlZ29yeUl0ZW0gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdDYXRlZ29yeUl0ZW0nLFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgaXNFZGl0b3I6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW0gPSBzZWxmLnByb3BzLml0ZW07XG4gICAgICAgIHZhciBjb250ZW50ID0gaXRlbS5jb250ZW50O1xuICAgICAgICB2YXIgaXNFZGl0b3IgPSBzZWxmLnByb3BzLmlzRWRpdG9yO1xuICAgICAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLnByb3BzLm9uQ2hhbmdlKHNlbGYucmVmcy5lZGl0b3IuZ2V0RE9NTm9kZSgpLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGlzRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5wcm9wcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJjYXJkXCI7XG4gICAgICAgIGlmIChzZWxmLnByb3BzLmlzRHJhZ0l0ZW0pIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBcIiBkcmFnZ2luZ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlubmVyO1xuICAgICAgICBpZiAoaXNFZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBtb3VzZURvd25FZGl0b3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbm5lciA9IFJlYWN0LkRPTS5kaXYoXG4gICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6Y2xhc3NOYW1lICsgXCIgY2FyZC1lZGl0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd246b25Nb3VzZURvd259LCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiZHJhZy1iYXJcIn0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge2NsYXNzTmFtZTpcImljb24tcmVvcmRlclwifSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJlZGl0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0Om9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd246bW91c2VEb3duRWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6Y29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbm5lciA9IFJlYWN0LkRPTS5kaXYoXG4gICAgICAgICAgICAgICAge2NsYXNzTmFtZTpjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgb25Nb3VzZURvd246b25Nb3VzZURvd24sXG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0Om9uTW91c2VEb3dufVxuICAgICAgICAgICAgLCBQZXJzZXVzLlJlbmRlcmVyKHtjb250ZW50OiBjb250ZW50fSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYucHJvcHMuaXNEcmFnSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00ubGkoIHtjbGFzc05hbWU6XCJjYXJkLWNvbnRhaW5lclwifSwgXG4gICAgICAgICAgICBpbm5lclxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVmcy5lZGl0b3IuZ2V0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgfSxcbn0pO1xuXG52YXIgQ2F0ZWdvcml6YXRpb25FZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdDYXRlZ29yaXphdGlvbkVkaXRvcicsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBnZXREZWZhdWx0UHJvcHMsXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb3JyZWN0TG9jYXRpb25zID0gc2VsZi5wcm9wcy5jb3JyZWN0TG9jYXRpb25zO1xuICAgICAgICB2YXIgaXRlbXMgPSBfLm1hcChzZWxmLnByb3BzLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBpdGVtLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGNvcnJlY3RMb2NhdGlvbnNbaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIlRoZSBudW1iZXIgb2YgY2FyZHMgYW5kIGNhdGVnb3JpZXMgaXMgdW5saW1pdGVkLCBidXQgd2UgXCIrXG4gICAgICAgICAgICAgIFwicmVjb21tZW5kIGEgbWF4IG9mIGZpdmUgY2FyZHMgYW5kIHRocmVlIGNhdGVnb3JpZXMgdG8gcHJldmVudCB0aGUgXCIrXG4gICAgICAgICAgICAgIFwicXVlc3Rpb24gZnJvbSBydW5uaW5nIG9mZiB0aGUgc2NyZWVuLlwiKSxcblxuICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIkZvciB0aGUgY29ycmVjdCBhbnN3ZXIsIG1vdmUgdGhlIGNhcmRzIGludG8gdGhlIGNvcnJlY3QgXCIrXG4gICAgICAgICAgICAgIFwiY2F0ZWdvcmllcyBpbiB0aGUgcXVlc3Rpb24gYXJlYSBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBcIitcbiAgICAgICAgICAgICAgXCJzY3JlZW4uXCIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImNhdGVnb3JpemF0aW9uLWVkaXRvci1hcmVhXCJ9LCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiYWRkLWl0ZW1cIn0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uYnV0dG9uKCB7b25DbGljazpzZWxmLmFkZEl0ZW19LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEFkZCBhbiBpdGVtIFwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJhZGQtY2F0ZWdvcnlcIn0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uYnV0dG9uKCB7b25DbGljazpzZWxmLm9uQWRkQ2F0ZWdvcnl9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEFkZCBhIGNhdGVnb3J5IFwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgQ2F0ZWdvcml6YXRpb24oXG4gICAgICAgICAgICAgICAge3JlZjpcImNhdGVnb3JpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgaXRlbXM6aXRlbXMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlIZWFkZXJzOnNlbGYucHJvcHMuY2F0ZWdvcnlIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGlzRWRpdG9yOnRydWUsXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2F0ZWdvcnk6c2VsZi5yZW1vdmVDYXRlZ29yeSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZUhlYWRlcjpzZWxmLm9uQ2hhbmdlSGVhZGVyLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ29udGVudDpzZWxmLm9uQ2hhbmdlQ29udGVudCxcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtOnNlbGYuZGVsZXRlSXRlbSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTpmdW5jdGlvbihyYXdOZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBfLmNsb25lKHJhd05ld1Byb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd05ld1Byb3BzLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcy5jb3JyZWN0TG9jYXRpb25zID0gXy5wbHVjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMuaXRlbXMsIFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wcy5vbkNoYW5nZShuZXdQcm9wcyk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uQWRkQ2F0ZWdvcnk6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLnByb3BzLmNhdGVnb3J5SGVhZGVycy5zbGljZSgpO1xuICAgICAgICBoZWFkZXJzLnB1c2goXCJcIik7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgY2F0ZWdvcnlIZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgIH0sIHRoaXMucmVmcy5jYXRlZ29yaXphdGlvbi5mb2N1c0FkZGVkQ2F0ZWdvcnkpO1xuICAgIH0sXG5cbiAgICByZW1vdmVDYXRlZ29yeTogZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIGNvcnJlY3RMb2NhdGlvbnMgPSB0aGlzLnByb3BzLmNvcnJlY3RMb2NhdGlvbnM7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5wcm9wcy5jYXRlZ29yeUhlYWRlcnMuc2xpY2UoKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV4dFBvc2l0aW9uQ29ycmVjdExvY2F0aW9ucyhjb3JyZWN0TG9jYXRpb25zKTtcbiAgICAgICAgY29ycmVjdExvY2F0aW9ucyA9IF8ubWFwKGNvcnJlY3RMb2NhdGlvbnMsIGZ1bmN0aW9uKGxvYykge1xuICAgICAgICAgICAgaWYgKGxvYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB7Y2F0ZWdvcnk6IDAsIHBvc2l0aW9uOiBwb3NpdGlvbn07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvYy5jYXRlZ29yeSA+IGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgbG9jID0gXy5jbG9uZShsb2MpO1xuICAgICAgICAgICAgICAgIGxvYy5jYXRlZ29yeSA9IGxvYy5jYXRlZ29yeSAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhlYWRlcnMuc3BsaWNlKGNhdGVnb3J5IC0gMSwgMSk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgY2F0ZWdvcnlIZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgY29ycmVjdExvY2F0aW9uczogY29ycmVjdExvY2F0aW9uc1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYWRkSXRlbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucHJvcHMuaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgdmFyIGNvcnJlY3RMb2NhdGlvbnMgPSB0aGlzLnByb3BzLmNvcnJlY3RMb2NhdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbmV4dFBvc2l0aW9uQ29ycmVjdExvY2F0aW9ucyhjb3JyZWN0TG9jYXRpb25zKTtcbiAgICAgICAgdmFyIGl0ZW0gPSBibGFua0l0ZW0ocG9zaXRpb24pO1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICBjb3JyZWN0TG9jYXRpb25zLnB1c2goaXRlbS5sb2NhdGlvbik7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICAgICAgY29ycmVjdExvY2F0aW9uczogY29ycmVjdExvY2F0aW9uc1xuICAgICAgICB9LCB0aGlzLnJlZnMuY2F0ZWdvcml6YXRpb24uZm9jdXNBZGRlZEl0ZW0pO1xuICAgIH0sXG5cbiAgICBkZWxldGVJdGVtOiBmdW5jdGlvbihyZW1vdmVJbmRleCkge1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnByb3BzLml0ZW1zLnNsaWNlKCk7XG4gICAgICAgIHZhciBjb3JyZWN0TG9jYXRpb25zID0gdGhpcy5wcm9wcy5jb3JyZWN0TG9jYXRpb25zLnNsaWNlKCk7XG4gICAgICAgIGl0ZW1zLnNwbGljZShyZW1vdmVJbmRleCwgMSk7XG4gICAgICAgIGNvcnJlY3RMb2NhdGlvbnMuc3BsaWNlKHJlbW92ZUluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICBpdGVtczogaXRlbXMsXG4gICAgICAgICAgICBjb3JyZWN0TG9jYXRpb25zOiBjb3JyZWN0TG9jYXRpb25zXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvbkNoYW5nZUNvbnRlbnQ6IGZ1bmN0aW9uKGl0ZW1JbmRleCwgY29udGVudCkge1xuICAgICAgICBpZiAoaXRlbUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnByb3BzLml0ZW1zLnNsaWNlKCk7XG4gICAgICAgIGl0ZW1zW2l0ZW1JbmRleF0gPSBfLmV4dGVuZCh7fSwgaXRlbXNbaXRlbUluZGV4XSwge2NvbnRlbnQ6IGNvbnRlbnR9KTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7aXRlbXM6IGl0ZW1zfSk7XG4gICAgfSxcblxuICAgIG9uQ2hhbmdlSGVhZGVyOiBmdW5jdGlvbihjYXRlZ29yeSwgY29udGVudCkge1xuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMucHJvcHMuY2F0ZWdvcnlIZWFkZXJzLnNsaWNlKCk7XG4gICAgICAgIGhlYWRlcnNbY2F0ZWdvcnkgLSAxXSA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2NhdGVnb3J5SGVhZGVyczogaGVhZGVyc30pO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVmcy5jYXRlZ29yaXphdGlvbi5mb2N1c0FkZGVkSXRlbSgpO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIganNvbiA9IF8ucGljayh0aGlzLnByb3BzLCBcIml0ZW1zXCIsIFwiY29ycmVjdExvY2F0aW9uc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImNhdGVnb3J5SGVhZGVyc1wiKTtcbiAgICAgICAganNvbi5pdGVtcyA9IF8ubWFwKGpzb24uaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpdGVtID0gXy5jbG9uZShpdGVtKTtcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtLmluZGV4O1xuICAgICAgICAgICAgaXRlbS5sb2NhdGlvbiA9IHtjYXRlZ29yeTogMCwgcG9zaXRpb246IGluZGV4fTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufSk7XG5cbldpZGdldHMucmVnaXN0ZXIoXCJjYXRlZ29yaXphdGlvblwiLCBDYXRlZ29yaXphdGlvbik7XG5XaWRnZXRzLnJlZ2lzdGVyKFwiY2F0ZWdvcml6YXRpb24tZWRpdG9yXCIsIENhdGVnb3JpemF0aW9uRWRpdG9yKTtcblxufSkoUGVyc2V1cyk7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbihmdW5jdGlvbihQZXJzZXVzKSB7XG5cbnJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xuXG52YXIgSW5mb1RpcCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2luZm8tdGlwLmpzeFwiKTtcbnZhciBXaWRnZXRzID0gcmVxdWlyZShcIi4uL3dpZGdldHMuanNcIik7XG5cbnZhciBEcm9wZG93biA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0Ryb3Bkb3duJyxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hvaWNlczogW3t9XSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5wcm9wcy5jaG9pY2VzLnNsaWNlKCk7XG4gICAgICAgIGNob2ljZXMudW5zaGlmdCh7XG4gICAgICAgICAgICBjb250ZW50OiBcIlwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE8oamFjayk6IFRoaXMgc2hvdWxkIGJhc2UgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gb24gaXRzIHByb3BzXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uc2VsZWN0KFxuICAgICAgICAgICAgICAgICAgICB7b25DaGFuZ2U6dGhpcy5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOlwicGVyc2V1cy13aWRnZXQtZHJvcGRvd25cIn0sIFxuICAgICAgICAgICAgY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5vcHRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICB7a2V5OlwiXCIgKyBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6aX0sIFxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UuY29udGVudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBvbkNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLmdldERPTU5vZGUoKS5zZWxlY3RlZEluZGV4O1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtzZWxlY3RlZDogc2VsZWN0ZWR9KTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICByZXR1cm4ge3ZhbHVlOiB0aGlzLmdldERPTU5vZGUoKS5zZWxlY3RlZEluZGV4fTtcbiAgICB9LFxuXG4gICAgc2ltcGxlVmFsaWRhdGU6IGZ1bmN0aW9uKHJ1YnJpYykge1xuICAgICAgICByZXR1cm4gRHJvcGRvd24udmFsaWRhdGUodGhpcy50b0pTT04oKSwgcnVicmljKTtcbiAgICB9LFxufSk7XG5cbl8uZXh0ZW5kKERyb3Bkb3duLCB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHN0YXRlLCBydWJyaWMpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gc3RhdGUudmFsdWU7XG4gICAgICAgIGlmIChzZWxlY3RlZCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvcnJlY3QgPSBydWJyaWMuY2hvaWNlc1tzZWxlY3RlZCAtIDFdLmNvcnJlY3Q7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgZWFybmVkOiBjb3JyZWN0ID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgRHJvcGRvd25FZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdEcm9wZG93bkVkaXRvcicsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNob2ljZXM6IFt7XG4gICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICBjb3JyZWN0OiB0cnVlXG4gICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZHJvcGRvd25Hcm91cE5hbWUgPSBfLnVuaXF1ZUlkKFwicGVyc2V1c19kcm9wZG93bl9cIik7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwicGVyc2V1cy13aWRnZXQtZHJvcGRvd25cIn0sIFxuICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIlRoZSBkcm9wIGRvd24gaXMgdXNlZnVsIGZvciBtYWtpbmcgaW5lcXVhbGl0aWVzIGluIGEgY3VzdG9tIFwiK1xuICAgICAgICAgICAgICAgIFwiZm9ybWF0LiBXZSBub3JtYWxseSB1c2UgdGhlIHN5bWJvbHMgXCIsIFwiPFwiLFwiLCBcIiwgXCI+XCIsXCIsIOKJpCwg4omlIChpbiBcIitcbiAgICAgICAgICAgICAgICBcInRoYXQgb3JkZXIpIHdoaWNoIHlvdSBjYW4gY29weSBpbnRvIHRoZSBjaG9pY2VzLiAgV2hlbiBcIitcbiAgICAgICAgICAgICAgICBcInBvc3NpYmxlLCB1c2UgdGhlIFxcXCJtdWx0aXBsZSBjaG9pY2VcXFwiIGFuc3dlciB0eXBlIFwiK1xuICAgICAgICAgICAgICAgIFwiaW5zdGVhZC5cIilcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00udWwobnVsbCwgXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jaG9pY2VzLm1hcChmdW5jdGlvbihjaG9pY2UsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5saSgge2tleTpcIlwiICsgaX0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJyYWRpb1wiICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTpcInJhZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ZHJvcGRvd25Hcm91cE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6Y2hvaWNlLmNvcnJlY3QgPyBcImNoZWNrZWRcIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMub25Db3JyZWN0Q2hhbmdlLmJpbmQodGhpcywgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOml9ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOlwiZWRpdG9yXCIgKyBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0OnRoaXMub25Db250ZW50Q2hhbmdlLmJpbmQodGhpcywgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOmNob2ljZS5jb250ZW50fSApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJhZGQtY2hvaWNlLWNvbnRhaW5lclwifSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmEoIHtocmVmOlwiI1wiLCBjbGFzc05hbWU6XCJzaW1wbGUtYnV0dG9uIG9yYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazp0aGlzLmFkZENob2ljZX0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge2NsYXNzTmFtZTpcImljb24tcGx1c1wifSApLFxuICAgICAgICAgICAgICAgICAgICBcIiBBZGQgYSBjaG9pY2UgXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uQ29ycmVjdENoYW5nZTogZnVuY3Rpb24oY2hvaWNlSW5kZXgpIHtcbiAgICAgICAgdmFyIGNob2ljZXMgPSBfLm1hcCh0aGlzLnByb3BzLmNob2ljZXMsIGZ1bmN0aW9uIChjaG9pY2UsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgY2hvaWNlLCB7XG4gICAgICAgICAgICAgICAgY29ycmVjdDogaSA9PT0gY2hvaWNlSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Y2hvaWNlczogY2hvaWNlc30pO1xuICAgIH0sXG5cbiAgICBvbkNvbnRlbnRDaGFuZ2U6IGZ1bmN0aW9uKGNob2ljZUluZGV4LCBlKSB7XG4gICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5wcm9wcy5jaG9pY2VzLnNsaWNlKCk7XG4gICAgICAgIHZhciBjaG9pY2UgPSBfLmNsb25lKGNob2ljZXNbY2hvaWNlSW5kZXhdKTtcbiAgICAgICAgY2hvaWNlLmNvbnRlbnQgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgY2hvaWNlc1tjaG9pY2VJbmRleF0gPSBjaG9pY2U7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2Nob2ljZXM6IGNob2ljZXN9KTtcbiAgICB9LFxuXG4gICAgYWRkQ2hvaWNlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgY2hvaWNlcyA9IHRoaXMucHJvcHMuY2hvaWNlcztcbiAgICAgICAgdmFyIGJsYW5rQ2hvaWNlID0ge2NvbnRlbnQ6IFwiXCIsIGNvcnJlY3Q6IGZhbHNlfTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICBjaG9pY2VzOiBjaG9pY2VzLmNvbmNhdChbYmxhbmtDaG9pY2VdKVxuICAgICAgICB9LCB0aGlzLmZvY3VzLmJpbmQodGhpcywgY2hvaWNlcy5sZW5ndGgpKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdGhpcy5yZWZzW1wiZWRpdG9yXCIgKyBpXS5nZXRET01Ob2RlKCkuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF8ucGljayh0aGlzLnByb3BzLCAnY2hvaWNlcycpO1xuICAgIH1cbn0pO1xuXG5XaWRnZXRzLnJlZ2lzdGVyKFwiZHJvcGRvd25cIiwgRHJvcGRvd24pO1xuV2lkZ2V0cy5yZWdpc3RlcihcImRyb3Bkb3duLWVkaXRvclwiLCBEcm9wZG93bkVkaXRvcik7XG5cbn0pKFBlcnNldXMpO1xuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG4oZnVuY3Rpb24oUGVyc2V1cykge1xuXG5yZXF1aXJlKFwiLi4vY29yZS5qc1wiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG5cbnZhciBJbmZvVGlwID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvaW5mby10aXAuanN4XCIpO1xudmFyIFRlWCAgICAgPSByZXF1aXJlKFwiLi4vdGV4LmpzeFwiKTsgIC8vIEthVGVYIGFuZC9vciBNYXRoSmF4XG52YXIgV2lkZ2V0cyA9IHJlcXVpcmUoXCIuLi93aWRnZXRzLmpzXCIpO1xuXG52YXIgRXhwcmVzc2lvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0V4cHJlc3Npb24nLFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICB0aW1lczogZmFsc2UsXG4gICAgICAgICAgICBmdW5jdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXN0UGFyc2VkVGV4OiBcIlwiXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbih2YWx1ZSwgcHJvcHMpIHtcbiAgICAgICAgLy8gVE9ETyhqYWNrKTogRGlzYWJsZSBpY3UgZm9yIGNvbnRlbnQgY3JlYXRvcnMgaGVyZSwgb3JcbiAgICAgICAgLy8gbWFrZSBpdCBzbyB0aGF0IHNvbHV0aW9uIGFuc3dlcnMgd2l0aCAnLCdzIG9yICcuJ3Mgd29ya1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF8ucGljayhwcm9wcyB8fCB0aGlzLnByb3BzLCBcImZ1bmN0aW9uc1wiKTtcbiAgICAgICAgaWYgKGljdSAmJiBpY3UuZ2V0RGVjaW1hbEZvcm1hdFN5bWJvbHMpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKG9wdGlvbnMsIGljdS5nZXREZWNpbWFsRm9ybWF0U3ltYm9scygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gS0FTLnBhcnNlKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJzZWRUZXgodGhpcy5wcm9wcy5jdXJyZW50VmFsdWUpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJzZWRUZXgobmV4dFByb3BzLmN1cnJlbnRWYWx1ZSwgbmV4dFByb3BzKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2UodGhpcy5wcm9wcy5jdXJyZW50VmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uc3Bhbigge2NsYXNzTmFtZTpcInBlcnNldXMtd2lkZ2V0LWV4cHJlc3Npb25cIn0sIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7cmVmOlwiaW5wdXRcIiwgdHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvbktleURvd246dGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgICAgIG9uS2V5UHJlc3M6dGhpcy5oYW5kbGVLZXlQcmVzcyxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmhhbmRsZUNoYW5nZX0gKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwib3V0cHV0XCJ9LCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge2NsYXNzTmFtZTpcInRleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6e29wYWNpdHk6IHJlc3VsdC5wYXJzZWQgPyAxLjAgOiAwLjV9fSwgXG4gICAgICAgICAgICAgICAgICAgIFRlWChudWxsLCB0aGlzLnN0YXRlLmxhc3RQYXJzZWRUZXgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge2NsYXNzTmFtZTpcInBsYWNlaG9sZGVyXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtyZWY6XCJlcnJvclwiLCBjbGFzc05hbWU6XCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOntkaXNwbGF5OiBcIm5vbmVcIn19LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwiYnVkZHlcIn0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwibWVzc2FnZVwifSwgUmVhY3QuRE9NLnNwYW4obnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTb3JyeSwgSSBkb24ndCB1bmRlcnN0YW5kIHRoYXQhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGVycm9yVGltZW91dDogbnVsbCxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXJyb3JUaW1lb3V0KTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UodGhpcy5wcm9wcy5jdXJyZW50VmFsdWUpLnBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlRXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnNob3dFcnJvciwgMjAwMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lcnJvclRpbWVvdXQpO1xuICAgIH0sXG5cbiAgICBzaG93RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgJGVycm9yID0gJCh0aGlzLnJlZnMuZXJyb3IuZ2V0RE9NTm9kZSgpKTtcbiAgICAgICAgaWYgKCEkZXJyb3IuaXMoXCI6dmlzaWJsZVwiKSkge1xuICAgICAgICAgICAgJGVycm9yLmNzcyh7IHRvcDogNTAsIG9wYWNpdHk6IDAuMSB9KS5zaG93KClcbiAgICAgICAgICAgICAgICAuYW5pbWF0ZSh7IHRvcDogMCwgb3BhY2l0eTogMS4wIH0sIDMwMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGlkZUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRlcnJvciA9ICQodGhpcy5yZWZzLmVycm9yLmdldERPTU5vZGUoKSk7XG4gICAgICAgIGlmICgkZXJyb3IuaXMoXCI6dmlzaWJsZVwiKSkge1xuICAgICAgICAgICAgJGVycm9yLmFuaW1hdGUoeyB0b3A6IDUwLCBvcGFjaXR5OiAwLjEgfSwgMzAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXlkb3duIGhhbmRsZXIgaGFuZGxlcyBjbGVhcmluZyB0aGUgZXJyb3IgdGltZW91dCwgdGVsbGluZ1xuICAgICAqIHByb3BzLmN1cnJlbnRWYWx1ZSB0byB1cGRhdGUsIGFuZCBpbnRlcmNlcHRpbmcgdGhlIGJhY2tzcGFjZSBrZXkgd2hlblxuICAgICAqIGFwcHJvcHJpYXRlLi4uXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5yZWZzLmlucHV0LmdldERPTU5vZGUoKTtcbiAgICAgICAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZTtcblxuICAgICAgICB2YXIgc3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IGlucHV0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgdmFyIHN1cHBvcnRlZCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIHdoaWNoID0gZXZlbnQubmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICAgICAgICBpZiAoc3VwcG9ydGVkICYmIHdoaWNoID09PSA4IC8qIGJhY2tzcGFjZSAqLykge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgJiYgdGV4dC5zbGljZShzdGFydCAtIDEsIHN0YXJ0ICsgMSkgPT09IFwiKClcIikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRleHQuc2xpY2UoMCwgc3RhcnQgLSAxKSArIHRleHQuc2xpY2Uoc3RhcnQgKyAxKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMucHJvcHMub25DaGFuZ2Ugd2lsbCB1cGRhdGUgdGhlIHZhbHVlIGZvciB1cywgYnV0XG4gICAgICAgICAgICAgICAgLy8gYXN5bmNocm9ub3VzbHksIG1ha2luZyBpdCBoYXJkZXIgdG8gc2V0IHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyB1c2VmdWxseSwgc28gd2UganVzdCBzZXQgLnZhbHVlIGRpcmVjdGx5IGhlcmUgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBlbmQgLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2N1cnJlbnRWYWx1ZTogdmFsfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogLi4ud2hlcmVhcyB0aGUga2V5cHJlc3MgaGFuZGxlciBoYW5kbGVzIHRoZSBwYXJlbnRoZXNlcyBiZWNhdXNlIGtleUNvZGVcbiAgICAgKiBpcyBtb3JlIHVzZWZ1bCBmb3IgYWN0dWFsIGNoYXJhY3RlciBpbnNlcnRpb25zIChrZXlwcmVzcyBnaXZlcyA0MCBmb3IgYW5cbiAgICAgKiBvcGVuIHBhcmVuICcoJyBpbnN0ZWFkIG9mIGtleWRvd24gd2hpY2ggZ2l2ZXMgNTcsIHRoZSBjb2RlIGZvciAnOScpLlxuICAgICAqL1xuICAgIGhhbmRsZUtleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnJlZnMuaW5wdXQuZ2V0RE9NTm9kZSgpO1xuICAgICAgICB2YXIgdGV4dCA9IGlucHV0LnZhbHVlO1xuXG4gICAgICAgIHZhciBzdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICB2YXIgc3VwcG9ydGVkID0gc3RhcnQgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgd2hpY2ggPSBldmVudC5uYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgICAgICBpZiAoc3VwcG9ydGVkICYmIHdoaWNoID09PSA0MCAvKiBsZWZ0IHBhcmVuICovKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0TWF0Y2hlZCA9IF8uYW55KFtcIiBcIiwgXCIpXCIsIFwiXCJdLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQuY2hhckF0KHN0YXJ0KSA9PT0gdmFsO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFsID0gdGV4dC5zbGljZSgwLCBzdGFydCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGluc2VydE1hdGNoZWQgPyBcIigpXCIgOiBcIihcIikgKyB0ZXh0LnNsaWNlKGVuZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRleHQuc2xpY2UoMCwgc3RhcnQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiICsgdGV4dC5zbGljZShzdGFydCwgZW5kKSArIFwiKVwiICsgdGV4dC5zbGljZShlbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQgKyAxO1xuICAgICAgICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gZW5kICsgMTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2N1cnJlbnRWYWx1ZTogdmFsfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0ZWQgJiYgd2hpY2ggPT09IDQxIC8qIHJpZ2h0IHBhcmVuICovKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCAmJiB0ZXh0LmNoYXJBdChzdGFydCkgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Y3VycmVudFZhbHVlOiBldmVudC50YXJnZXQudmFsdWV9KTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnMuaW5wdXQuZ2V0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7Y3VycmVudFZhbHVlOiB0aGlzLnByb3BzLmN1cnJlbnRWYWx1ZX07XG4gICAgfSxcblxuICAgIHVwZGF0ZVBhcnNlZFRleDogZnVuY3Rpb24odmFsdWUsIHByb3BzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlKHZhbHVlLCBwcm9wcyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gXy5waWNrKHRoaXMucHJvcHMsIFwidGltZXNcIik7XG4gICAgICAgIGlmIChyZXN1bHQucGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtsYXN0UGFyc2VkVGV4OiByZXN1bHQuZXhwci5hc1RleChvcHRpb25zKX0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNpbXBsZVZhbGlkYXRlOiBmdW5jdGlvbihydWJyaWMpIHtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb24udmFsaWRhdGUodGhpcy50b0pTT04oKSwgcnVicmljKTtcbiAgICB9LFxuXG4gICAgZXhhbXBsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXVsdCA9ICQuXyhcIkZvciAkMlxcXFxjZG90MiQsIGVudGVyICoqMioyKipcIik7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnRpbWVzKSB7XG4gICAgICAgICAgICBtdWx0ID0gbXVsdC5yZXBsYWNlKC9cXFxcY2RvdC9nLCBcIlxcXFx0aW1lc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtdWx0LFxuICAgICAgICAgICAgJC5fKFwiRm9yICQzeSQsIGVudGVyICoqM3kqKiBvciAqKjMqeSoqXCIpLFxuICAgICAgICAgICAgJC5fKFwiRm9yICRcXFxcZGZyYWN7MX17eH0kLCBlbnRlciAqKjEveCoqXCIpLFxuICAgICAgICAgICAgJC5fKFwiRm9yICR4Xnt5fSQsIGVudGVyICoqeF55KipcIiksXG4gICAgICAgICAgICAkLl8oXCJGb3IgJFxcXFxzcXJ0e3h9JCwgZW50ZXIgKipzcXJ0KHgpKipcIiksXG4gICAgICAgICAgICAkLl8oXCJGb3IgJFxcXFxwaSQsIGVudGVyICoqcGkqKlwiKSxcbiAgICAgICAgICAgICQuXyhcIkZvciAkXFxcXHNpbiBcXFxcdGhldGEkLCBlbnRlciAqKnNpbih0aGV0YSkqKlwiKSxcbiAgICAgICAgICAgICQuXyhcIkZvciAkXFxcXGxlJCBvciAkXFxcXGdlJCwgZW50ZXIgKio8PSoqIG9yICoqPj0qKlwiKSxcbiAgICAgICAgICAgICQuXyhcIkZvciAkXFxcXG5lcSQsIGVudGVyICoqPS89KipcIilcbiAgICAgICAgXTtcbiAgICB9XG59KTtcblxuXy5leHRlbmQoRXhwcmVzc2lvbiwge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbihzdGF0ZSwgcnVicmljKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gXy5jbG9uZShydWJyaWMpO1xuICAgICAgICBpZiAoaWN1ICYmIGljdS5nZXREZWNpbWFsRm9ybWF0U3ltYm9scykge1xuICAgICAgICAgICAgXy5leHRlbmQob3B0aW9ucywgaWN1LmdldERlY2ltYWxGb3JtYXRTeW1ib2xzKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvbid0IGdpdmUgb3B0aW9ucyB0byBLQVMucGFyc2UgaGVyZSBiZWNhdXNlIHRoYXQgaXMgcGFyc2luZ1xuICAgICAgICAvLyB0aGUgc29sdXRpb24gYW5zd2VyLCBub3QgdGhlIHN0dWRlbnQgYW5zd2VyLCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgLy8gd2FudCBhIHNvbHV0aW9uIHRvIHdvcmsgaWYgdGhlIHN0dWRlbnQgaXMgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gbGFuZ3VhZ2UgYnV0IG5vdCBpbiBlbmdsaXNoLlxuICAgICAgICB2YXIgdmFsID0gS2hhbi5hbnN3ZXJUeXBlcy5leHByZXNzaW9uLmNyZWF0ZVZhbGlkYXRvckZ1bmN0aW9uYWwoXG4gICAgICAgICAgICBLQVMucGFyc2UocnVicmljLnZhbHVlLCBydWJyaWMpLmV4cHIsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB2YWwoc3RhdGUuY3VycmVudFZhbHVlKTtcblxuICAgICAgICAvLyBUT0RPKGVhdGVyKTogU2VlbXMgc2lsbHkgdG8gdHJhbnNsYXRlIHJlc3VsdCB0byB0aGlzIGludmFsaWQvcG9pbnRzXG4gICAgICAgIC8vIHRoaW5nIGFuZCBpbW1lZGlhdGVseSB0cmFuc2xhdGUgaXQgYmFjayBpbiBJdGVtUmVuZGVyZXIuc2NvcmVJbnB1dCgpXG4gICAgICAgIGlmIChyZXN1bHQuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgZWFybmVkOiByZXN1bHQuY29ycmVjdCA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBFeHByZXNzaW9uRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnRXhwcmVzc2lvbkVkaXRvcicsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm06IGZhbHNlLFxuICAgICAgICAgICAgc2ltcGxpZnk6IGZhbHNlLFxuICAgICAgICAgICAgdGltZXM6IGZhbHNlLFxuICAgICAgICAgICAgZnVuY3Rpb25zOiBbXCJmXCIsIFwiZ1wiLCBcImhcIl1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb3B0aW9uTGFiZWxzOiB7XG4gICAgICAgIGZvcm06IHtcbiAgICAgICAgICAgIGxhYmVsVGV4dDogXCJBbnN3ZXIgZXhwcmVzc2lvbiBtdXN0IGhhdmUgdGhlIHNhbWUgZm9ybS5cIixcbiAgICAgICAgICAgIGluZm9UaXA6IFwiVGhlIHN0dWRlbnQncyBhbnN3ZXIgbXVzdCBiZSBpbiB0aGUgc2FtZSBmb3JtLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiQ29tbXV0YXRpdml0eSBhbmQgZXhjZXNzIG5lZ2F0aXZlIHNpZ25zIGFyZSBpZ25vcmVkLlwiXG4gICAgICAgIH0sXG4gICAgICAgIHNpbXBsaWZ5OiB7XG4gICAgICAgICAgICBsYWJlbFRleHQ6IFwiQW5zd2VyIGV4cHJlc3Npb24gbXVzdCBiZSBmdWxseSBleHBhbmRlZCBhbmQgXCIgK1xuICAgICAgICAgICAgICAgIFwic2ltcGxpZmllZC5cIixcbiAgICAgICAgICAgIGluZm9UaXA6IFwiVGhlIHN0dWRlbnQncyBhbnN3ZXIgbXVzdCBiZSBmdWxseSBleHBhbmRlZCBhbmQgXCIgK1xuICAgICAgICAgICAgICAgIFwiIHNpbXBsaWZpZWQuIEFuc3dlcmluZyB0aGlzIGVxdWF0aW9uICh4XjIrMngrMSkgd2l0aCB0aGlzIFwiICtcbiAgICAgICAgICAgICAgICBcIiBmYWN0b3JlZCBlcXVhdGlvbiAoeCsxKV4yIHdpbGwgcmVuZGVyIHRoaXMgcmVzcG9uc2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiXFxcIllvdXIgYW5zd2VyIGlzIG5vdCBmdWxseSBleHBhbmRlZCBhbmQgc2ltcGxpZmllZC5cXFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXM6IHtcbiAgICAgICAgICAgIGxhYmVsVGV4dDogXCJVc2UgXFx1MDBkNyBmb3IgcmVuZGVyaW5nIG11bHRpcGxpY2F0aW9uIGluc3RlYWQgb2YgXCIgK1xuICAgICAgICAgICAgICAgIFwiYSBjZW50ZXIgZG90LlwiLFxuICAgICAgICAgICAgaW5mb1RpcDogXCJGb3IgcHJlLWFsZ2VicmEgcHJvYmxlbXMgdGhpcyBvcHRpb24gZGlzcGxheXMgXCIgK1xuICAgICAgICAgICAgICAgIFwibXVsdGlwbGljYXRpb24gYXMgXFxcXHRpbWVzIGluc3RlYWQgb2YgXFxcXGNkb3QgaW4gYm90aCB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIFwicmVuZGVyZWQgb3V0cHV0IGFuZCB0aGUgYWNjZXB0YWJsZSBmb3JtYXRzIGV4YW1wbGVzLlwiXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNpbXBsaWZ5V2FybmluZyA9IG51bGw7XG4gICAgICAgIHZhciBzaG91bGRUcnlUb1BhcnNlID0gdGhpcy5wcm9wcy5zaW1wbGlmeSAmJiB0aGlzLnByb3BzLnZhbHVlICE9PSBcIlwiO1xuICAgICAgICBpZiAoc2hvdWxkVHJ5VG9QYXJzZSkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBLQVMucGFyc2UodGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5wYXJzZWQgJiYgIWV4cHJlc3Npb24uZXhwci5pc1NpbXBsaWZpZWQoKSkge1xuICAgICAgICAgICAgICAgIHNpbXBsaWZ5V2FybmluZyA9IFJlYWN0LkRPTS5wKCB7Y2xhc3NOYW1lOlwid2FybmluZ1wifSwgUmVhY3QuRE9NLmIobnVsbCwgXCJXYXJuaW5nXCIpLFwiOiBZb3UgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwic3BlY2lmaWVkIHRoYXQgdGhlIGFuc3dlciBzaG91bGQgYmUgc2ltcGxpZmllZCBidXQgZGlkIG5vdCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJwcm92aWRlIGEgc2ltcGxpZmllZCBhbnN3ZXIuIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlIHNpbXBsaWZpY2F0aW9uP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgQ29ycmVjdCBhbnN3ZXI6IFwiLFxuICAgICAgICAgICAgICAgIEV4cHJlc3Npb24oIHtyZWY6XCJleHByZXNzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTp0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0aW1lczp0aGlzLnByb3BzLnRpbWVzLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnM6dGhpcy5wcm9wcy5mdW5jdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJjdXJyZW50VmFsdWVcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnZhbHVlID0gbmV3UHJvcHMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdQcm9wcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG5ld1Byb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSApXG4gICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgc2ltcGxpZnlXYXJuaW5nLFxuXG4gICAgICAgICAgICBfLm1hcCh0aGlzLm9wdGlvbkxhYmVscywgZnVuY3Rpb24ob3B0aW9uRGF0YSwgb3B0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KG51bGwsIFJlYWN0LkRPTS5sYWJlbCgge2tleTpvcHRpb25OYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJjaGVja2JveFwiLCBuYW1lOm9wdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOnRoaXMucHJvcHNbb3B0aW9uTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmhhbmRsZUNoZWNrfSApLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25EYXRhLmxhYmVsVGV4dFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBSZWFjdC5ET00ucChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uRGF0YS5pbmZvVGlwXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICBcIkZ1bmN0aW9uIHZhcmlhYmxlczogXCIsXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOnRoaXMucHJvcHMuZnVuY3Rpb25zLmpvaW4oXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmhhbmRsZUZ1bmN0aW9uc30gKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBSZWFjdC5ET00ucChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgU2luZ2xlLWxldHRlciB2YXJpYWJsZXMgbGlzdGVkIGhlcmUgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbnMuIFRoaXMgbGV0IHVzIGtub3cgdGhhdCBmKHgpIG1lYW5zIFxcXCJmIG9mIHhcXFwiIGFuZCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJub3QgXFxcImYgdGltZXMgeFxcXCIuIFwiXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlQ2hlY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG5ld1Byb3BzID0ge307XG4gICAgICAgIG5ld1Byb3BzW2UudGFyZ2V0Lm5hbWVdID0gZS50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShuZXdQcm9wcyk7XG4gICAgfSxcblxuICAgIGhhbmRsZUZ1bmN0aW9uczogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgbmV3UHJvcHMuZnVuY3Rpb25zID0gXy5jb21wYWN0KGUudGFyZ2V0LnZhbHVlLnNwbGl0KC9bICxdKy8pKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShuZXdQcm9wcyk7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWZzLmV4cHJlc3Npb24uZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcblxuICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBhbGVydChcIldhcm5pbmc6IE5vIGV4cHJlc3Npb24gaGFzIGJlZW4gZW50ZXJlZC5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnJlZnMuZXhwcmVzc2lvbi5wYXJzZSh2YWx1ZSkucGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBFbnRlcmVkIGV4cHJlc3Npb24gZGlkbid0IHBhcnNlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfLnBpY2sodGhpcy5wcm9wcywgXCJ2YWx1ZVwiLCBcImZvcm1cIiwgXCJzaW1wbGlmeVwiLFxuICAgICAgICAgICAgXCJ0aW1lc1wiLCBcImZ1bmN0aW9uc1wiKTtcbiAgICB9XG59KTtcblxuV2lkZ2V0cy5yZWdpc3RlcihcImV4cHJlc3Npb25cIiwgRXhwcmVzc2lvbik7XG5XaWRnZXRzLnJlZ2lzdGVyKFwiZXhwcmVzc2lvbi1lZGl0b3JcIiwgRXhwcmVzc2lvbkVkaXRvcik7XG5cbn0pKFBlcnNldXMpO1xuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG4oZnVuY3Rpb24oUGVyc2V1cykge1xuXG5yZXF1aXJlKFwiLi4vY29yZS5qc1wiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG5cbnZhciBJbmZvVGlwID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvaW5mby10aXAuanN4XCIpO1xudmFyIFdpZGdldHMgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy5qc1wiKTtcbnZhciBCbHVySW5wdXQgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9ibHVyLWlucHV0LmpzeFwiKTtcblxudmFyIGFuc3dlclR5cGVzID0ge1xuICAgIG51bWJlcjoge1xuICAgICAgICBuYW1lOiBcIk51bWJlcnNcIixcbiAgICAgICAgZm9ybXM6IFwiaW50ZWdlciwgZGVjaW1hbCwgcHJvcGVyLCBpbXByb3BlciwgbWl4ZWRcIlxuICAgIH0sXG4gICAgZGVjaW1hbDoge1xuICAgICAgICBuYW1lOiBcIkRlY2ltYWxzXCIsXG4gICAgICAgIGZvcm1zOiBcImRlY2ltYWxcIlxuICAgIH0sXG4gICAgaW50ZWdlcjoge1xuICAgICAgICBuYW1lOiBcIkludGVnZXJzXCIsXG4gICAgICAgIGZvcm1zOiBcImludGVnZXJcIlxuICAgIH0sXG4gICAgcmF0aW9uYWw6IHtcbiAgICAgICAgbmFtZTogXCJGcmFjdGlvbnMgYW5kIG1peGVkIG51bWJlcnNcIixcbiAgICAgICAgZm9ybXM6IFwiaW50ZWdlciwgcHJvcGVyLCBpbXByb3BlciwgbWl4ZWRcIlxuICAgIH0sXG4gICAgaW1wcm9wZXI6IHtcbiAgICAgICAgbmFtZTogXCJJbXByb3BlciBudW1iZXJzIChubyBtaXhlZClcIixcbiAgICAgICAgZm9ybXM6IFwiaW50ZWdlciwgcHJvcGVyLCBpbXByb3BlclwiXG4gICAgfSxcbiAgICBtaXhlZDoge1xuICAgICAgICBuYW1lOiBcIk1peGVkIG51bWJlcnMgKG5vIGltcHJvcGVyKVwiLFxuICAgICAgICBmb3JtczogXCJpbnRlZ2VyLCBwcm9wZXIsIG1peGVkXCJcbiAgICB9LFxuICAgIHBlcmNlbnQ6IHtcbiAgICAgICAgbmFtZTogXCJOdW1iZXJzIG9yIHBlcmNlbnRzXCIsXG4gICAgICAgIGZvcm1zOiBcImludGVnZXIsIGRlY2ltYWwsIHByb3BlciwgaW1wcm9wZXIsIG1peGVkLCBwZXJjZW50XCJcbiAgICB9LFxuICAgIHBpOiB7XG4gICAgICAgIG5hbWU6IFwiTnVtYmVycyB3aXRoIHBpXCIsIGZvcm1zOiBcInBpXCJcbiAgICB9XG59O1xuXG52YXIgZm9ybUV4YW1wbGVzID0ge1xuICAgIFwiaW50ZWdlclwiOiBmdW5jdGlvbihvcHRpb25zKSB7IHJldHVybiAkLl8oXCJhbiBpbnRlZ2VyLCBsaWtlICQ2JFwiKTsgfSxcbiAgICBcInByb3BlclwiOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpbXBsaWZ5ID09PSBcIm9wdGlvbmFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAkLl8oXCJhICpwcm9wZXIqIGZyYWN0aW9uLCBsaWtlICQxLzIkIG9yICQ2LzEwJFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkLl8oXCJhICpzaW1wbGlmaWVkIHByb3BlciogZnJhY3Rpb24sIGxpa2UgJDMvNSRcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiaW1wcm9wZXJcIjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaW1wbGlmeSA9PT0gXCJvcHRpb25hbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5fKFwiYW4gKmltcHJvcGVyKiBmcmFjdGlvbiwgbGlrZSAkMTAvNyQgb3IgJDE0LzgkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICQuXyhcImEgKnNpbXBsaWZpZWQgaW1wcm9wZXIqIGZyYWN0aW9uLCBsaWtlICQ3LzQkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcIm1peGVkXCI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICQuXyhcImEgbWl4ZWQgbnVtYmVyLCBsaWtlICQxXFxcXCAzLzQkXCIpO1xuICAgIH0sXG4gICAgXCJkZWNpbWFsXCI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICQuXyhcImFuICpleGFjdCogZGVjaW1hbCwgbGlrZSAkMC43NSRcIik7XG4gICAgfSxcbiAgICBcInBlcmNlbnRcIjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gJC5fKFwiYSBwZXJjZW50LCBsaWtlICQxMi4zNFxcXFwlJFwiKTtcbiAgICB9LFxuICAgIFwicGlcIjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gJC5fKFwiYSBtdWx0aXBsZSBvZiBwaSwgbGlrZSAkMTJcXFxcIFxcXFx0ZXh0e3BpfSQgb3IgXCIgK1xuICAgICAgICAgICAgICAgIFwiJDIvM1xcXFwgXFxcXHRleHR7cGl9JFwiKTtcbiAgICB9XG59O1xuXG52YXIgSW5wdXROdW1iZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdJbnB1dE51bWJlcicsXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVE9ETyhqYWNrKTogUHJvYmFibHkgbWFrZSB0aGlzIHN5bmMgdXAgd2l0aCBpdHMgcHJvcHNcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJ0ZXh0XCIsIGNsYXNzTmFtZTpcbiAgICAgICAgICAgIFwicGVyc2V1cy1pbnB1dC1zaXplLVwiICsgKHRoaXMucHJvcHMuc2l6ZSB8fCBcIm5vcm1hbFwiKX0gKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldERPTU5vZGUoKS5mb2N1cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0RE9NTm9kZSgpLnZhbHVlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNpbXBsZVZhbGlkYXRlOiBmdW5jdGlvbihydWJyaWMpIHtcbiAgICAgICAgcmV0dXJuIElucHV0TnVtYmVyLnZhbGlkYXRlKHRoaXMudG9KU09OKCksIHJ1YnJpYyk7XG4gICAgfSxcblxuICAgIGV4YW1wbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnByb3BzLmFuc3dlclR5cGUgfHwgXCJudW1iZXJcIjtcbiAgICAgICAgdmFyIGZvcm1zID0gYW5zd2VyVHlwZXNbdHlwZV0uZm9ybXMuc3BsaXQoL1xccyosXFxzKi8pO1xuXG4gICAgICAgIHZhciBleGFtcGxlcyA9IF8ubWFwKGZvcm1zLCBmdW5jdGlvbihmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybUV4YW1wbGVzW2Zvcm1dKHRoaXMucHJvcHMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgfVxufSk7XG5cbl8uZXh0ZW5kKElucHV0TnVtYmVyLCB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHN0YXRlLCBydWJyaWMpIHtcbiAgICAgICAgaWYgKHJ1YnJpYy5hbnN3ZXJUeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1YnJpYy5hbnN3ZXJUeXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsID0gS2hhbi5hbnN3ZXJUeXBlcy5udW1iZXIuY3JlYXRlVmFsaWRhdG9yRnVuY3Rpb25hbChcbiAgICAgICAgICAgIHJ1YnJpYy52YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNpbXBsaWZ5OiBydWJyaWMuc2ltcGxpZnksXG4gICAgICAgICAgICAgICAgaW5leGFjdDogcnVicmljLmluZXhhY3QgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1heEVycm9yOiBydWJyaWMubWF4RXJyb3IsXG4gICAgICAgICAgICAgICAgZm9ybXM6IGFuc3dlclR5cGVzW3J1YnJpYy5hbnN3ZXJUeXBlXS5mb3Jtc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHZhbChzdGF0ZS52YWx1ZSk7XG5cbiAgICAgICAgLy8gVE9ETyhlYXRlcik6IFNlZW1zIHNpbGx5IHRvIHRyYW5zbGF0ZSByZXN1bHQgdG8gdGhpcyBpbnZhbGlkL3BvaW50c1xuICAgICAgICAvLyB0aGluZyBhbmQgaW1tZWRpYXRlbHkgdHJhbnNsYXRlIGl0IGJhY2sgaW4gSXRlbVJlbmRlcmVyLnNjb3JlSW5wdXQoKVxuICAgICAgICBpZiAocmVzdWx0LmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgIGVhcm5lZDogcmVzdWx0LmNvcnJlY3QgPyAxIDogMCxcbiAgICAgICAgICAgICAgICB0b3RhbDogMSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgSW5wdXROdW1iZXJFZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdJbnB1dE51bWJlckVkaXRvcicsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIjBcIixcbiAgICAgICAgICAgIHNpbXBsaWZ5OiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICBzaXplOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgaW5leGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtYXhFcnJvcjogMC4xLFxuICAgICAgICAgICAgYW5zd2VyVHlwZTogXCJudW1iZXJcIlxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBoYW5kbGVBbnN3ZXJDaGFuZ2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgdmFsdWUgPSBVdGlsLmZpcnN0TnVtZXJpY2FsUGFyc2Uoc3RyKSB8fCAwO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHt2YWx1ZTogdmFsdWV9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuc3dlclR5cGVPcHRpb25zID0gXy5tYXAoYW5zd2VyVHlwZXMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6a30sIHYubmFtZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgQ29ycmVjdCBhbnN3ZXI6IFwiLFxuICAgICAgICAgICAgICAgIEJsdXJJbnB1dCgge3ZhbHVlOlwiXCIgKyB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5oYW5kbGVBbnN3ZXJDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6XCJpbnB1dFwifSApXG4gICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIFVuc2ltcGxpZmllZCBhbnN3ZXJzIFwiLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KCB7dmFsdWU6dGhpcy5wcm9wcy5zaW1wbGlmeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe3NpbXBsaWZ5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKX0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwicmVxdWlyZWRcIn0sIFwid2lsbCBub3QgYmUgZ3JhZGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwib3B0aW9uYWxcIn0sIFwid2lsbCBiZSBhY2NlcHRlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImVuZm9yY2VkXCJ9LCBcIndpbGwgYmUgbWFya2VkIHdyb25nXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiTm9ybWFsbHkgc2VsZWN0IFxcXCJ3aWxsIG5vdCBiZSBncmFkZWRcXFwiLiBUaGlzIHdpbGwgZ2l2ZSB0aGUgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwidXNlciBhIG1lc3NhZ2Ugc2F5aW5nIHRoZSBhbnN3ZXIgaXMgY29ycmVjdCBidXQgbm90IFwiK1xuICAgICAgICAgICAgICAgICAgICBcInNpbXBsaWZpZWQuIFRoZSB1c2VyIHdpbGwgdGhlbiBoYXZlIHRvIHNpbXBsaWZ5IGl0IGFuZCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJyZS1lbnRlciwgYnV0IHdpbGwgbm90IGJlIHBlbmFsaXplZC4gKDV0aCBncmFkZSBhbmQgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwiYW55dGhpbmcgYWZ0ZXIpXCIpLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIlNlbGVjdCBcXFwid2lsbCBiZSBhY2NlcHRlZFxcXCIgb25seSBpZiB0aGUgdXNlciBpcyBub3QgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgdG8ga25vdyBob3cgdG8gc2ltcGxpZnkgZnJhY3Rpb25zIHlldC4gKEFueXRoaW5nIFwiK1xuICAgICAgICAgICAgICAgICAgICBcInByaW9yIHRvIDV0aCBncmFkZSlcIiksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiU2VsZWN0IFxcXCJ3aWxsIGJlIG1hcmtlZCB3cm9uZ1xcXCIgb25seSBpZiB3ZSBhcmUgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwic3BlY2lmaWNhbGx5IGFzc2Vzc2luZyB0aGUgYWJpbGl0eSB0byBzaW1wbGlmeS5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoIHt0eXBlOlwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDp0aGlzLnByb3BzLmluZXhhY3QsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2luZXhhY3Q6IGUudGFyZ2V0LmNoZWNrZWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSApLFxuICAgICAgICAgICAgICAgIFwiIEFsbG93IGluZXhhY3QgYW5zd2VycyBcIlxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCAvKiBUT0RPKGVtaWx5KTogZG9uJ3QgdXNlIGEgaGlkZGVuIGNoZWNrYm94IGZvciBhbGlnbm1lbnQgKi9cbiAgICAgICAgICAgICAgICB7dHlwZTpcImNoZWNrYm94XCIsIHN0eWxlOnt2aXNpYmlsaXR5OiBcImhpZGRlblwifX0gKSxcbiAgICAgICAgICAgIFwiIE1heCBlcnJvcjogXCIsXG4gICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoIHt0eXBlOlwidGV4dFwiLCBkaXNhYmxlZDohdGhpcy5wcm9wcy5pbmV4YWN0LFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTp0aGlzLnByb3BzLm1heEVycm9yLFxuICAgICAgICAgICAgICAgIG9uQmx1cjpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnMgPSBcIlwiICsgKFV0aWwuZmlyc3ROdW1lcmljYWxQYXJzZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZSkgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gYW5zO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHttYXhFcnJvcjogYW5zfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSApXG4gICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgIFwiIEFuc3dlciB0eXBlOiBcIixcbiAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoXG4gICAgICAgICAgICAgICAge3ZhbHVlOnRoaXMucHJvcHMuYW5zd2VyVHlwZSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2Fuc3dlclR5cGU6IGUudGFyZ2V0LnZhbHVlfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSwgXG4gICAgICAgICAgICAgICAgYW5zd2VyVHlwZU9wdGlvbnNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiVXNlIHRoZSBkZWZhdWx0IFxcXCJOdW1iZXJzXFxcIiB1bmxlc3MgdGhlIGFuc3dlciBtdXN0IGJlIGluIGEgXCIrXG4gICAgICAgICAgICAgICAgXCJzcGVjaWZpYyBmb3JtIChlLmcuLCBxdWVzdGlvbiBpcyBhYm91dCBjb252ZXJ0aW5nIGRlY2ltYWxzIHRvIFwiK1xuICAgICAgICAgICAgICAgIFwiZnJhY3Rpb25zKS5cIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBXaWR0aCBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCgge3ZhbHVlOnRoaXMucHJvcHMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe3NpemU6IGUudGFyZ2V0LnZhbHVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJub3JtYWxcIn0sIFwiTm9ybWFsICg4MHB4KVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcInNtYWxsXCJ9LCBcIlNtYWxsICg0MHB4KVwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIlVzZSBzaXplIFxcXCJOb3JtYWxcXFwiIGZvciBhbGwgdGV4dCBib3hlcywgdW5sZXNzIHRoZXJlIGFyZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJtdWx0aXBsZSB0ZXh0IGJveGVzIGluIG9uZSBsaW5lIGFuZCB0aGUgYW5zd2VyIGFyZWEgaXMgdG9vIFwiK1xuICAgICAgICAgICAgICAgICAgICBcIm5hcnJvdyB0byBmaXQgdGhlbS5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWZzLmlucHV0LmdldERPTU5vZGUoKS5mb2N1cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8ucGljayh0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIiwgXCJzaW1wbGlmeVwiLCBcInNpemVcIiwgXCJpbmV4YWN0XCIsIFwibWF4RXJyb3JcIixcbiAgICAgICAgICAgICAgICBcImFuc3dlclR5cGVcIik7XG4gICAgfVxufSk7XG5cbldpZGdldHMucmVnaXN0ZXIoXCJpbnB1dC1udW1iZXJcIiwgSW5wdXROdW1iZXIpO1xuV2lkZ2V0cy5yZWdpc3RlcihcImlucHV0LW51bWJlci1lZGl0b3JcIiwgSW5wdXROdW1iZXJFZGl0b3IpO1xuXG59KShQZXJzZXVzKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xuXG52YXIgR3JhcGggICAgICAgICA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2dyYXBoLmpzeFwiKTtcbnZhciBHcmFwaFNldHRpbmdzID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvZ3JhcGgtc2V0dGluZ3MuanN4XCIpO1xudmFyIEluZm9UaXAgICAgICAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9pbmZvLXRpcC5qc3hcIik7XG52YXIgTnVtYmVySW5wdXQgICA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL251bWJlci1pbnB1dC5qc3hcIik7XG52YXIgV2lkZ2V0cyAgICAgICA9IHJlcXVpcmUoXCIuLi93aWRnZXRzLmpzXCIpO1xudmFyIGtwb2ludCAgICAgICAgPSBLaGFuVXRpbC5rcG9pbnQ7XG5cbnZhciBEZXByZWNhdGlvbk1peGluID0gVXRpbC5EZXByZWNhdGlvbk1peGluO1xuXG52YXIga251bWJlciA9IEtoYW5VdGlsLmtudW1iZXI7XG5cbnZhciBUUkFTSF9JQ09OX1VSSSA9ICdodHRwczovL2thLXBlcnNldXMtZ3JhcGhpZS5zMy5hbWF6b25hd3MuY29tL2IxNDUyYzBkNzlmZDBmN2ZmNGMzYWY5NDg4NDc0YTBhMGRlY2IzNjEucG5nJztcblxudmFyIGRlZmF1bHRCb3hTaXplID0gNDAwO1xudmFyIGRlZmF1bHRFZGl0b3JCb3hTaXplID0gMzQwO1xudmFyIGRlZmF1bHRCYWNrZ3JvdW5kSW1hZ2UgPSB7XG4gICAgdXJsOiBudWxsLFxuICAgIHNjYWxlOiAxLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxufTtcblxudmFyIGVxID0gVXRpbC5lcTtcbnZhciBkZWVwRXEgPSBVdGlsLmRlZXBFcTtcblxudmFyIFVOTElNSVRFRCA9IFwidW5saW1pdGVkXCI7XG5cbi8vIFNhbXBsZSBiYWNrZ3JvdW5kIGltYWdlOlxuLy8gaHR0cHM6Ly9rYS1wZXJzZXVzLWdyYXBoaWUuczMuYW1hem9uYXdzLmNvbS8yOWMxYjBmY2QxN2ZlNjNkZjBmMTQ4ZmUzNTcwNDRkNWQ1YzdkMGJiLnBuZ1xuXG5mdW5jdGlvbiBjY3coYSwgYiwgYykge1xuICAgIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSAtIChjWzBdIC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pO1xufVxuXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSwgYiwgYykge1xuICAgIHJldHVybiBlcShjY3coYSwgYiwgYyksIDApO1xufVxuXG5mdW5jdGlvbiBzaWduKHZhbCkge1xuICAgIGlmIChlcSh2YWwsIDApKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWwgPiAwID8gMSA6IC0xO1xuICAgIH0gICAgXG59XG5cbi8vIGRlZmF1bHQgdG8gZGVmYXVsdFZhbHVlIGlmIGFjdHVhbCBpcyBudWxsIG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gZGVmYXVsdFZhbChhY3R1YWwsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiAoYWN0dWFsID09IG51bGwpID8gZGVmYXVsdFZhbHVlIDogYWN0dWFsO1xufVxuXG4vLyBHaXZlbiByZWN0IGJvdW5kaW5nIHBvaW50cyBBIGFuZCBCLCB3aGV0aGVyIHBvaW50IEMgaXMgaW5zaWRlIHRoZSByZWN0XG5mdW5jdGlvbiBwb2ludEluUmVjdChhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChjWzBdIDw9IE1hdGgubWF4KGFbMF0sIGJbMF0pICYmIGNbMF0gPj0gTWF0aC5taW4oYVswXSwgYlswXSkgJiZcbiAgICAgICAgICAgIGNbMV0gPD0gTWF0aC5tYXgoYVsxXSwgYlsxXSkgJiYgY1sxXSA+PSBNYXRoLm1pbihhWzFdLCBiWzFdKSk7XG59XG5cbi8vIFdoZXRoZXIgbGluZSBzZWdtZW50IEFCIGludGVyc2VjdHMgbGluZSBzZWdtZW50IENEXG4vLyBodHRwOi8vd3d3LmdlZWtzZm9yZ2Vla3Mub3JnL2NoZWNrLWlmLXR3by1naXZlbi1saW5lLXNlZ21lbnRzLWludGVyc2VjdC9cbmZ1bmN0aW9uIGludGVyc2VjdHMoYWIsIGNkKSB7XG4gICAgdmFyIHRyaXBsZXRzID0gW1xuICAgICAgICBbYWJbMF0sIGFiWzFdLCBjZFswXV0sXG4gICAgICAgIFthYlswXSwgYWJbMV0sIGNkWzFdXSxcbiAgICAgICAgW2NkWzBdLCBjZFsxXSwgYWJbMF1dLFxuICAgICAgICBbY2RbMF0sIGNkWzFdLCBhYlsxXV0sXG4gICAgXTtcblxuICAgIHZhciBvcmllbnRhdGlvbnMgPSBfLm1hcCh0cmlwbGV0cywgZnVuY3Rpb24odHJpcGxldCkge1xuICAgICAgICByZXR1cm4gc2lnbihjY3cuYXBwbHkobnVsbCwgdHJpcGxldCkpO1xuICAgIH0pO1xuXG4gICAgaWYgKG9yaWVudGF0aW9uc1swXSAhPT0gb3JpZW50YXRpb25zWzFdICYmXG4gICAgICAgIG9yaWVudGF0aW9uc1syXSAhPT0gb3JpZW50YXRpb25zWzNdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbnNbaV0gPT09IDAgJiYgcG9pbnRJblJlY3QuYXBwbHkobnVsbCwgdHJpcGxldHNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdmVjdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gXy5tYXAoXy56aXAoYSwgYiksIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJbMF0gLSBwYWlyWzFdO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWduaXR1ZGUodikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoXy5yZWR1Y2UodiwgZnVuY3Rpb24obWVtbywgZWwpIHtcbiAgICAgICAgcmV0dXJuIG1lbW8gKyBNYXRoLnBvdyhlbCwgMik7XG4gICAgfSwgMCkpO1xufVxuXG5mdW5jdGlvbiBkb3RQcm9kdWN0KGEsIGIpIHtcbiAgICByZXR1cm4gXy5yZWR1Y2UoXy56aXAoYSwgYiksIGZ1bmN0aW9uKG1lbW8sIHBhaXIpIHtcbiAgICAgICAgcmV0dXJuIG1lbW8gKyBwYWlyWzBdICogcGFpclsxXTtcbiAgICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gc2lkZUxlbmd0aHMoY29vcmRzKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gXy56aXAoY29vcmRzLCByb3RhdGUoY29vcmRzKSk7XG4gICAgcmV0dXJuIF8ubWFwKHNlZ21lbnRzLCBmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBtYWduaXR1ZGUodmVjdG9yLmFwcGx5KG51bGwsIHNlZ21lbnQpKTtcbiAgICB9KTtcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS8xNTExNDlcbmZ1bmN0aW9uIGFuZ2xlTWVhc3VyZXMoY29vcmRzKSB7XG4gICAgdmFyIHRyaXBsZXRzID0gXy56aXAocm90YXRlKGNvb3JkcywgLTEpLCBjb29yZHMsIHJvdGF0ZShjb29yZHMsIDEpKTtcblxuICAgIHZhciBvZmZzZXRzID0gXy5tYXAodHJpcGxldHMsIGZ1bmN0aW9uKHRyaXBsZXQpIHtcbiAgICAgICAgdmFyIHAgPSB2ZWN0b3IodHJpcGxldFsxXSwgdHJpcGxldFswXSk7XG4gICAgICAgIHZhciBxID0gdmVjdG9yKHRyaXBsZXRbMl0sIHRyaXBsZXRbMV0pO1xuICAgICAgICB2YXIgcmF3ID0gTWF0aC5hY29zKGRvdFByb2R1Y3QocCwgcSkgLyAobWFnbml0dWRlKHApICogbWFnbml0dWRlKHEpKSk7XG4gICAgICAgIHJldHVybiBzaWduKGNjdy5hcHBseShudWxsLCB0cmlwbGV0KSkgPiAwID8gcmF3IDogLXJhdztcbiAgICB9KTtcblxuICAgIHZhciBzdW0gPSBfLnJlZHVjZShvZmZzZXRzLCBmdW5jdGlvbihtZW1vLCBhcmcpIHsgcmV0dXJuIG1lbW8gKyBhcmc7IH0sIDApO1xuXG4gICAgcmV0dXJuIF8ubWFwKG9mZnNldHMsIGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gc3VtID4gMCA/IE1hdGguUEkgLSBvZmZzZXQgOiBNYXRoLlBJICsgb2Zmc2V0O1xuICAgIH0pO1xufVxuXG4vLyBXaGV0aGVyIHR3byBwb2x5Z29ucyBhcmUgc2ltaWxhciAob3IgaWYgc3BlY2lmaWVkLCBjb25ncnVlbnQpXG5mdW5jdGlvbiBzaW1pbGFyKGNvb3JkczEsIGNvb3JkczIsIHRvbGVyYW5jZSkge1xuICAgIGlmIChjb29yZHMxLmxlbmd0aCAhPT0gY29vcmRzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBuID0gY29vcmRzMS5sZW5ndGg7XG5cbiAgICB2YXIgYW5nbGVzMSA9IGFuZ2xlTWVhc3VyZXMoY29vcmRzMSk7XG4gICAgdmFyIGFuZ2xlczIgPSBhbmdsZU1lYXN1cmVzKGNvb3JkczIpO1xuXG4gICAgdmFyIHNpZGVzMSA9IHNpZGVMZW5ndGhzKGNvb3JkczEpO1xuICAgIHZhciBzaWRlczIgPSBzaWRlTGVuZ3Rocyhjb29yZHMyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMiAqIG47IGkrKykge1xuICAgICAgICB2YXIgYW5nbGVzID0gYW5nbGVzMi5zbGljZSgpO1xuICAgICAgICB2YXIgc2lkZXMgPSBzaWRlczIuc2xpY2UoKTtcblxuICAgICAgICAvLyBSZXZlcnNlIGFuZ2xlcyBhbmQgc2lkZXMgdG8gYWxsb3cgbWF0Y2hpbmcgcmVmbGVjdGVkIHBvbHlnb25zXG4gICAgICAgIGlmIChpID49IG4pIHtcbiAgICAgICAgICAgIGFuZ2xlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBzaWRlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAvLyBTaW5jZSBzaWRlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHR3byBjb29yZGluYXRlcyxcbiAgICAgICAgICAgIC8vIHNpbXBseSByZXZlcnNpbmcgcmVzdWx0cyBpbiBhbiBvZmYgYnkgb25lIGVycm9yXG4gICAgICAgICAgICBzaWRlcyA9IHJvdGF0ZShzaWRlcywgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbmdsZXMgPSByb3RhdGUoYW5nbGVzLCBpKTtcbiAgICAgICAgc2lkZXMgPSByb3RhdGUoc2lkZXMsIGkpO1xuXG4gICAgICAgIGlmIChkZWVwRXEoYW5nbGVzMSwgYW5nbGVzKSkge1xuICAgICAgICAgICAgdmFyIHNpZGVQYWlycyA9IF8uemlwKHNpZGVzMSwgc2lkZXMpO1xuXG4gICAgICAgICAgICB2YXIgZmFjdG9ycyA9IF8ubWFwKHNpZGVQYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWlyWzBdIC8gcGFpclsxXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2FtZSA9IF8uYWxsKGZhY3RvcnMsIGZ1bmN0aW9uKGZhY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcShmYWN0b3JzWzBdLCBmYWN0b3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjb25ncnVlbnRFbm91Z2ggPSBfLmFsbChzaWRlUGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga251bWJlci5lcXVhbChwYWlyWzBdLCBwYWlyWzFdLCB0b2xlcmFuY2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzYW1lICYmIGNvbmdydWVudEVub3VnaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBMZXNzIHRoYW4gb3IgYXBwcm94aW1hdGVseSBlcXVhbFxuZnVuY3Rpb24gbGVxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgfHwgZXEoYSwgYik7XG59XG5cbi8vIEdpdmVuIHRyaWFuZ2xlIHdpdGggc2lkZXMgQUJDIHJldHVybiBhbmdsZSBvcHBvc2l0ZSBzaWRlIEMgaW4gZGVncmVlc1xuZnVuY3Rpb24gbGF3T2ZDb3NpbmVzKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKChhICogYSArIGIgKiBiIC0gYyAqIGMpIC8gKDIgKiBhICogYikpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLy8gZS5nLiByb3RhdGUoWzEsIDIsIDNdKSAtPiBbMiwgMywgMV1cbmZ1bmN0aW9uIHJvdGF0ZShhcnJheSwgbikge1xuICAgIG4gPSAodHlwZW9mIG4gPT09IFwidW5kZWZpbmVkXCIpID8gMSA6IChuICUgYXJyYXkubGVuZ3RoKTtcbiAgICByZXR1cm4gYXJyYXkuc2xpY2UobikuY29uY2F0KGFycmF5LnNsaWNlKDAsIG4pKTtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyg/Ol58LSkoLikvZywgZnVuY3Rpb24obWF0Y2gsIGxldHRlcikge1xuICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVFcXVhdGlvbihmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKGVxKGZpcnN0WzBdLCBzZWNvbmRbMF0pKSB7XG4gICAgICAgIHJldHVybiBcInggPSBcIiArIGZpcnN0WzBdLnRvRml4ZWQoMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG0gPSAoc2Vjb25kWzFdIC0gZmlyc3RbMV0pIC9cbiAgICAgICAgICAgICAgICAoc2Vjb25kWzBdIC0gZmlyc3RbMF0pO1xuICAgICAgICB2YXIgYiA9IGZpcnN0WzFdIC0gbSAqIGZpcnN0WzBdO1xuICAgICAgICByZXR1cm4gXCJ5ID0gXCIgKyBtLnRvRml4ZWQoMykgKyBcInggKyBcIiArIGIudG9GaXhlZCgzKTtcbiAgICB9XG59XG5cbi8vIFN0b2xlbiBmcm9tIHRoZSB3aWtpcGVkaWEgYXJ0aWNsZVxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lLWxpbmVfaW50ZXJzZWN0aW9uXG5mdW5jdGlvbiBnZXRMaW5lSW50ZXJzZWN0aW9uKGZpcnN0UG9pbnRzLCBzZWNvbmRQb2ludHMpIHtcbiAgICB2YXIgeDEgPSBmaXJzdFBvaW50c1swXVswXSxcbiAgICAgICAgeTEgPSBmaXJzdFBvaW50c1swXVsxXSxcbiAgICAgICAgeDIgPSBmaXJzdFBvaW50c1sxXVswXSxcbiAgICAgICAgeTIgPSBmaXJzdFBvaW50c1sxXVsxXSxcbiAgICAgICAgeDMgPSBzZWNvbmRQb2ludHNbMF1bMF0sXG4gICAgICAgIHkzID0gc2Vjb25kUG9pbnRzWzBdWzFdLFxuICAgICAgICB4NCA9IHNlY29uZFBvaW50c1sxXVswXSxcbiAgICAgICAgeTQgPSBzZWNvbmRQb2ludHNbMV1bMV07XG5cbiAgICB2YXIgZGV0ZXJtaW5hbnQgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGV0ZXJtaW5hbnQpIDwgMWUtOSkge1xuICAgICAgICByZXR1cm4gXCJMaW5lcyBhcmUgcGFyYWxsZWxcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeCA9ICgoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC1cbiAgICAgICAgICAgICAgICAgKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSkgLyBkZXRlcm1pbmFudDtcbiAgICAgICAgdmFyIHkgPSAoKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtXG4gICAgICAgICAgICAgICAgICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCkpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICAgIHJldHVybiBcIkludGVyc2VjdGlvbjogKFwiICsgeC50b0ZpeGVkKDMpICsgXCIsIFwiICsgeS50b0ZpeGVkKDMpICsgXCIpXCI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBudW1TdGVwcyhyYW5nZSwgc3RlcCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKChyYW5nZVsxXSAtIHJhbmdlWzBdKSAvIHN0ZXApO1xufVxuXG52YXIgZGVwcmVjYXRlZFByb3BzID0ge1xuICAgIHNob3dHcmFwaDogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHttYXJraW5nczogcHJvcHMuc2hvd0dyYXBoID8gXCJncmFwaFwiIDogXCJub25lXCJ9O1xuICAgIH1cbn07XG5cblxudmFyIEludGVyYWN0aXZlR3JhcGggPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdJbnRlcmFjdGl2ZUdyYXBoJyxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnByb3BzLnJhbmdlIHx8IFtbLTEwLCAxMF0sIFstMTAsIDEwXV07XG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5wcm9wcy5zdGVwIHx8IFsxLCAxXTtcbiAgICAgICAgdmFyIGdyaWRTdGVwID0gdGhpcy5wcm9wcy5ncmlkU3RlcCB8fFxuICAgICAgICAgICAgICAgICAgIFV0aWwuZ2V0R3JpZFN0ZXAocmFuZ2UsIHN0ZXAsIGRlZmF1bHRCb3hTaXplKTtcbiAgICAgICAgdmFyIHNuYXBTdGVwID0gdGhpcy5wcm9wcy5zbmFwU3RlcCB8fFxuICAgICAgICAgICAgICAgICAgIFV0aWwuc25hcFN0ZXBGcm9tR3JpZFN0ZXAoZ3JpZFN0ZXApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWxzOiBbXCJ4XCIsIFwieVwiXSxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIGJveDogW2RlZmF1bHRCb3hTaXplLCBkZWZhdWx0Qm94U2l6ZV0sXG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgZ3JpZFN0ZXA6IGdyaWRTdGVwLFxuICAgICAgICAgICAgc25hcFN0ZXA6IHNuYXBTdGVwLFxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBkZWZhdWx0QmFja2dyb3VuZEltYWdlLFxuICAgICAgICAgICAgbWFya2luZ3M6IFwiZ3JhcGhcIixcbiAgICAgICAgICAgIHNob3dQcm90cmFjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGdyYXBoOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsaW5lYXJcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBtaXhpbnM6IFtEZXByZWNhdGlvbk1peGluXSxcbiAgICBkZXByZWNhdGVkUHJvcHM6IGRlcHJlY2F0ZWRQcm9wcyxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzLCBwcmV2U3RhdGUsIHJvb3ROb2RlKSB7XG4gICAgICAgIHZhciBvbGRUeXBlID0gcHJldlByb3BzLmdyYXBoLnR5cGU7XG4gICAgICAgIHZhciBuZXdUeXBlID0gdGhpcy5wcm9wcy5ncmFwaC50eXBlO1xuICAgICAgICBpZiAob2xkVHlwZSAhPT0gbmV3VHlwZSB8fFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcy5ncmFwaC5hbGxvd1JlZmxleEFuZ2xlcyAhPT1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5ncmFwaC5hbGxvd1JlZmxleEFuZ2xlcyB8fFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcy5ncmFwaC5hbmdsZU9mZnNldERlZyAhPT1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5ncmFwaC5hbmdsZU9mZnNldERlZyB8fFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcy5ncmFwaC5udW1Qb2ludHMgIT09IHRoaXMucHJvcHMuZ3JhcGgubnVtUG9pbnRzIHx8XG4gICAgICAgICAgICAgICAgcHJldlByb3BzLmdyYXBoLm51bVNpZGVzICE9PSB0aGlzLnByb3BzLmdyYXBoLm51bVNpZGVzIHx8XG4gICAgICAgICAgICAgICAgcHJldlByb3BzLmdyYXBoLm51bVNlZ21lbnRzICE9PSB0aGlzLnByb3BzLmdyYXBoLm51bVNlZ21lbnRzIHx8XG4gICAgICAgICAgICAgICAgcHJldlByb3BzLmdyYXBoLnNob3dBbmdsZXMgIT09IHRoaXMucHJvcHMuZ3JhcGguc2hvd0FuZ2xlcyB8fFxuICAgICAgICAgICAgICAgIHByZXZQcm9wcy5ncmFwaC5zaG93U2lkZXMgIT09IHRoaXMucHJvcHMuZ3JhcGguc2hvd1NpZGVzIHx8XG4gICAgICAgICAgICAgICAgcHJldlByb3BzLmdyYXBoLnNuYXBUbyAhPT0gdGhpcy5wcm9wcy5ncmFwaC5zbmFwVG8gfHxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHMuZ3JhcGguc25hcERlZ3JlZXMgIT09IHRoaXMucHJvcHMuZ3JhcGguc25hcERlZ3JlZXMpIHtcbiAgICAgICAgICAgIHRoaXNbXCJyZW1vdmVcIiArIGNhcGl0YWxpemUob2xkVHlwZSkgKyBcIkNvbnRyb2xzXCJdKCk7XG4gICAgICAgICAgICB0aGlzW1wiYWRkXCIgKyBjYXBpdGFsaXplKG5ld1R5cGUpICsgXCJDb250cm9sc1wiXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlc2V0R3JhcGhpZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldEdyYXBoaWUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwb2ludHNGcm9tTm9ybWFsaXplZDogZnVuY3Rpb24oY29vcmRzTGlzdCwgbm9TbmFwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF8ubWFwKGNvb3Jkc0xpc3QsIGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKGNvb3JkcywgZnVuY3Rpb24oY29vcmQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxmLnByb3BzLnJhbmdlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChub1NuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdICsgKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICogY29vcmQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBzZWxmLnByb3BzLnN0ZXBbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuU3RlcHMgPSBudW1TdGVwcyhyYW5nZSwgc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aWNrID0gTWF0aC5yb3VuZChjb29yZCAqIG5TdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVswXSArIHN0ZXAgKiB0aWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHR5cGVTZWxlY3Q7XG4gICAgICAgIHZhciBleHRyYU9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZsZXhpYmxlVHlwZSkge1xuICAgICAgICAgICAgdHlwZVNlbGVjdCA9IFJlYWN0LkRPTS5zZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgIHt2YWx1ZTp0aGlzLnByb3BzLmdyYXBoLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaDoge3R5cGU6IHR5cGV9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwibGluZWFyXCJ9LCBcIkxpbmVhciBmdW5jdGlvblwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJxdWFkcmF0aWNcIn0sIFwiUXVhZHJhdGljIGZ1bmN0aW9uXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImNpcmNsZVwifSwgXCJDaXJjbGVcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwicG9pbnRcIn0sIFwiUG9pbnQocylcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwibGluZWFyLXN5c3RlbVwifSwgXCJMaW5lYXIgU3lzdGVtXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcInBvbHlnb25cIn0sIFwiUG9seWdvblwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJzZWdtZW50XCJ9LCBcIkxpbmUgU2VnbWVudChzKVwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJyYXlcIn0sIFwiUmF5XCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImFuZ2xlXCJ9LCBcIkFuZ2xlXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5ncmFwaC50eXBlID09PSBcInBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICBleHRyYU9wdGlvbnMgPSBSZWFjdC5ET00uc2VsZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAge2tleTpcInBvaW50LXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy5ncmFwaC5udW1Qb2ludHMgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG51bWJlcnMsIGxlYXZlIFVOTElNSVRFRCBpbnRhY3Q6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9ICtlLnRhcmdldC52YWx1ZSB8fCBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVBvaW50czogbnVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKX0sIFxuICAgICAgICAgICAgICAgICAgICBfLm1hcChfLnJhbmdlKDEsIDcpLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOm59LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLCBcIiBwb2ludFwiLG4gPiAxICYmIFwic1wiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlVOTElNSVRFRH0sIFwidW5saW1pdGVkXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5ncmFwaC50eXBlID09PSBcInBvbHlnb25cIikge1xuICAgICAgICAgICAgICAgIGV4dHJhT3B0aW9ucyA9IFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrZXk6XCJwb2x5Z29uLXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMucHJvcHMuZ3JhcGgubnVtU2lkZXMgfHwgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSArZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1TaWRlczogbnVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtncmFwaDogZ3JhcGh9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyl9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLm1hcChfLnJhbmdlKDMsIDEzKSwgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOm59LCBuLCBcIiBzaWRlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsICBcIiBTbmFwIHRvIFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrZXk6XCJwb2x5Z29uLXNuYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy5ncmFwaC5zbmFwVG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKHt9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmdyYXBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcFRvOiBlLnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtncmFwaDogZ3JhcGh9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImdyaWRcIn0sIFwiZ3JpZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiYW5nbGVzXCJ9LCBcImludGVyaW9yIGFuZ2xlc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwic2lkZXNcIn0sIFwic2lkZSBtZWFzdXJlc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiVGhlc2Ugb3B0aW9ucyBhZmZlY3QgdGhlIG1vdmVtZW50IG9mIHRoZSB2ZXJ0ZXggXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwb2ludHMuIFRoZSBncmlkIG9wdGlvbiB3aWxsIGd1aWRlIHRoZSBwb2ludHMgdG8gXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGUgbmVhcmVzdCBoYWxmIHN0ZXAgYWxvbmcgdGhlIGdyaWQuXCIpLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJUaGUgaW50ZXJpb3IgYW5nbGUgYW5kIHNpZGUgbWVhc3VyZSBvcHRpb25zIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ3VpZGUgdGhlIHBvaW50cyB0byB0aGUgbmVhcmVzdCB3aG9sZSBhbmdsZSBvciBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNpZGVcIiksIFwiIG1lYXN1cmUgcmVzcGVjdGl2ZWx5LiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiU2hvdyBhbmdsZSBtZWFzdXJlczogXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6dGhpcy5wcm9wcy5ncmFwaC5zaG93QW5nbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOnRoaXMudG9nZ2xlU2hvd0FuZ2xlc30gKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJEaXNwbGF5cyB0aGUgaW50ZXJpb3IgYW5nbGUgbWVhc3VyZXMuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXCJTaG93IHNpZGUgbWVhc3VyZXM6IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOnRoaXMucHJvcHMuZ3JhcGguc2hvd1NpZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOnRoaXMudG9nZ2xlU2hvd1NpZGVzfSApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIkRpc3BsYXlzIHRoZSBzaWRlIGxlbmd0aHMuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmdyYXBoLnR5cGUgPT09IFwic2VnbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFPcHRpb25zID0gUmVhY3QuRE9NLnNlbGVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtrZXk6XCJzZWdtZW50LXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy5ncmFwaC5udW1TZWdtZW50cyB8fCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6ZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSArZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNlZ21lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVNlZ21lbnRzOiBudW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHM6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpfSwgXG4gICAgICAgICAgICAgICAgICAgIF8ubWFwKF8ucmFuZ2UoMSwgNyksIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6bn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4sIFwiIHNlZ21lbnRcIixuID4gMSAmJiBcInNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmdyYXBoLnR5cGUgPT09IFwiYW5nbGVcIikge1xuICAgICAgICAgICAgICAgIHZhciBhbGxvd1JlZmxleEFuZ2xlcyA9IGRlZmF1bHRWYWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZ3JhcGguYWxsb3dSZWZsZXhBbmdsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGV4dHJhT3B0aW9ucyA9IFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXCJTaG93IGFuZ2xlIG1lYXN1cmU6IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOnRoaXMucHJvcHMuZ3JhcGguc2hvd0FuZ2xlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazp0aGlzLnRvZ2dsZVNob3dBbmdsZXN9IClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIkFsbG93IHJlZmxleCBhbmdsZXM6IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOmFsbG93UmVmbGV4QW5nbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOmZ1bmN0aW9uKG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGg6IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93UmVmbGV4QW5nbGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFhbGxvd1JlZmxleEFuZ2xlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyl9IClcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBSZWZsZXggYW5nbGVzIGFyZSBhbmdsZXMgd2l0aCBhIG1lYXN1cmUgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ3JlYXRlciB0aGFuIDE4MCBkZWdyZWVzLiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIEJ5IGRlZmF1bHQsIHRoZXNlIHNob3VsZCByZW1haW4gZW5hYmxlZC4gXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXCJTbmFwIHRvIGluY3JlbWVudHMgb2YgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVySW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrZXk6XCJkZWdyZWUtc25hcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0VtcHR5OmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmdyYXBoLnNuYXBEZWdyZWVzIHx8IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGg6IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBEZWdyZWVzOiBNYXRoLmFicyhuZXdWYWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHM6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKX0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBkZWdyZWVzIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgV2l0aCBhbiBvZmZzZXQgb2YgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVySW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrZXk6XCJhbmdsZS1vZmZzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dFbXB0eTpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy5ncmFwaC5hbmdsZU9mZnNldERlZyB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpmdW5jdGlvbihuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoOiBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy5ncmFwaCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmdsZU9mZnNldERlZzogbmV3VmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHM6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKX0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBkZWdyZWVzIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJveCA9IHRoaXMucHJvcHMuYm94O1xuXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMucHJvcHMuYmFja2dyb3VuZEltYWdlO1xuICAgICAgICBpZiAoaW1hZ2UudXJsKSB7XG4gICAgICAgICAgICB2YXIgcHJlU2NhbGUgPSBib3hbMF0gLyBkZWZhdWx0Qm94U2l6ZTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGltYWdlLnNjYWxlICogcHJlU2NhbGU7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAocHJlU2NhbGUgKiBpbWFnZS5ib3R0b20pICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IChwcmVTY2FsZSAqIGltYWdlLmxlZnQpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAoc2NhbGUgKiBpbWFnZS53aWR0aCkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAoc2NhbGUgKiBpbWFnZS5oZWlnaHQpICsgXCJweFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1hZ2UgPSBSZWFjdC5ET00uaW1nKCB7c3R5bGU6c3R5bGUsIHNyYzppbWFnZS51cmx9ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWFnZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25DbGljayA9IHRoaXMuaXNDbGlja1RvQWRkUG9pbnRzKCkgP1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBZGRQb2ludHNDbGljayA6XG4gICAgICAgICAgICBudWxsO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwicGVyc2V1cy13aWRnZXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInBlcnNldXMtd2lkZ2V0LWludGVyYWN0aXZlLWdyYXBoXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOntcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3hbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuZmxleGlibGVUeXBlID8gXCJhdXRvXCIgOiBib3hbMV1cbiAgICAgICAgICAgICAgICAgICAgfX0sIFxuICAgICAgICAgICAgR3JhcGgoXG4gICAgICAgICAgICAgICAge3JlZjpcImdyYXBoXCIsXG4gICAgICAgICAgICAgICAgYm94OnRoaXMucHJvcHMuYm94LFxuICAgICAgICAgICAgICAgIGxhYmVsczp0aGlzLnByb3BzLmxhYmVscyxcbiAgICAgICAgICAgICAgICByYW5nZTp0aGlzLnByb3BzLnJhbmdlLFxuICAgICAgICAgICAgICAgIHN0ZXA6dGhpcy5wcm9wcy5zdGVwLFxuICAgICAgICAgICAgICAgIGdyaWRTdGVwOnRoaXMucHJvcHMuZ3JpZFN0ZXAsXG4gICAgICAgICAgICAgICAgc25hcFN0ZXA6dGhpcy5wcm9wcy5zbmFwU3RlcCxcbiAgICAgICAgICAgICAgICBtYXJraW5nczp0aGlzLnByb3BzLm1hcmtpbmdzLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTp0aGlzLnByb3BzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICAgICAgICBzaG93UHJvdHJhY3Rvcjp0aGlzLnByb3BzLnNob3dQcm90cmFjdG9yLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6b25DbGljayxcbiAgICAgICAgICAgICAgICBvbk5ld0dyYXBoaWU6dGhpcy5zZXRHcmFwaGllfSApLFxuICAgICAgICAgICAgdHlwZVNlbGVjdCxleHRyYU9wdGlvbnNcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2V0R3JhcGhpZTogZnVuY3Rpb24obmV3R3JhcGhpZSkge1xuICAgICAgICB0aGlzLmdyYXBoaWUgPSBuZXdHcmFwaGllO1xuICAgICAgICB0aGlzLnNldHVwR3JhcGhpZSgpO1xuICAgIH0sXG5cbiAgICBoYW5kbGVBZGRQb2ludHNDbGljazogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGlzLmlzQ2xpY2tUb0FkZFBvaW50cygpXG4gICAgICAgIC8vIGlzIHRydWVcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xpY2tUb0FkZFBvaW50cygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVBZGRQb2ludHNDbGljayBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWRcIiArXG4gICAgICAgICAgICAgICAgXCJ3aGVuIGlzQ2xpY2tUb0FkZFBvaW50cygpIGlzIGZhbHNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0Nvb3JkSW5UcmFzaChjb29yZCkpIHtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQb2ludEZvclBvaW50c1R5cGUoY29vcmQsIHRoaXMucG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvb3Jkc0Zyb21Qb2ludHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldEdyYXBoaWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNob3VsZFJlc2V0R3JhcGhpZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZnMuZ3JhcGgucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgc2V0dXBHcmFwaGllOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyYXBoaWUgPSB0aGlzLmdyYXBoaWU7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNDbGlja1RvQWRkUG9pbnRzKCkpIHtcbiAgICAgICAgICAgIHZhciBsb3dlckxlZnQgPSBncmFwaGllLnVuc2NhbGVQb2ludChbZ3JhcGhpZS54cGl4ZWxzIC0gNDAsXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWUueXBpeGVsc10pO1xuICAgICAgICAgICAgdmFyIHdpZHRoSGVpZ2h0ID0gZ3JhcGhpZS51bnNjYWxlVmVjdG9yKFs0MCwgNDBdKTtcbiAgICAgICAgICAgIGdyYXBoaWUucmFwaGFlbC5pbWFnZShUUkFTSF9JQ09OX1VSSSxcbiAgICAgICAgICAgICAgICBncmFwaGllLnhwaXhlbHMgLSA0MCxcbiAgICAgICAgICAgICAgICBncmFwaGllLnlwaXhlbHMgLSA0MCxcbiAgICAgICAgICAgICAgICA0MCxcbiAgICAgICAgICAgICAgICA0MFxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnByb3BzLmdyYXBoLnR5cGU7XG4gICAgICAgIHRoaXNbXCJhZGRcIiArIGNhcGl0YWxpemUodHlwZSkgKyBcIkNvbnRyb2xzXCJdKCk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5pc0NsaWNrVG9BZGRQb2ludHMoKSAhPT0gdGhpcy5pc0NsaWNrVG9BZGRQb2ludHMobmV4dFByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldEdyYXBoaWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzQ2xpY2tUb0FkZFBvaW50czogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gcHJvcHMuZ3JhcGgudHlwZSA9PT0gXCJwb2ludFwiICYmXG4gICAgICAgICAgICAgICAgcHJvcHMuZ3JhcGgubnVtUG9pbnRzID09PSBVTkxJTUlURUQ7XG4gICAgfSxcblxuICAgIGdldEVxdWF0aW9uU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnByb3BzLmdyYXBoLnR5cGU7XG4gICAgICAgIHJldHVybiB0aGlzW1wiZ2V0XCIgKyBjYXBpdGFsaXplKHR5cGUpICsgXCJFcXVhdGlvblN0cmluZ1wiXSgpO1xuICAgIH0sXG5cbiAgICBhZGRMaW5lOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdyYXBoaWUgPSBzZWxmLmdyYXBoaWU7XG4gICAgICAgIHZhciBjb29yZHMgPSBJbnRlcmFjdGl2ZUdyYXBoLmdldExpbmVDb29yZHMoc2VsZi5wcm9wcy5ncmFwaCwgc2VsZik7XG5cbiAgICAgICAgdmFyIHBvaW50QSA9IHNlbGYucG9pbnRBID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9pbnQoe1xuICAgICAgICAgICAgY29vcmQ6IGNvb3Jkc1swXSxcbiAgICAgICAgICAgIHNuYXBYOiBncmFwaGllLnNuYXBbMF0sXG4gICAgICAgICAgICBzbmFwWTogZ3JhcGhpZS5zbmFwWzFdLFxuICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkJMVUUsXG4gICAgICAgICAgICAgICAgZmlsbDogS2hhblV0aWwuQkxVRVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcG9pbnRCID0gc2VsZi5wb2ludEIgPSBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICBjb29yZDogY29vcmRzWzFdLFxuICAgICAgICAgICAgc25hcFg6IGdyYXBoaWUuc25hcFswXSxcbiAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBsaW5lQ29uZmlnID0ge1xuICAgICAgICAgICAgcG9pbnRBOiBwb2ludEEsXG4gICAgICAgICAgICBwb2ludFo6IHBvaW50QixcbiAgICAgICAgICAgIGZpeGVkOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG4gICAgICAgICAgICBsaW5lQ29uZmlnLmV4dGVuZExpbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicmF5XCIpIHtcbiAgICAgICAgICAgIGxpbmVDb25maWcuZXh0ZW5kUmF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lID0gc2VsZi5saW5lID0gZ3JhcGhpZS5hZGRNb3ZhYmxlTGluZVNlZ21lbnQobGluZUNvbmZpZyk7XG5cbiAgICAgICAgLy8gQSBhbmQgQiBjYW4ndCBiZSBpbiB0aGUgc2FtZSBwbGFjZVxuICAgICAgICBwb2ludEEub25Nb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuICFrcG9pbnQuZXF1YWwoW3gsIHldLCBwb2ludEIuY29vcmQpO1xuICAgICAgICB9O1xuICAgICAgICBwb2ludEIub25Nb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuICFrcG9pbnQuZXF1YWwoW3gsIHldLCBwb2ludEEuY29vcmQpO1xuICAgICAgICB9O1xuXG4gICAgICAgICQoW3BvaW50QSwgcG9pbnRCXSkub24oXCJtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGdyYXBoID0gXy5leHRlbmQoe30sIHNlbGYucHJvcHMuZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IFtwb2ludEEuY29vcmQsIHBvaW50Qi5jb29yZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5wcm9wcy5vbkNoYW5nZSh7Z3JhcGg6IGdyYXBofSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmVMaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wb2ludEEucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucG9pbnRCLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmxpbmUucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIGFkZExpbmVhckNvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hZGRMaW5lKFwibGluZVwiKTtcbiAgICB9LFxuXG4gICAgZ2V0TGluZWFyRXF1YXRpb25TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29vcmRzID0gSW50ZXJhY3RpdmVHcmFwaC5nZXRMaW5lQ29vcmRzKHRoaXMucHJvcHMuZ3JhcGgsIHRoaXMpO1xuICAgICAgICBpZiAoZXEoY29vcmRzWzBdWzBdLCBjb29yZHNbMV1bMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ4ID0gXCIgKyBjb29yZHNbMF1bMF0udG9GaXhlZCgzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtID0gKGNvb3Jkc1sxXVsxXSAtIGNvb3Jkc1swXVsxXSkgL1xuICAgICAgICAgICAgICAgICAgICAoY29vcmRzWzFdWzBdIC0gY29vcmRzWzBdWzBdKTtcbiAgICAgICAgICAgIHZhciBiID0gY29vcmRzWzBdWzFdIC0gbSAqIGNvb3Jkc1swXVswXTtcbiAgICAgICAgICAgIGlmIChlcShtLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInkgPSBcIiArIGIudG9GaXhlZCgzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieSA9IFwiICsgbS50b0ZpeGVkKDMpICsgXCJ4ICsgXCIgKyBiLnRvRml4ZWQoMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlTGluZWFyQ29udHJvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpbmUoKTtcbiAgICB9LFxuXG4gICAgZGVmYXVsdFF1YWRyYXRpY0Nvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBbWzAuMjUsIDAuNzVdLCBbMC41LCAwLjI1XSwgWzAuNzUsIDAuNzVdXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzRnJvbU5vcm1hbGl6ZWQoY29vcmRzKTtcbiAgICB9LFxuXG4gICAgYWRkUXVhZHJhdGljQ29udHJvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHRoaXMuZ3JhcGhpZTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMucHJvcHMuZ3JhcGguY29vcmRzO1xuICAgICAgICBpZiAoIWNvb3Jkcykge1xuICAgICAgICAgICAgY29vcmRzID0gdGhpcy5kZWZhdWx0UXVhZHJhdGljQ29vcmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnRBID0gdGhpcy5wb2ludEEgPSBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICBjb29yZDogY29vcmRzWzBdLFxuICAgICAgICAgICAgc25hcFg6IGdyYXBoaWUuc25hcFswXSxcbiAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwb2ludEIgPSB0aGlzLnBvaW50QiA9IGdyYXBoaWUuYWRkTW92YWJsZVBvaW50KHtcbiAgICAgICAgICAgIGNvb3JkOiBjb29yZHNbMV0sXG4gICAgICAgICAgICBzbmFwWDogZ3JhcGhpZS5zbmFwWzBdLFxuICAgICAgICAgICAgc25hcFk6IGdyYXBoaWUuc25hcFsxXSxcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5CTFVFLFxuICAgICAgICAgICAgICAgIGZpbGw6IEtoYW5VdGlsLkJMVUVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBvaW50QyA9IHRoaXMucG9pbnRDID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9pbnQoe1xuICAgICAgICAgICAgY29vcmQ6IGNvb3Jkc1syXSxcbiAgICAgICAgICAgIHNuYXBYOiBncmFwaGllLnNuYXBbMF0sXG4gICAgICAgICAgICBzbmFwWTogZ3JhcGhpZS5zbmFwWzFdLFxuICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkJMVUUsXG4gICAgICAgICAgICAgICAgZmlsbDogS2hhblV0aWwuQkxVRVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBLCBCLCBhbmQgQyBjYW4ndCBiZSBpbiB0aGUgc2FtZSBwbGFjZVxuICAgICAgICBwb2ludEEub25Nb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggIT09IHBvaW50Qi5jb29yZFswXSAmJiB4ICE9PSBwb2ludEMuY29vcmRbMF07XG4gICAgICAgIH07XG4gICAgICAgIHBvaW50Qi5vbk1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCAhPT0gcG9pbnRBLmNvb3JkWzBdICYmIHggIT09IHBvaW50Qy5jb29yZFswXTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9pbnRDLm9uTW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ICE9PSBwb2ludEEuY29vcmRbMF0gJiYgeCAhPT0gcG9pbnRCLmNvb3JkWzBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudXBkYXRlUXVhZHJhdGljKCk7XG5cbiAgICAgICAgJChbcG9pbnRBLCBwb2ludEIsIHBvaW50Q10pLm9uKFwibW92ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICAgICAgY29vcmRzOiBbcG9pbnRBLmNvb3JkLCBwb2ludEIuY29vcmQsIHBvaW50Qy5jb29yZF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Z3JhcGg6IGdyYXBofSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVF1YWRyYXRpYygpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBnZXRRdWFkcmF0aWNDb2VmZmljaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPKGFscGVydCk6IERvbid0IGR1cGxpY2F0ZVxuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5wcm9wcy5ncmFwaC5jb29yZHMgfHwgdGhpcy5kZWZhdWx0UXVhZHJhdGljQ29vcmRzKCk7XG4gICAgICAgIHJldHVybiBJbnRlcmFjdGl2ZUdyYXBoLmdldFF1YWRyYXRpY0NvZWZmaWNpZW50cyhjb29yZHMpO1xuICAgIH0sXG5cbiAgICBnZXRRdWFkcmF0aWNFcXVhdGlvblN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2VmZnMgPSB0aGlzLmdldFF1YWRyYXRpY0NvZWZmaWNpZW50cygpO1xuICAgICAgICByZXR1cm4gXCJ5ID0gXCIgKyBjb2VmZnNbMF0udG9GaXhlZCgzKSArIFwieF4yICsgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzWzFdLnRvRml4ZWQoMykgKyBcInggKyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZnNbMl0udG9GaXhlZCgzKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlUXVhZHJhdGljOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYWJvbGEpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYWJvbGEucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29lZmZzID0gdGhpcy5nZXRRdWFkcmF0aWNDb2VmZmljaWVudHMoKTtcbiAgICAgICAgaWYgKCFjb2VmZnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhID0gY29lZmZzWzBdLCBiID0gY29lZmZzWzFdLCBjID0gY29lZmZzWzJdO1xuICAgICAgICB0aGlzLnBhcmFib2xhID0gdGhpcy5ncmFwaGllLnBsb3QoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIChhICogeCArIGIpICogeCArIGM7XG4gICAgICAgIH0sIHRoaXMucHJvcHMucmFuZ2VbMF0pLmF0dHIoe1xuICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcmFib2xhLnRvQmFjaygpO1xuICAgIH0sXG5cbiAgICByZW1vdmVRdWFkcmF0aWNDb250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucG9pbnRBLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnBvaW50Qi5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5wb2ludEMucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcmFib2xhKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFib2xhLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZENpcmNsZUNvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyYXBoaWUgPSB0aGlzLmdyYXBoaWU7XG4gICAgICAgIHZhciBtaW5TbmFwID0gXy5taW4oZ3JhcGhpZS5zbmFwKTtcblxuICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5jaXJjbGUgPSBncmFwaGllLmFkZENpcmNsZUdyYXBoKHtcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5wcm9wcy5ncmFwaC5jZW50ZXIgfHwgWzAsIDBdLFxuICAgICAgICAgICAgcmFkaXVzOiB0aGlzLnByb3BzLmdyYXBoLnJhZGl1cyB8fCBfLm1pbih0aGlzLnByb3BzLnN0ZXApLFxuICAgICAgICAgICAgc25hcFg6IGdyYXBoaWUuc25hcFswXSxcbiAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICBtaW5SYWRpdXM6IG1pblNuYXAgKiAyLFxuICAgICAgICAgICAgc25hcFJhZGl1czogbWluU25hcFxuICAgICAgICB9KTtcblxuICAgICAgICAkKGNpcmNsZSkub24oXCJtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGdyYXBoID0gXy5leHRlbmQoe30sIHRoaXMucHJvcHMuZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IGNpcmNsZS5jZW50ZXIsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBjaXJjbGUucmFkaXVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2dyYXBoOiBncmFwaH0pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBnZXRDaXJjbGVFcXVhdGlvblN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmFwaCA9IHRoaXMucHJvcHMuZ3JhcGg7XG4gICAgICAgIC8vIFRPRE8oYWxwZXJ0KTogRG9uJ3QgZHVwbGljYXRlXG4gICAgICAgIHZhciBjZW50ZXIgPSBncmFwaC5jZW50ZXIgfHwgWzAsIDBdO1xuICAgICAgICB2YXIgcmFkaXVzID0gZ3JhcGgucmFkaXVzIHx8IDI7XG4gICAgICAgIHJldHVybiBcImNlbnRlciAoXCIgKyBjZW50ZXJbMF0gKyBcIiwgXCIgKyBjZW50ZXJbMV0gKyBcIiksIHJhZGl1cyBcIiArXG4gICAgICAgICAgICAgICAgcmFkaXVzO1xuICAgIH0sXG5cbiAgICByZW1vdmVDaXJjbGVDb250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2lyY2xlLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICBhZGRMaW5lYXJTeXN0ZW1Db250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmFwaGllID0gdGhpcy5ncmFwaGllO1xuICAgICAgICB2YXIgY29vcmRzID0gSW50ZXJhY3RpdmVHcmFwaC5nZXRMaW5lYXJTeXN0ZW1Db29yZHModGhpcy5wcm9wcy5ncmFwaCxcbiAgICAgICAgICAgIHRoaXMpO1xuXG4gICAgICAgIHZhciBmaXJzdFBvaW50cyA9IHRoaXMuZmlyc3RQb2ludHMgPSBbXG4gICAgICAgICAgICBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICAgICAgY29vcmQ6IGNvb3Jkc1swXVswXSxcbiAgICAgICAgICAgICAgICBzbmFwWDogZ3JhcGhpZS5zbmFwWzBdLFxuICAgICAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5CTFVFLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICAgICAgY29vcmQ6IGNvb3Jkc1swXVsxXSxcbiAgICAgICAgICAgICAgICBzbmFwWDogZ3JhcGhpZS5zbmFwWzBdLFxuICAgICAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5CTFVFLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgc2Vjb25kUG9pbnRzID0gdGhpcy5zZWNvbmRQb2ludHMgPSBbXG4gICAgICAgICAgICBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICAgICAgY29vcmQ6IGNvb3Jkc1sxXVswXSxcbiAgICAgICAgICAgICAgICBzbmFwWDogZ3JhcGhpZS5zbmFwWzBdLFxuICAgICAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5HUkVFTixcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogS2hhblV0aWwuR1JFRU5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyYXBoaWUuYWRkTW92YWJsZVBvaW50KHtcbiAgICAgICAgICAgICAgICBjb29yZDogY29vcmRzWzFdWzFdLFxuICAgICAgICAgICAgICAgIHNuYXBYOiBncmFwaGllLnNuYXBbMF0sXG4gICAgICAgICAgICAgICAgc25hcFk6IGdyYXBoaWUuc25hcFsxXSxcbiAgICAgICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkdSRUVOLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5HUkVFTlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IHRoaXMuZmlyc3RMaW5lID0gZ3JhcGhpZS5hZGRNb3ZhYmxlTGluZVNlZ21lbnQoe1xuICAgICAgICAgICAgcG9pbnRBOiBmaXJzdFBvaW50c1swXSxcbiAgICAgICAgICAgIHBvaW50WjogZmlyc3RQb2ludHNbMV0sXG4gICAgICAgICAgICBmaXhlZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4dGVuZExpbmU6IHRydWUsXG4gICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzZWNvbmRMaW5lID0gdGhpcy5zZWNvbmRMaW5lID0gZ3JhcGhpZS5hZGRNb3ZhYmxlTGluZVNlZ21lbnQoe1xuICAgICAgICAgICAgcG9pbnRBOiBzZWNvbmRQb2ludHNbMF0sXG4gICAgICAgICAgICBwb2ludFo6IHNlY29uZFBvaW50c1sxXSxcbiAgICAgICAgICAgIGZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgZXh0ZW5kTGluZTogdHJ1ZSxcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5HUkVFTixcbiAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uZWFjaChbZmlyc3RQb2ludHMsIHNlY29uZFBvaW50c10sIGZ1bmN0aW9uKHBvaW50cykge1xuICAgICAgICAgICAgcG9pbnRzWzBdLm9uTW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIV8uaXNFcXVhbChbeCwgeV0sIHBvaW50c1sxXS5jb29yZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwb2ludHNbMV0ub25Nb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhXy5pc0VxdWFsKFt4LCB5XSwgcG9pbnRzWzBdLmNvb3JkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZmlyc3RQb2ludHMuY29uY2F0KHNlY29uZFBvaW50cykpLm9uKFwibW92ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICAgICAgY29vcmRzOiBbXG4gICAgICAgICAgICAgICAgICAgIFtmaXJzdFBvaW50c1swXS5jb29yZCwgZmlyc3RQb2ludHNbMV0uY29vcmRdLFxuICAgICAgICAgICAgICAgICAgICBbc2Vjb25kUG9pbnRzWzBdLmNvb3JkLCBzZWNvbmRQb2ludHNbMV0uY29vcmRdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtncmFwaDogZ3JhcGh9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZ2V0TGluZWFyU3lzdGVtRXF1YXRpb25TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29vcmRzID0gSW50ZXJhY3RpdmVHcmFwaC5nZXRMaW5lYXJTeXN0ZW1Db29yZHModGhpcy5wcm9wcy5ncmFwaCxcbiAgICAgICAgICAgIHRoaXMpO1xuICAgICAgICByZXR1cm4gXCJcXG5cIiArXG4gICAgICAgICAgICBnZXRMaW5lRXF1YXRpb24oY29vcmRzWzBdWzBdLCBjb29yZHNbMF1bMV0pICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgZ2V0TGluZUVxdWF0aW9uKGNvb3Jkc1sxXVswXSwgY29vcmRzWzFdWzFdKSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIGdldExpbmVJbnRlcnNlY3Rpb24oY29vcmRzWzBdLCBjb29yZHNbMV0pO1xuICAgIH0sXG5cbiAgICByZW1vdmVMaW5lYXJTeXN0ZW1Db250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIF8uY2hhaW4odGhpcy5maXJzdFBvaW50cylcbiAgICAgICAgIC5jb25jYXQodGhpcy5zZWNvbmRQb2ludHMpXG4gICAgICAgICAuY29uY2F0KFt0aGlzLmZpcnN0TGluZSwgdGhpcy5zZWNvbmRMaW5lXSlcbiAgICAgICAgIC5pbnZva2UoXCJyZW1vdmVcIik7XG4gICAgfSxcblxuICAgIGlzQ29vcmRJblRyYXNoOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHRoaXMuZ3JhcGhpZTtcbiAgICAgICAgdmFyIHNjcmVlblBvaW50ID0gZ3JhcGhpZS5zY2FsZVBvaW50KGNvb3JkKTtcbiAgICAgICAgcmV0dXJuIHNjcmVlblBvaW50WzBdID49IGdyYXBoaWUueHBpeGVscyAtIDQwICYmXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9pbnRbMV0gPj0gZ3JhcGhpZS55cGl4ZWxzIC0gNDA7XG4gICAgfSxcblxuICAgIGNyZWF0ZVBvaW50Rm9yUG9pbnRzVHlwZTogZnVuY3Rpb24oY29vcmQsIGkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHNlbGYuZ3JhcGhpZTtcbiAgICAgICAgdmFyIHBvaW50ID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9pbnQoe1xuICAgICAgICAgICAgY29vcmQ6IGNvb3JkLFxuICAgICAgICAgICAgc25hcFg6IGdyYXBoaWUuc25hcFswXSxcbiAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBvaW50Lm9uTW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5wb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaiAmJiBrcG9pbnQuZXF1YWwoW3gsIHldLCBzZWxmLnBvaW50c1tqXS5jb29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgICQocG9pbnQpLm9uKFwibW92ZVwiLCB0aGlzLnVwZGF0ZUNvb3Jkc0Zyb21Qb2ludHMpO1xuXG4gICAgICAgIGlmIChzZWxmLmlzQ2xpY2tUb0FkZFBvaW50cygpKSB7XG4gICAgICAgICAgICBwb2ludC5vbk1vdmVFbmQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNDb29yZEluVHJhc2goW3gsIHldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBwb2ludCBmcm9tIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBvaW50cyA9IF8uZmlsdGVyKHNlbGYucG9pbnRzLCBmdW5jdGlvbihwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB0ICE9PSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY29ycmVjdCBhbnN3ZXIgYm94XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ29vcmRzRnJvbVBvaW50cygpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIG1vdmFibGVQb2ludCBmcm9tIGdyYXBoaWUuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhaXQgdG8gZG8gdGhpcyB1bnRpbCB3ZSdyZSBub3QgaW5zaWRlIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhaWQgcG9pbnQncyBvbk1vdmVFbmQgbWV0aG9kIHNvIGl0cyBzdGF0ZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zaXN0ZW50IHRocm91Z2hvdXQgdGhpcyBtZXRob2QgY2FsbFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KF8uYmluZChwb2ludC5yZW1vdmUsIHBvaW50KSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuXG4gICAgdXBkYXRlQ29vcmRzRnJvbVBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICBjb29yZHM6IF8ucGx1Y2sodGhpcy5wb2ludHMsIFwiY29vcmRcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2dyYXBoOiBncmFwaH0pO1xuICAgIH0sXG5cbiAgICBhZGRQb2ludENvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IEludGVyYWN0aXZlR3JhcGguZ2V0UG9pbnRDb29yZHModGhpcy5wcm9wcy5ncmFwaCwgdGhpcyk7XG4gICAgICAgIHRoaXMucG9pbnRzID0gXy5tYXAoY29vcmRzLCB0aGlzLmNyZWF0ZVBvaW50Rm9yUG9pbnRzVHlwZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGdldFBvaW50RXF1YXRpb25TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29vcmRzID0gSW50ZXJhY3RpdmVHcmFwaC5nZXRQb2ludENvb3Jkcyh0aGlzLnByb3BzLmdyYXBoLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNvb3Jkcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIihcIiArIGNvb3JkWzBdICsgXCIsIFwiICsgY29vcmRbMV0gKyBcIilcIjtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpO1xuICAgIH0sXG5cbiAgICByZW1vdmVQb2ludENvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXy5pbnZva2UodGhpcy5wb2ludHMsIFwicmVtb3ZlXCIpO1xuICAgIH0sXG5cbiAgICBhZGRTZWdtZW50Q29udHJvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHRoaXMuZ3JhcGhpZTtcblxuICAgICAgICB2YXIgY29vcmRzID0gSW50ZXJhY3RpdmVHcmFwaC5nZXRTZWdtZW50Q29vcmRzKHRoaXMucHJvcHMuZ3JhcGgsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgIHRoaXMubGluZXMgPSBfLm1hcChjb29yZHMsIGZ1bmN0aW9uKHNlZ21lbnQsIGkpIHtcbiAgICAgICAgICAgIHZhciBwb2ludEEgPSBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICAgICAgY29vcmQ6IHNlZ21lbnRbMF0sXG4gICAgICAgICAgICAgICAgc25hcFg6IGdyYXBoaWUuc25hcFswXSxcbiAgICAgICAgICAgICAgICBzbmFwWTogZ3JhcGhpZS5zbmFwWzFdLFxuICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogS2hhblV0aWwuQkxVRVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludEEpO1xuXG4gICAgICAgICAgICB2YXIgcG9pbnRCID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9pbnQoe1xuICAgICAgICAgICAgICAgIGNvb3JkOiBzZWdtZW50WzFdLFxuICAgICAgICAgICAgICAgIHNuYXBYOiBncmFwaGllLnNuYXBbMF0sXG4gICAgICAgICAgICAgICAgc25hcFk6IGdyYXBoaWUuc25hcFsxXSxcbiAgICAgICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkJMVUUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IEtoYW5VdGlsLkJMVUVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnRCKTtcblxuICAgICAgICAgICAgdmFyIGxpbmUgPSBncmFwaGllLmFkZE1vdmFibGVMaW5lU2VnbWVudCh7XG4gICAgICAgICAgICAgICAgcG9pbnRBOiBwb2ludEEsXG4gICAgICAgICAgICAgICAgcG9pbnRaOiBwb2ludEIsXG4gICAgICAgICAgICAgICAgZml4ZWQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBIGFuZCBCIGNhbid0IGJlIGluIHRoZSBzYW1lIHBsYWNlXG4gICAgICAgICAgICBwb2ludEEub25Nb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhXy5pc0VxdWFsKFt4LCB5XSwgcG9pbnRCLmNvb3JkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb2ludEIub25Nb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhXy5pc0VxdWFsKFt4LCB5XSwgcG9pbnRBLmNvb3JkKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQoW3BvaW50QSwgcG9pbnRCXSkub24oXCJtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IF8ubWFwKHRoaXMubGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtsaW5lLnBvaW50QS5jb29yZCwgbGluZS5wb2ludFouY29vcmRdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkczogc2VnbWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtncmFwaDogZ3JhcGh9KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlU2VnbWVudENvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXy5pbnZva2UodGhpcy5wb2ludHMsIFwicmVtb3ZlXCIpO1xuICAgICAgICBfLmludm9rZSh0aGlzLmxpbmVzLCBcInJlbW92ZVwiKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VnbWVudEVxdWF0aW9uU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gSW50ZXJhY3RpdmVHcmFwaC5nZXRTZWdtZW50Q29vcmRzKHRoaXMucHJvcHMuZ3JhcGgsXG4gICAgICAgICAgICB0aGlzKTtcbiAgICAgICAgcmV0dXJuIF8ubWFwKHNlZ21lbnRzLCBmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbXCIgK1xuICAgICAgICAgICAgICAgIF8ubWFwKHNlZ21lbnQsIGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIGNvb3JkLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIgXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiIFwiKTtcbiAgICB9LFxuXG4gICAgYWRkUmF5Q29udHJvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFkZExpbmUoXCJyYXlcIik7XG4gICAgfSxcblxuICAgIHJlbW92ZVJheUNvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaW5lKCk7XG4gICAgfSxcblxuICAgIGdldFJheUVxdWF0aW9uU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IEludGVyYWN0aXZlR3JhcGguZ2V0TGluZUNvb3Jkcyh0aGlzLnByb3BzLmdyYXBoLCB0aGlzKTtcbiAgICAgICAgdmFyIGEgPSBjb29yZHNbMF07XG4gICAgICAgIHZhciBiID0gY29vcmRzWzFdO1xuICAgICAgICB2YXIgZXEgPSB0aGlzLmdldExpbmVhckVxdWF0aW9uU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGFbMF0gPiBiWzBdKSB7XG4gICAgICAgICAgICBlcSArPSBcIiAoZm9yIHggPD0gXCIgKyBhWzBdLnRvRml4ZWQoMykgKyBcIilcIjtcbiAgICAgICAgfSBlbHNlIGlmIChhWzBdIDwgYlswXSkge1xuICAgICAgICAgICAgZXEgKz0gXCIgKGZvciB4ID49IFwiICsgYVswXS50b0ZpeGVkKDMpICsgXCIpXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYVsxXSA+IGJbMV0pIHtcbiAgICAgICAgICAgIGVxICs9IFwiIChmb3IgeSA8PSBcIiArIGFbMV0udG9GaXhlZCgzKSArIFwiKVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXEgKz0gXCIgKGZvciB5ID49IFwiICsgYVsxXS50b0ZpeGVkKDMpICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXE7XG4gICAgfSxcblxuICAgIGFkZFBvbHlnb25Db250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmFwaGllID0gdGhpcy5ncmFwaGllO1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBJbnRlcmFjdGl2ZUdyYXBoLmdldFBvbHlnb25Db29yZHModGhpcy5wcm9wcy5ncmFwaCwgdGhpcyk7XG4gICAgICAgIHZhciBuID0gY29vcmRzLmxlbmd0aDtcblxuICAgICAgICAvLyBUT0RPKGFsZXgpOiBjaGVjayBhZ2FpbnN0IFwiZ3JpZFwiIGluc3RlYWQsIHVzZSBjb25zdGFudHNcbiAgICAgICAgdmFyIHNuYXBUb0dyaWQgPSAhXy5jb250YWlucyhbXCJhbmdsZXNcIiwgXCJzaWRlc1wiXSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZ3JhcGguc25hcFRvKTtcblxuICAgICAgICB0aGlzLnBvaW50cyA9IF8ubWFwKGNvb3JkcywgZnVuY3Rpb24oY29vcmQsIGkpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGdyYXBoaWUuYWRkTW92YWJsZVBvaW50KF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBjb29yZDogY29vcmQsXG4gICAgICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5CTFVFLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc25hcFRvR3JpZCA/IHtcbiAgICAgICAgICAgICAgICBzbmFwWDogZ3JhcGhpZS5zbmFwWzBdLFxuICAgICAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV1cbiAgICAgICAgICAgIH0gOiB7fVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIC8vIEluZGV4IHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9pbnQgLT4gYWJzb2x1dGUgaW5kZXhcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbChqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpICsgaiArIG4pICUgbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9pbnQub25Nb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBfLnBsdWNrKHRoaXMucG9pbnRzLCBcImNvb3JkXCIpO1xuICAgICAgICAgICAgICAgIGNvb3Jkc1tpXSA9IFt4LCB5XTtcblxuICAgICAgICAgICAgICAgIC8vIFBvbHlnb25zIGNhbid0IGhhdmUgY29uc2VjdXRpdmUgY29sbGluZWFyIHBvaW50c1xuICAgICAgICAgICAgICAgIGlmIChjb2xsaW5lYXIoY29vcmRzW3JlbCgtMildLCBjb29yZHNbcmVsKC0xKV0sIGNvb3Jkc1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgY29sbGluZWFyKGNvb3Jkc1tyZWwoLTEpXSwgY29vcmRzW2ldLCAgY29vcmRzW3JlbCgxKV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIGNvbGxpbmVhcihjb29yZHNbaV0sICBjb29yZHNbcmVsKDEpXSwgIGNvb3Jkc1tyZWwoMildKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gXy56aXAoY29vcmRzLCByb3RhdGUoY29vcmRzKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RyYWluIHRvIHNpbXBsZSAobm9uIHNlbGYtaW50ZXJzZWN0aW5nKSBwb2x5Z29uIGJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3Rpbmcgd2hldGhlciBhZGphY2VudCBzZWdtZW50cyBpbnRlcnNlY3QgYW55IG90aGVyc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gLTE7IGogPD0gMDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW3JlbChqKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJzID0gXy53aXRob3V0KHNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsIHNlZ21lbnRzW3JlbChqLTEpXSwgc2VnbWVudHNbcmVsKGorMSldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdGhlcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBvdGhlcnNba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoc2VnbWVudCwgb3RoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5ncmFwaC5zbmFwVG8gPT09IFwiYW5nbGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcCB0byB3aG9sZSBkZWdyZWUgaW50ZXJpb3IgYW5nbGVzXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlcyA9IF8ubWFwKGFuZ2xlTWVhc3VyZXMoY29vcmRzKSwgZnVuY3Rpb24ocmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFkICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKFstMSwgMV0sIGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlc1tyZWwoaildID0gTWF0aC5yb3VuZChhbmdsZXNbcmVsKGopXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRBbmdsZSA9IGZ1bmN0aW9uKGEsIHZlcnRleCwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gS2hhblV0aWwuZmluZEFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkc1tyZWwoYSldLCBjb29yZHNbcmVsKGIpXSwgY29vcmRzW3JlbCh2ZXJ0ZXgpXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYW5nbGUgKyAzNjApICUgMzYwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckFuZ2xlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlc1tyZWwoLTEpXSAtIGdldEFuZ2xlKC0yLCAtMSwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZXNbcmVsKDEpXSAtIGdldEFuZ2xlKC0xLCAxLCAyKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpbm5lckFuZ2xlc1syXSA9IDE4MCAtIChpbm5lckFuZ2xlc1swXSArIGlubmVyQW5nbGVzWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBkZWdlbmVyYXRlIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5hbnkoaW5uZXJBbmdsZXMsIGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZXEoYW5nbGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIga25vd25TaWRlID0gbWFnbml0dWRlKHZlY3Rvcihjb29yZHNbcmVsKC0xKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZHNbcmVsKDEpXSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkxlZnQgPSBzaWduKGNjdyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkc1tyZWwoLTEpXSwgY29vcmRzW3JlbCgxKV0sIGNvb3Jkc1tpXVxuICAgICAgICAgICAgICAgICAgICApKSA9PT0gMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTb2x2ZSBmb3Igc2lkZSBieSB1c2luZyB0aGUgbGF3IG9mIHNpbmVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gTWF0aC5zaW4oaW5uZXJBbmdsZXNbMV0gKiBNYXRoLlBJIC8gMTgwKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbihpbm5lckFuZ2xlc1syXSAqIE1hdGguUEkgLyAxODApICoga25vd25TaWRlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRlckFuZ2xlID0gS2hhblV0aWwuZmluZEFuZ2xlKGNvb3Jkc1tyZWwoMSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzW3JlbCgtMSldKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ncmFwaGllLnBvbGFyKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQW5nbGUgKyAob25MZWZ0PyAxIDogLTEpICogaW5uZXJBbmdsZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaGllLmFkZFBvaW50cyhjb29yZHNbcmVsKC0xKV0sIG9mZnNldCk7XG5cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5ncmFwaC5zbmFwVG8gPT09IFwic2lkZXNcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBTbmFwIHRvIHdob2xlIHVuaXQgc2lkZSBtZWFzdXJlc1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlcyA9IF8ubWFwKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb29yZHNbcmVsKC0xKV0sIGNvb3Jkc1tpXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbY29vcmRzW2ldLCBjb29yZHNbcmVsKDEpXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbY29vcmRzW3JlbCgtMSldLCBjb29yZHNbcmVsKDEpXV1cbiAgICAgICAgICAgICAgICAgICAgXSwgZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFnbml0dWRlKHZlY3Rvci5hcHBseShudWxsLCBjb29yZHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKFswLCAxXSwgZnVuY3Rpb24oaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZXNbal0gPSBNYXRoLnJvdW5kKHNpZGVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgZGVnZW5lcmF0ZSB0cmlhbmdsZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlcShzaWRlc1sxXSArIHNpZGVzWzJdLCBzaWRlc1swXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXEoc2lkZXNbMF0gKyBzaWRlc1syXSwgc2lkZXNbMV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVxKHNpZGVzWzBdICsgc2lkZXNbMV0sIHNpZGVzWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU29sdmUgZm9yIGFuZ2xlIGJ5IHVzaW5nIHRoZSBsYXcgb2YgY29zaW5lc1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJBbmdsZSA9IGxhd09mQ29zaW5lcyhzaWRlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVzWzJdLCBzaWRlc1sxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dGVyQW5nbGUgPSBLaGFuVXRpbC5maW5kQW5nbGUoY29vcmRzW3JlbCgxKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZHNbcmVsKC0xKV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkxlZnQgPSBzaWduKGNjdyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkc1tyZWwoLTEpXSwgY29vcmRzW3JlbCgxKV0sIGNvb3Jkc1tpXVxuICAgICAgICAgICAgICAgICAgICApKSA9PT0gMTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5ncmFwaGllLnBvbGFyKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckFuZ2xlICsgKG9uTGVmdCA/IDEgOiAtMSkgKiBpbm5lckFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGhpZS5hZGRQb2ludHMoY29vcmRzW3JlbCgtMSldLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcCB0byBncmlkIChhbHJlYWR5IGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAkKHBvaW50KS5vbihcIm1vdmVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYXBoID0gXy5leHRlbmQoe30sIHRoaXMucHJvcHMuZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBfLnBsdWNrKHRoaXMucG9pbnRzLCBcImNvb3JkXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Z3JhcGg6IGdyYXBofSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHZhciBhbmdsZUxhYmVscyA9IF8udGltZXMobiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMuZ3JhcGguc2hvd0FuZ2xlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmdyYXBoLnNuYXBUbyA9PT0gXCJhbmdsZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIiRkZWcwXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIiRkZWcxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHZhciBudW1BcmNzID0gXy50aW1lcyhuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmdyYXBoLnNob3dBbmdsZXMgPyAxIDogMDtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdmFyIHNpZGVMYWJlbHMgPSBfLnRpbWVzKG4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BzLmdyYXBoLnNob3dTaWRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmdyYXBoLnNuYXBUbyA9PT0gXCJzaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJGxlbjBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJGxlbjFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5wb2x5Z29uID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9seWdvbihfLmV4dGVuZCh7XG4gICAgICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgYW5nbGVMYWJlbHM6IGFuZ2xlTGFiZWxzLFxuICAgICAgICAgICAgbnVtQXJjczogbnVtQXJjcyxcbiAgICAgICAgICAgIHNpZGVMYWJlbHM6IHNpZGVMYWJlbHNcbiAgICAgICAgfSwgc25hcFRvR3JpZCA/IHtcbiAgICAgICAgICAgIHNuYXBYOiBncmFwaGllLnNuYXBbMF0sXG4gICAgICAgICAgICBzbmFwWTogZ3JhcGhpZS5zbmFwWzFdXG4gICAgICAgIH0gOiB7fVxuICAgICAgICApKTtcblxuICAgICAgICAkKHRoaXMucG9seWdvbikub24oXCJtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGdyYXBoID0gXy5leHRlbmQoe30sIHRoaXMucHJvcHMuZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IF8ucGx1Y2sodGhpcy5wb2ludHMsIFwiY29vcmRcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Z3JhcGg6IGdyYXBofSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIHJlbW92ZVBvbHlnb25Db250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIF8uaW52b2tlKHRoaXMucG9pbnRzLCBcInJlbW92ZVwiKTtcbiAgICAgICAgdGhpcy5wb2x5Z29uLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICBnZXRQb2x5Z29uRXF1YXRpb25TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29vcmRzID0gSW50ZXJhY3RpdmVHcmFwaC5nZXRQb2x5Z29uQ29vcmRzKHRoaXMucHJvcHMuZ3JhcGgsIHRoaXMpO1xuICAgICAgICByZXR1cm4gXy5tYXAoY29vcmRzLCBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgY29vcmQuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH0pLmpvaW4oXCIgXCIpO1xuICAgIH0sXG5cbiAgICBhZGRBbmdsZUNvbnRyb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyYXBoaWUgPSB0aGlzLmdyYXBoaWU7XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IEludGVyYWN0aXZlR3JhcGguZ2V0QW5nbGVDb29yZHModGhpcy5wcm9wcy5ncmFwaCwgdGhpcyk7XG5cbiAgICAgICAgLy8gVGhlIHZlcnRleCBzbmFwcyB0byB0aGUgZ3JpZCwgYnV0IHRoZSByYXlzIGRvbid0Li4uXG4gICAgICAgIHRoaXMucG9pbnRzID0gXy5tYXAoY29vcmRzLCBmdW5jdGlvbihjb29yZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyYXBoaWUuYWRkTW92YWJsZVBvaW50KF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBjb29yZDogY29vcmQsXG4gICAgICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5CTFVFLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5CTFVFXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaSA9PT0gMSA/IHtcbiAgICAgICAgICAgICAgICBzbmFwWDogZ3JhcGhpZS5zbmFwWzBdLFxuICAgICAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV1cbiAgICAgICAgICAgIH0gOiB7fSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyAuLi50aGV5IHNuYXAgdG8gd2hvbGUtZGVncmVlIGFuZ2xlcyBmcm9tIHRoZSB2ZXJ0ZXguXG4gICAgICAgIHRoaXMuYW5nbGUgPSBncmFwaGllLmFkZE1vdmFibGVBbmdsZSh7XG4gICAgICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgc25hcERlZ3JlZXM6IHRoaXMucHJvcHMuZ3JhcGguc25hcERlZ3JlZXMgfHwgMSxcbiAgICAgICAgICAgIHNuYXBPZmZzZXREZWc6IHRoaXMucHJvcHMuZ3JhcGguYW5nbGVPZmZzZXREZWcgfHwgMCxcbiAgICAgICAgICAgIGFuZ2xlTGFiZWw6IHRoaXMucHJvcHMuZ3JhcGguc2hvd0FuZ2xlcyA/IFwiJGRlZzBcIiA6IFwiXCIsXG4gICAgICAgICAgICBwdXNoT3V0OiAyLFxuICAgICAgICAgICAgYWxsb3dSZWZsZXg6IGRlZmF1bHRWYWwodGhpcy5wcm9wcy5ncmFwaC5hbGxvd1JlZmxleEFuZ2xlcywgdHJ1ZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCh0aGlzLmFuZ2xlKS5vbihcIm1vdmVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGggPSBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy5ncmFwaCwge1xuICAgICAgICAgICAgICAgIGNvb3JkczogdGhpcy5hbmdsZS5nZXRDbG9ja3dpc2VDb29yZHMoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtncmFwaDogZ3JhcGh9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQW5nbGVDb250cm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIF8uaW52b2tlKHRoaXMucG9pbnRzLCBcInJlbW92ZVwiKTtcbiAgICAgICAgdGhpcy5hbmdsZS5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgZ2V0QW5nbGVFcXVhdGlvblN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBJbnRlcmFjdGl2ZUdyYXBoLmdldEFuZ2xlQ29vcmRzKHRoaXMucHJvcHMuZ3JhcGgsIHRoaXMpO1xuICAgICAgICB2YXIgYW5nbGUgPSBLaGFuVXRpbC5maW5kQW5nbGUoY29vcmRzWzJdLCBjb29yZHNbMF0sIGNvb3Jkc1sxXSk7XG4gICAgICAgIHJldHVybiBhbmdsZS50b0ZpeGVkKDApICsgXCJcXHUwMEIwIGFuZ2xlXCIgK1xuICAgICAgICAgICAgICAgIFwiIGF0IChcIiArIGNvb3Jkc1sxXS5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU2hvd0FuZ2xlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKHt9LCB0aGlzLnByb3BzLmdyYXBoLCB7XG4gICAgICAgICAgICBzaG93QW5nbGVzOiAhdGhpcy5wcm9wcy5ncmFwaC5zaG93QW5nbGVzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtncmFwaDogZ3JhcGh9KTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU2hvd1NpZGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gXy5leHRlbmQoe30sIHRoaXMucHJvcHMuZ3JhcGgsIHtcbiAgICAgICAgICAgIHNob3dTaWRlczogIXRoaXMucHJvcHMuZ3JhcGguc2hvd1NpZGVzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtncmFwaDogZ3JhcGh9KTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZ3JhcGg7XG4gICAgfSxcblxuICAgIHNpbXBsZVZhbGlkYXRlOiBmdW5jdGlvbihydWJyaWMpIHtcbiAgICAgICAgcmV0dXJuIEludGVyYWN0aXZlR3JhcGgudmFsaWRhdGUodGhpcy50b0pTT04oKSwgcnVicmljLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6ICQubm9vcFxufSk7XG5cblxuXy5leHRlbmQoSW50ZXJhY3RpdmVHcmFwaCwge1xuICAgIGdldFF1YWRyYXRpY0NvZWZmaWNpZW50czogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHZhciBwMSA9IGNvb3Jkc1swXTtcbiAgICAgICAgdmFyIHAyID0gY29vcmRzWzFdO1xuICAgICAgICB2YXIgcDMgPSBjb29yZHNbMl07XG5cbiAgICAgICAgdmFyIGRlbm9tID0gKHAxWzBdIC0gcDJbMF0pICogKHAxWzBdIC0gcDNbMF0pICogKHAyWzBdIC0gcDNbMF0pO1xuICAgICAgICBpZiAoZGVub20gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IChwM1swXSAqIChwMlsxXSAtIHAxWzFdKSArXG4gICAgICAgICAgICAgICAgIHAyWzBdICogKHAxWzFdIC0gcDNbMV0pICtcbiAgICAgICAgICAgICAgICAgcDFbMF0gKiAocDNbMV0gLSBwMlsxXSkpIC8gZGVub207XG4gICAgICAgIHZhciBiID0gKChwM1swXSAqIHAzWzBdKSAqIChwMVsxXSAtIHAyWzFdKSArXG4gICAgICAgICAgICAgICAgIChwMlswXSAqIHAyWzBdKSAqIChwM1sxXSAtIHAxWzFdKSArXG4gICAgICAgICAgICAgICAgIChwMVswXSAqIHAxWzBdKSAqIChwMlsxXSAtIHAzWzFdKSkgLyBkZW5vbTtcbiAgICAgICAgdmFyIGMgPSAocDJbMF0gKiBwM1swXSAqIChwMlswXSAtIHAzWzBdKSAqIHAxWzFdICtcbiAgICAgICAgICAgICAgICAgcDNbMF0gKiBwMVswXSAqIChwM1swXSAtIHAxWzBdKSAqIHAyWzFdICtcbiAgICAgICAgICAgICAgICAgcDFbMF0gKiBwMlswXSAqIChwMVswXSAtIHAyWzBdKSAqIHAzWzFdKSAvIGRlbm9tO1xuICAgICAgICByZXR1cm4gW2EsIGIsIGNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggTGlrZSBwcm9wcy5ncmFwaCBvciBwcm9wcy5jb3JyZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBJbnRlcmFjdGl2ZUdyYXBoIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0TGluZUNvb3JkczogZnVuY3Rpb24oZ3JhcGgsIGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gZ3JhcGguY29vcmRzIHx8XG4gICAgICAgICAgICBjb21wb25lbnQucG9pbnRzRnJvbU5vcm1hbGl6ZWQoW1swLjI1LCAwLjc1XSwgWzAuNzUsIDAuNzVdXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaCBMaWtlIHByb3BzLmdyYXBoIG9yIHByb3BzLmNvcnJlY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IEludGVyYWN0aXZlR3JhcGggaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRQb2ludENvb3JkczogZnVuY3Rpb24oZ3JhcGgsIGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gZ3JhcGgubnVtUG9pbnRzIHx8IDE7XG4gICAgICAgIHZhciBjb29yZHMgPSBncmFwaC5jb29yZHM7XG5cbiAgICAgICAgaWYgKGNvb3Jkcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAobnVtUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrIGluIHRoZSBkYXksIG9uZSBwb2ludCdzIGNvb3JkcyB3ZXJlIGluIGdyYXBoLmNvb3JkXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IFtncmFwaC5jb29yZCB8fCBbMCwgMF1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IFtbLTUsIDBdLCBbNSwgMF1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IFtbLTUsIDBdLCBbMCwgMF0sIFs1LCAwXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzID0gW1stNiwgMF0sIFstMiwgMF0sIFsyLCAwXSwgWzYsIDBdXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSBbWy02LCAwXSwgWy0zLCAwXSwgWzAsIDBdLCBbMywgMF0sIFs2LCAwXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzID0gW1stNSwgMF0sIFstMywgMF0sIFstMSwgMF0sIFsxLCAwXSwgWzMsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzUsIDBdXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBVTkxJTUlURUQ6XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBjb29yZHMgZnJvbSB0aGVpciAtMTAgdG8gMTAgc3BhY2UgdG8gMCB0byAxXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG9mIHRoZSBvbGQgZ3JhcGguY29vcmQsIGFuZCBhbHNvIGl0J3MgZWFzaWVyLlxuICAgICAgICAgICAgdmFyIHJhbmdlID0gW1stMTAsIDEwXSwgWy0xMCwgMTBdXTtcbiAgICAgICAgICAgIGNvb3JkcyA9IEludGVyYWN0aXZlR3JhcGgubm9ybWFsaXplQ29vcmRzKGNvb3JkcywgcmFuZ2UpO1xuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gY29tcG9uZW50LnBvaW50c0Zyb21Ob3JtYWxpemVkKGNvb3Jkcyk7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaCBMaWtlIHByb3BzLmdyYXBoIG9yIHByb3BzLmNvcnJlY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IEludGVyYWN0aXZlR3JhcGggaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRMaW5lYXJTeXN0ZW1Db29yZHM6IGZ1bmN0aW9uKGdyYXBoLCBjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGdyYXBoLmNvb3JkcyB8fFxuICAgICAgICAgICAgXy5tYXAoW1xuICAgICAgICAgICAgICAgIFtbMC4yNSwgMC43NV0sIFswLjc1LCAwLjc1XV0sXG4gICAgICAgICAgICAgICAgW1swLjI1LCAwLjI1XSwgWzAuNzUsIDAuMjVdXVxuICAgICAgICAgICAgXSwgY29tcG9uZW50LnBvaW50c0Zyb21Ob3JtYWxpemVkLCBjb21wb25lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggTGlrZSBwcm9wcy5ncmFwaCBvciBwcm9wcy5jb3JyZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBJbnRlcmFjdGl2ZUdyYXBoIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0UG9seWdvbkNvb3JkczogZnVuY3Rpb24oZ3JhcGgsIGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgY29vcmRzID0gZ3JhcGguY29vcmRzO1xuICAgICAgICBpZiAoY29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSBncmFwaC5udW1TaWRlcyB8fCAzO1xuICAgICAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5QSSAvIG47XG4gICAgICAgIHZhciBvZmZzZXQgPSAoMSAvIG4gLSAxIC8gMikgKiBNYXRoLlBJO1xuXG4gICAgICAgIC8vIFRPRE8oYWxleCk6IEdlbmVyYWxpemUgdGhpcyB0byBtb3JlIHRoYW4ganVzdCB0cmlhbmdsZXMgc28gdGhhdFxuICAgICAgICAvLyBhbGwgcG9seWdvbnMgaGF2ZSB3aG9sZSBudW1iZXIgc2lkZSBsZW5ndGhzIGlmIHNuYXBwaW5nIHRvIHNpZGVzXG4gICAgICAgIHZhciByYWRpdXMgPSBncmFwaC5zbmFwVG8gPT09IFwic2lkZXNcIiA/IE1hdGguc3FydCgzKSAvIDMgKiA3OiA0O1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGNvb3JkcyBvZiBhIHJlZ3VsYXIgcG9seWdvbiB3aXRoIG4gc2lkZXNcbiAgICAgICAgY29vcmRzID0gXy50aW1lcyhuLCBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJhZGl1cyAqIE1hdGguY29zKGkgKiBhbmdsZSArIG9mZnNldCksXG4gICAgICAgICAgICAgICAgcmFkaXVzICogTWF0aC5zaW4oaSAqIGFuZ2xlICsgb2Zmc2V0KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gW1stMTAsIDEwXSwgWy0xMCwgMTBdXTtcbiAgICAgICAgY29vcmRzID0gSW50ZXJhY3RpdmVHcmFwaC5ub3JtYWxpemVDb29yZHMoY29vcmRzLCByYW5nZSk7XG5cbiAgICAgICAgdmFyIHNuYXBUb0dyaWQgPSAhXy5jb250YWlucyhbXCJhbmdsZXNcIiwgXCJzaWRlc1wiXSwgZ3JhcGguc25hcFRvKTtcbiAgICAgICAgY29vcmRzID0gY29tcG9uZW50LnBvaW50c0Zyb21Ob3JtYWxpemVkKGNvb3JkcyxcbiAgICAgICAgICAgIC8qIG5vU25hcCAqLyAhc25hcFRvR3JpZCk7XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdyYXBoIExpa2UgcHJvcHMuZ3JhcGggb3IgcHJvcHMuY29ycmVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgSW50ZXJhY3RpdmVHcmFwaCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldFNlZ21lbnRDb29yZHM6IGZ1bmN0aW9uKGdyYXBoLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGdyYXBoLmNvb3JkcztcbiAgICAgICAgaWYgKGNvb3Jkcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gZ3JhcGgubnVtU2VnbWVudHMgfHwgMTtcbiAgICAgICAgdmFyIHlzID0ge1xuICAgICAgICAgICAgMTogWzVdLFxuICAgICAgICAgICAgMjogWzUsIC01XSxcbiAgICAgICAgICAgIDM6IFs1LCAwLCAtNV0sXG4gICAgICAgICAgICA0OiBbNiwgMiwgLTIsIC02XSxcbiAgICAgICAgICAgIDU6IFs2LCAzLCAwLCAtMywgLTZdLFxuICAgICAgICAgICAgNjogWzUsIDMsIDEsIC0xLCAtMywgLTVdLFxuICAgICAgICB9W25dO1xuICAgICAgICB2YXIgcmFuZ2UgPSBbWy0xMCwgMTBdLCBbLTEwLCAxMF1dO1xuXG4gICAgICAgIHJldHVybiBfLm1hcCh5cywgZnVuY3Rpb24oeSkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBbWy01LCB5XSwgWzUsIHldXTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBJbnRlcmFjdGl2ZUdyYXBoLm5vcm1hbGl6ZUNvb3JkcyhzZWdtZW50LCByYW5nZSk7XG4gICAgICAgICAgICBzZWdtZW50ID0gY29tcG9uZW50LnBvaW50c0Zyb21Ob3JtYWxpemVkKHNlZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggTGlrZSBwcm9wcy5ncmFwaCBvciBwcm9wcy5jb3JyZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBJbnRlcmFjdGl2ZUdyYXBoIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0QW5nbGVDb29yZHM6IGZ1bmN0aW9uKGdyYXBoLCBjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGdyYXBoLmNvb3JkcztcbiAgICAgICAgaWYgKGNvb3Jkcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzbmFwID0gZ3JhcGguc25hcERlZ3JlZXMgfHwgMTtcbiAgICAgICAgdmFyIGFuZ2xlID0gc25hcDtcbiAgICAgICAgd2hpbGUgKGFuZ2xlIDwgMjApIHtcbiAgICAgICAgICAgIGFuZ2xlICs9IHNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgYW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAoZ3JhcGguYW5nbGVPZmZzZXREZWcgfHwgMCkgKiBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAgIGNvb3JkcyA9IGNvbXBvbmVudC5wb2ludHNGcm9tTm9ybWFsaXplZChbXG4gICAgICAgICAgICBbMC44NSwgMC41MF0sXG4gICAgICAgICAgICBbMC41LCAwLjUwXVxuICAgICAgICBdKTtcblxuICAgICAgICB2YXIgcmFkaXVzID0gbWFnbml0dWRlKHZlY3Rvci5hcHBseShudWxsLCBjb29yZHMpKTtcblxuICAgICAgICAvLyBBZGp1c3QgdGhlIGxvd2VyIHBvaW50IGJ5IGFuZ2xlT2Zmc2V0RGVnIGRlZ3JlZXNcbiAgICAgICAgY29vcmRzWzBdID0gW1xuICAgICAgICAgICAgY29vcmRzWzFdWzBdICsgcmFkaXVzICogTWF0aC5jb3Mob2Zmc2V0KSxcbiAgICAgICAgICAgIGNvb3Jkc1sxXVsxXSArIHJhZGl1cyAqIE1hdGguc2luKG9mZnNldClcbiAgICAgICAgXTtcbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIHVwcGVyIHBvaW50IGFuZ2xlIHJhZGlhbnMgZnJvbSB0aGVcbiAgICAgICAgLy8gbG93ZXIgcG9pbnRcbiAgICAgICAgY29vcmRzWzJdID0gW1xuICAgICAgICAgICAgY29vcmRzWzFdWzBdICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUgKyBvZmZzZXQpLFxuICAgICAgICAgICAgY29vcmRzWzFdWzFdICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUgKyBvZmZzZXQpXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplQ29vcmRzOiBmdW5jdGlvbihjb29yZHNMaXN0LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gXy5tYXAoY29vcmRzTGlzdCwgZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAoY29vcmRzLCBmdW5jdGlvbihjb29yZCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnQgPSByYW5nZVtpXVsxXSAtIHJhbmdlW2ldWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKGNvb3JkICsgcmFuZ2VbaV1bMV0pIC8gZXh0ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHN0YXRlLCBydWJyaWMsIGNvbXBvbmVudCkge1xuICAgICAgICAvLyBUT0RPKGFscGVydCk6IEJlY2F1c2UgdGhpcy5wcm9wcy5ncmFwaCBkb2Vzbid0IGFsd2F5cyBoYXZlIGNvb3JkcyxcbiAgICAgICAgLy8gY2hlY2sgdGhhdCAuY29vcmRzIGV4aXN0cyBoZXJlLCB3aGljaCBpcyBhbHdheXMgdHJ1ZSB3aGVuIHNvbWV0aGluZ1xuICAgICAgICAvLyBoYXMgbW92ZWRcbiAgICAgICAgaWYgKHN0YXRlLnR5cGUgPT09IHJ1YnJpYy5jb3JyZWN0LnR5cGUgJiYgc3RhdGUuY29vcmRzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUudHlwZSA9PT0gXCJsaW5lYXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBndWVzcyA9IHN0YXRlLmNvb3JkcztcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdCA9IHJ1YnJpYy5jb3JyZWN0LmNvb3JkcztcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIG9mIHRoZSBndWVzcyBwb2ludHMgYXJlIG9uIHRoZSBjb3JyZWN0IGxpbmUsIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0LlxuICAgICAgICAgICAgICAgIGlmIChjb2xsaW5lYXIoY29ycmVjdFswXSwgY29ycmVjdFsxXSwgZ3Vlc3NbMF0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaW5lYXIoY29ycmVjdFswXSwgY29ycmVjdFsxXSwgZ3Vlc3NbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFybmVkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50eXBlID09PSBcImxpbmVhci1zeXN0ZW1cIikge1xuICAgICAgICAgICAgICAgIHZhciBndWVzcyA9IHN0YXRlLmNvb3JkcztcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdCA9IHJ1YnJpYy5jb3JyZWN0LmNvb3JkcztcblxuICAgICAgICAgICAgICAgIGlmICgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaW5lYXIoY29ycmVjdFswXVswXSwgY29ycmVjdFswXVsxXSwgZ3Vlc3NbMF1bMF0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaW5lYXIoY29ycmVjdFswXVswXSwgY29ycmVjdFswXVsxXSwgZ3Vlc3NbMF1bMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaW5lYXIoY29ycmVjdFsxXVswXSwgY29ycmVjdFsxXVsxXSwgZ3Vlc3NbMV1bMF0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaW5lYXIoY29ycmVjdFsxXVswXSwgY29ycmVjdFsxXVsxXSwgZ3Vlc3NbMV1bMV0pXG4gICAgICAgICAgICAgICAgICAgICkgfHwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGluZWFyKGNvcnJlY3RbMF1bMF0sIGNvcnJlY3RbMF1bMV0sIGd1ZXNzWzFdWzBdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGluZWFyKGNvcnJlY3RbMF1bMF0sIGNvcnJlY3RbMF1bMV0sIGd1ZXNzWzFdWzFdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGluZWFyKGNvcnJlY3RbMV1bMF0sIGNvcnJlY3RbMV1bMV0sIGd1ZXNzWzBdWzBdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGluZWFyKGNvcnJlY3RbMV1bMF0sIGNvcnJlY3RbMV1bMV0sIGd1ZXNzWzBdWzFdKVxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFybmVkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnR5cGUgPT09IFwicXVhZHJhdGljXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyYWJvbGEgY29lZmZpY2llbnRzIG1hdGNoLCBpdCdzIGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgdmFyIGd1ZXNzQ29lZmZzID0gdGhpcy5nZXRRdWFkcmF0aWNDb2VmZmljaWVudHMoc3RhdGUuY29vcmRzKTtcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdENvZWZmcyA9IHRoaXMuZ2V0UXVhZHJhdGljQ29lZmZpY2llbnRzKFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVicmljLmNvcnJlY3QuY29vcmRzKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcEVxKGd1ZXNzQ29lZmZzLCBjb3JyZWN0Q29lZmZzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhcm5lZDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUudHlwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgICAgICAgICAgIGlmIChkZWVwRXEoc3RhdGUuY2VudGVyLCBydWJyaWMuY29ycmVjdC5jZW50ZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlcShzdGF0ZS5yYWRpdXMsIHJ1YnJpYy5jb3JyZWN0LnJhZGl1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXJuZWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnR5cGUgPT09IFwicG9pbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBndWVzcyA9IHN0YXRlLmNvb3JkcztcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdCA9IEludGVyYWN0aXZlR3JhcGguZ2V0UG9pbnRDb29yZHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBydWJyaWMuY29ycmVjdCwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBndWVzcyA9IGd1ZXNzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29ycmVjdCA9IGNvcnJlY3Quc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nJ3MgYWxyZWFkeSByb3VuZGVkIHNvIHdlIHNob3VsZG4ndCBuZWVkIHRvIGRvIGFuXG4gICAgICAgICAgICAgICAgLy8gZXEoKSBjb21wYXJpc29uIGJ1dCBfLmlzRXF1YWwoMCwgLTApIGlzIGZhbHNlLCBzbyB3ZSdsbCB1c2VcbiAgICAgICAgICAgICAgICAvLyBlcSgpIGFueXdheS4gVGhlIHNvcnQgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSBpdCdsbCBzdHJpbmdpZnlcbiAgICAgICAgICAgICAgICAvLyBpdCBhbmQgLTAgY29udmVydGVkIHRvIGEgc3RyaW5nIGlzIFwiMFwiXG4gICAgICAgICAgICAgICAgZ3Vlc3Muc29ydCgpO1xuICAgICAgICAgICAgICAgIGNvcnJlY3Quc29ydCgpO1xuICAgICAgICAgICAgICAgIGlmIChkZWVwRXEoZ3Vlc3MsIGNvcnJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFybmVkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50eXBlID09PSBcInBvbHlnb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBndWVzcyA9IHN0YXRlLmNvb3Jkcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ID0gcnVicmljLmNvcnJlY3QuY29vcmRzLnNsaWNlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHJ1YnJpYy5jb3JyZWN0Lm1hdGNoID09PSBcInNpbWlsYXJcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHNpbWlsYXIoZ3Vlc3MsIGNvcnJlY3QsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChydWJyaWMuY29ycmVjdC5tYXRjaCA9PT0gXCJjb25ncnVlbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHNpbWlsYXIoZ3Vlc3MsIGNvcnJlY3QsIGtudW1iZXIuREVGQVVMVF9UT0xFUkFOQ0UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocnVicmljLmNvcnJlY3QubWF0Y2ggPT09IFwiYXBwcm94XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzaW1pbGFyKGd1ZXNzLCBjb3JyZWN0LCAwLjEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8qIGV4YWN0ICovXG4gICAgICAgICAgICAgICAgICAgIGd1ZXNzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdC5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZGVlcEVxKGd1ZXNzLCBjb3JyZWN0KTtcbiAgICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFybmVkOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50eXBlID09PSBcInNlZ21lbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBndWVzcyA9IHN0YXRlLmNvb3Jkcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ID0gcnVicmljLmNvcnJlY3QuY29vcmRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgZ3Vlc3MgPSBfLmludm9rZShndWVzcywgXCJzb3J0XCIpLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBjb3JyZWN0ID0gXy5pbnZva2UoY29ycmVjdCwgXCJzb3J0XCIpLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcEVxKGd1ZXNzLCBjb3JyZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhcm5lZDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUudHlwZSA9PT0gXCJyYXlcIikge1xuICAgICAgICAgICAgICAgIHZhciBndWVzcyA9IHN0YXRlLmNvb3JkcztcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdCA9IHJ1YnJpYy5jb3JyZWN0LmNvb3JkcztcbiAgICAgICAgICAgICAgICBpZiAoZGVlcEVxKGd1ZXNzWzBdLCBjb3JyZWN0WzBdKSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpbmVhcihjb3JyZWN0WzBdLCBjb3JyZWN0WzFdLCBndWVzc1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXJuZWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnR5cGUgPT09IFwiYW5nbGVcIikge1xuICAgICAgICAgICAgICAgIHZhciBndWVzcyA9IHN0YXRlLmNvb3JkcztcbiAgICAgICAgICAgICAgICB2YXIgY29ycmVjdCA9IHJ1YnJpYy5jb3JyZWN0LmNvb3JkcztcblxuICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICAgICAgICBpZiAocnVicmljLmNvcnJlY3QubWF0Y2ggPT09IFwiY29uZ3J1ZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlcyA9IF8ubWFwKFtndWVzcywgY29ycmVjdF0sIGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gS2hhblV0aWwuZmluZEFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkc1syXSwgY29vcmRzWzBdLCBjb29yZHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhbmdsZSArIDM2MCkgJSAzNjA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGVxLmFwcGx5KG51bGwsIGFuZ2xlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLyogZXhhY3QgKi9cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBkZWVwRXEoZ3Vlc3NbMV0sIGNvcnJlY3RbMV0pICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpbmVhcihjb3JyZWN0WzFdLCBjb3JyZWN0WzBdLCBndWVzc1swXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaW5lYXIoY29ycmVjdFsxXSwgY29ycmVjdFsyXSwgZ3Vlc3NbMl0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhcm5lZDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBpbnB1dCB3YXNuJ3QgY29ycmVjdCwgc28gY2hlY2sgaWYgaXQncyBhIGJsYW5rIGlucHV0IG9yIGlmIGl0J3NcbiAgICAgICAgLy8gYWN0dWFsbHkganVzdCB3cm9uZ1xuICAgICAgICBpZiAoXy5pc0VxdWFsKHN0YXRlLCBydWJyaWMuZ3JhcGgpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSB3aGVyZSB3ZSBzdGFydGVkLlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgIGVhcm5lZDogMCxcbiAgICAgICAgICAgICAgICB0b3RhbDogMSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBJbnRlcmFjdGl2ZUdyYXBoRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnSW50ZXJhY3RpdmVHcmFwaEVkaXRvcicsXG4gICAgY2xhc3NOYW1lOiBcInBlcnNldXMtd2lkZ2V0LWludGVyYWN0aXZlLWdyYXBoXCIsXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnByb3BzLnJhbmdlIHx8IFtbLTEwLCAxMF0sIFstMTAsIDEwXV07XG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5wcm9wcy5zdGVwIHx8IFsxLCAxXTtcbiAgICAgICAgdmFyIGdyaWRTdGVwID0gdGhpcy5wcm9wcy5ncmlkU3RlcCB8fFxuICAgICAgICAgICAgICAgICAgIFV0aWwuZ2V0R3JpZFN0ZXAocmFuZ2UsIHN0ZXAsIGRlZmF1bHRFZGl0b3JCb3hTaXplKTtcbiAgICAgICAgdmFyIHNuYXBTdGVwID0gdGhpcy5wcm9wcy5zbmFwU3RlcCB8fFxuICAgICAgICAgICAgICAgICAgIFV0aWwuc25hcFN0ZXBGcm9tR3JpZFN0ZXAoZ3JpZFN0ZXApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYm94OiBbZGVmYXVsdEVkaXRvckJveFNpemUsIGRlZmF1bHRFZGl0b3JCb3hTaXplXSxcbiAgICAgICAgICAgIGxhYmVsczogW1wieFwiLCBcInlcIl0sXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgZ3JpZFN0ZXA6IGdyaWRTdGVwLFxuICAgICAgICAgICAgc25hcFN0ZXA6IHNuYXBTdGVwLFxuICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGRlZmF1bHRCYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgICAgICBtYXJraW5nczogXCJncmFwaFwiLFxuICAgICAgICAgICAgc2hvd1Byb3RyYWN0b3I6IGZhbHNlLFxuICAgICAgICAgICAgY29ycmVjdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgICAgICAgICAgY29vcmRzOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG1peGluczogW0RlcHJlY2F0aW9uTWl4aW5dLFxuICAgIGRlcHJlY2F0ZWRQcm9wczogZGVwcmVjYXRlZFByb3BzLFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyYXBoO1xuICAgICAgICB2YXIgZXF1YXRpb25TdHJpbmc7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGdyYXBoID0gSW50ZXJhY3RpdmVHcmFwaChcbiAgICAgICAgICAgICAgICB7cmVmOlwiZ3JhcGhcIixcbiAgICAgICAgICAgICAgICBib3g6dGhpcy5wcm9wcy5ib3gsXG4gICAgICAgICAgICAgICAgcmFuZ2U6dGhpcy5wcm9wcy5yYW5nZSxcbiAgICAgICAgICAgICAgICBsYWJlbHM6dGhpcy5wcm9wcy5sYWJlbHMsXG4gICAgICAgICAgICAgICAgc3RlcDp0aGlzLnByb3BzLnN0ZXAsXG4gICAgICAgICAgICAgICAgZ3JpZFN0ZXA6dGhpcy5wcm9wcy5ncmlkU3RlcCxcbiAgICAgICAgICAgICAgICBzbmFwU3RlcDp0aGlzLnByb3BzLnNuYXBTdGVwLFxuICAgICAgICAgICAgICAgIGdyYXBoOnRoaXMucHJvcHMuY29ycmVjdCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6dGhpcy5wcm9wcy5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgICAgICAgICAgbWFya2luZ3M6dGhpcy5wcm9wcy5tYXJraW5ncyxcbiAgICAgICAgICAgICAgICBzaG93UHJvdHJhY3Rvcjp0aGlzLnByb3BzLnNob3dQcm90cmFjdG9yLFxuICAgICAgICAgICAgICAgIGZsZXhpYmxlVHlwZTp0cnVlLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ID0gdGhpcy5wcm9wcy5jb3JyZWN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ycmVjdC50eXBlID09PSBuZXdQcm9wcy5ncmFwaC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ID0gXy5leHRlbmQoe30sIGNvcnJlY3QsIG5ld1Byb3BzLmdyYXBoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIG9wdGlvbnMgZnJvbSBwcmV2aW91cyBncmFwaFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdCA9IG5ld1Byb3BzLmdyYXBoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2NvcnJlY3Q6IGNvcnJlY3R9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyl9ICk7XG4gICAgICAgICAgICBlcXVhdGlvblN0cmluZyA9IGdyYXBoLmdldEVxdWF0aW9uU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmFwaCA9IFJlYWN0LkRPTS5kaXYobnVsbCwgdGhpcy5wcm9wcy52YWxpZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtd2lkZ2V0LWludGVyYWN0aXZlLWdyYXBoXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXCJDb3JyZWN0IGFuc3dlciBcIixcbiAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIkdyYXBoIHRoZSBjb3JyZWN0IGFuc3dlciBpbiB0aGUgZ3JhcGggYmVsb3cgYW5kIGVuc3VyZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJ0aGUgZXF1YXRpb24gb3IgcG9pbnQgY29vcmRpbmF0ZXMgZGlzcGxheWVkIHJlcHJlc2VudCB0aGUgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwiY29ycmVjdCBhbnN3ZXIuXCIpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBcIiA6IFwiLCBlcXVhdGlvblN0cmluZyksXG5cblxuICAgICAgICAgICAgR3JhcGhTZXR0aW5ncyhcbiAgICAgICAgICAgICAgICB7Ym94OnRoaXMucHJvcHMuYm94LFxuICAgICAgICAgICAgICAgIHJhbmdlOnRoaXMucHJvcHMucmFuZ2UsXG4gICAgICAgICAgICAgICAgbGFiZWxzOnRoaXMucHJvcHMubGFiZWxzLFxuICAgICAgICAgICAgICAgIHN0ZXA6dGhpcy5wcm9wcy5zdGVwLFxuICAgICAgICAgICAgICAgIGdyaWRTdGVwOnRoaXMucHJvcHMuZ3JpZFN0ZXAsXG4gICAgICAgICAgICAgICAgc25hcFN0ZXA6dGhpcy5wcm9wcy5zbmFwU3RlcCxcbiAgICAgICAgICAgICAgICB2YWxpZDp0aGlzLnByb3BzLnZhbGlkLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTp0aGlzLnByb3BzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICAgICAgICBtYXJraW5nczp0aGlzLnByb3BzLm1hcmtpbmdzLFxuICAgICAgICAgICAgICAgIHNob3dQcm90cmFjdG9yOnRoaXMucHJvcHMuc2hvd1Byb3RyYWN0b3IsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcblxuXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNvcnJlY3QudHlwZSA9PT0gXCJwb2x5Z29uXCIgJiZcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJ0eXBlLXNldHRpbmdzXCJ9LCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIFN0dWRlbnQgYW5zd2VyIG11c3QgXCIsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhbHVlOnRoaXMucHJvcHMuY29ycmVjdC5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmNoYW5nZU1hdGNoVHlwZX0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiZXhhY3RcIn0sIFwibWF0Y2ggZXhhY3RseVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImNvbmdydWVudFwifSwgXCJiZSBjb25ncnVlbnRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJhcHByb3hcIn0sIFwiYmUgYXBwcm94aW1hdGVseSBjb25ncnVlbnRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJzaW1pbGFyXCJ9LCBcImJlIHNpbWlsYXJcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnVsKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxpKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFJlYWN0LkRPTS5iKG51bGwsIFwiTWF0Y2ggRXhhY3RseTpcIiksIFwiIE1hdGNoIGV4YWN0bHkgaW4gc2l6ZSwgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmllbnRhdGlvbiwgYW5kIGxvY2F0aW9uIG9uIHRoZSBncmlkIGV2ZW4gaWYgaXQgaXMgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJub3Qgc2hvd24gaW4gdGhlIGJhY2tncm91bmQuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxpKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFJlYWN0LkRPTS5iKG51bGwsIFwiQmUgQ29uZ3J1ZW50OlwiKSwgXCIgQmUgY29uZ3J1ZW50IGluIHNpemUgYW5kIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hhcGUsIGJ1dCBjYW4gYmUgbG9jYXRlZCBhbnl3aGVyZSBvbiB0aGUgZ3JpZC5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGkobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5iKG51bGwsIFwiQmUgQXBwcm94aW1hdGVseSBDb25ncnVlbnQ6XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBCZSBleGFjdGx5IHNpbWlsYXIsIGFuZCBjb25ncnVlbnQgaW4gc2l6ZSBhbmQgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hhcGUgdG8gd2l0aGluIDAuMSB1bml0cywgYnV0IGNhbiBiZSBsb2NhdGVkIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFueXdoZXJlIG9uIHRoZSBncmlkLiBcIiwgUmVhY3QuRE9NLmVtKG51bGwsIFwiVXNlIHRoaXMgd2l0aCBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzbmFwcGluZyB0byBhbmdsZSBtZWFzdXJlLlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGkobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgUmVhY3QuRE9NLmIobnVsbCwgXCJCZSBTaW1pbGFyOlwiKSwgXCIgQmUgc2ltaWxhciB3aXRoIG1hdGNoaW5nIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJpb3IgYW5nbGVzLCBhbmQgc2lkZSBtZWFzdXJlcyB0aGF0IGFyZSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hdGNoaW5nIG9yIGEgbXVsdGlwbGUgb2YgdGhlIGNvcnJlY3Qgc2lkZSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1lYXN1cmVzLiBUaGUgZmlndXJlIGNhbiBiZSBsb2NhdGVkIGFueXdoZXJlIG9uIHRoZSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdyaWQuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jb3JyZWN0LnR5cGUgPT09IFwiYW5nbGVcIiAmJlxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInR5cGUtc2V0dGluZ3NcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFN0dWRlbnQgYW5zd2VyIG11c3QgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWU6dGhpcy5wcm9wcy5jb3JyZWN0Lm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmNoYW5nZU1hdGNoVHlwZX0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImV4YWN0XCJ9LCBcIm1hdGNoIGV4YWN0bHlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiY29uZ3J1ZW50XCJ9LCBcImJlIGNvbmdydWVudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJDb25ncnVlbmN5IHJlcXVpcmVzIG9ubHkgdGhhdCB0aGUgYW5nbGUgbWVhc3VyZXMgYXJlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGUgc2FtZS4gQW4gZXhhY3QgbWF0Y2ggaW1wbGllcyBjb25ncnVlbmN5LCBidXQgYWxzbyBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZXMgdGhhdCB0aGUgYW5nbGVzIGhhdmUgdGhlIHNhbWUgb3JpZW50YXRpb24gYW5kIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGF0IHRoZSB2ZXJ0aWNlcyBhcmUgaW4gdGhlIHNhbWUgcG9zaXRpb24uXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZ3JhcGhcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgY2hhbmdlTWF0Y2hUeXBlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBjb3JyZWN0ID0gXy5leHRlbmQoe30sIHRoaXMucHJvcHMuY29ycmVjdCwge1xuICAgICAgICAgICAgbWF0Y2g6IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtjb3JyZWN0OiBjb3JyZWN0fSk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBqc29uID0gXy5waWNrKHRoaXMucHJvcHMsIFwic3RlcFwiLCBcImJhY2tncm91bmRJbWFnZVwiLCBcIm1hcmtpbmdzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxzXCIsIFwic2hvd1Byb3RyYWN0b3JcIiwgXCJyYW5nZVwiLCBcImdyaWRTdGVwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJzbmFwU3RlcFwiKTtcblxuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLnJlZnMuZ3JhcGg7XG4gICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgdmFyIGNvcnJlY3QgPSBncmFwaCAmJiBncmFwaC50b0pTT04oKTtcbiAgICAgICAgICAgIF8uZXh0ZW5kKGpzb24sIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFscGVydCk6IEFsbG93IHNwZWNpZnlpbmcgZmxleGlibGVUeXBlICh3aGV0aGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGdyYXBoIHR5cGUgc2hvdWxkIGJlIGEgY2hvaWNlIG9yIG5vdClcbiAgICAgICAgICAgICAgICBncmFwaDoge3R5cGU6IGNvcnJlY3QudHlwZX0sXG4gICAgICAgICAgICAgICAgY29ycmVjdDogY29ycmVjdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uZWFjaChbXCJhbGxvd1JlZmxleEFuZ2xlc1wiLCBcImFuZ2xlT2Zmc2V0RGVnXCIsIFwibnVtUG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm51bVNpZGVzXCIsIFwibnVtU2VnbWVudHNcIiwgXCJzaG93QW5nbGVzXCIsIFwic2hvd1NpZGVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNuYXBUb1wiLCBcInNuYXBEZWdyZWVzXCJdLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmhhcyhjb3JyZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5ncmFwaFtrZXldID0gY29ycmVjdFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG59KTtcblxuV2lkZ2V0cy5yZWdpc3RlcihcImludGVyYWN0aXZlLWdyYXBoXCIsIEludGVyYWN0aXZlR3JhcGgpO1xuV2lkZ2V0cy5yZWdpc3RlcihcImludGVyYWN0aXZlLWdyYXBoLWVkaXRvclwiLCBJbnRlcmFjdGl2ZUdyYXBoRWRpdG9yKTtcblxufSkoUGVyc2V1cyk7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbihmdW5jdGlvbihQZXJzZXVzKSB7XG5cbnJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xudmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcbnJlcXVpcmUoXCIuLi93aWRnZXRzLmpzXCIpO1xuXG52YXIgSW5mb1RpcCAgICAgID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvaW5mby10aXAuanN4XCIpO1xudmFyIFByb3BDaGVja0JveCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL3Byb3AtY2hlY2stYm94LmpzeFwiKTtcblxuZnVuY3Rpb24gZXEoeCwgeSkge1xuICAgIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCAxZS05O1xufVxuXG52YXIgcmV2ZXJzZVJlbCA9IHtcbiAgICBnZTogXCJsZVwiLFxuICAgIGd0OiBcImx0XCIsXG4gICAgbGU6IFwiZ2VcIixcbiAgICBsdDogXCJndFwiXG59O1xuXG52YXIgdG9nZ2xlU3RyaWN0UmVsID0ge1xuICAgIGdlOiBcImd0XCIsXG4gICAgZ3Q6IFwiZ2VcIixcbiAgICBsZTogXCJsdFwiLFxuICAgIGx0OiBcImxlXCJcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdEltcHJvcGVyKG4sIGQpIHtcbiAgICBpZiAoZCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcIiArIG47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG4gKyBcIi9cIiArIGQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRNaXhlZChuLCBkKSB7XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHJldHVybiBcIi1cIiArIGZvcm1hdE1peGVkKC1uLCBkKTtcbiAgICB9XG4gICAgdmFyIHcgPSBNYXRoLmZsb29yKG4gLyBkKTtcbiAgICBpZiAodyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0SW1wcm9wZXIobiwgZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHcgKyBcIlxcXFw6XCIgKyBmb3JtYXRJbXByb3BlcihuIC0gdyAqIGQsIGQpO1xuICAgIH1cbn1cblxudmFyIEludGVyYWN0aXZlTnVtYmVyTGluZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0ludGVyYWN0aXZlTnVtYmVyTGluZScsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsU3R5bGU6IFwiZGVjaW1hbFwiLFxuICAgICAgICAgICAgbGFiZWxUaWNrczogZmFsc2UsXG4gICAgICAgICAgICBpc0luZXF1YWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgcG9pbnRYOiAwLFxuICAgICAgICAgICAgcmVsOiBcImdlXCJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnJhbmdlWzBdIDwgdGhpcy5wcm9wcy5yYW5nZVsxXSAmJlxuICAgICAgICAgICAgICAgIDAgPCB0aGlzLnByb3BzLnRpY2tTdGVwICYmXG4gICAgICAgICAgICAgICAgMCA8IHRoaXMucHJvcHMuc25hcERpdmlzaW9ucztcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGluZXF1YWxpdHlDb250cm9scztcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNJbmVxdWFsaXR5KSB7XG4gICAgICAgICAgICBpbmVxdWFsaXR5Q29udHJvbHMgPSBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJidXR0b25cIiwgdmFsdWU6XCJTd2l0Y2ggZGlyZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy5oYW5kbGVSZXZlcnNlfSApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnJlbCA9PT0gXCJsZVwiIHx8IHRoaXMucHJvcHMucmVsID09PSBcImdlXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWFrZSBjaXJjbGUgb3BlblwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk1ha2UgY2lyY2xlIGZpbGxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy5oYW5kbGVUb2dnbGVTdHJpY3R9IClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWQgPSB0aGlzLmlzVmFsaWQoKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLXdpZGdldCBcIiArXG4gICAgICAgICAgICAgICAgXCJwZXJzZXVzLXdpZGdldC1pbnRlcmFjdGl2ZS1udW1iZXItbGluZVwifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7c3R5bGU6e2Rpc3BsYXk6IHZhbGlkID8gXCJcIiA6IFwibm9uZVwifSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOlwiZ3JhcGhpZVwiLCByZWY6XCJncmFwaGllRGl2XCJ9ICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7c3R5bGU6e2Rpc3BsYXk6IHZhbGlkID8gXCJub25lXCIgOiBcIlwifX0sIFxuICAgICAgICAgICAgICAgIFwiIGludmFsaWQgbnVtYmVyIGxpbmUgY29uZmlndXJhdGlvbiBcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGluZXF1YWxpdHlDb250cm9sc1xuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBoYW5kbGVSZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7cmVsOiByZXZlcnNlUmVsW3RoaXMucHJvcHMucmVsXX0pO1xuICAgIH0sXG5cbiAgICBoYW5kbGVUb2dnbGVTdHJpY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtyZWw6IHRvZ2dsZVN0cmljdFJlbFt0aGlzLnByb3BzLnJlbF19KTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFkZEdyYXBoaWUoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGpRdWVyeSB0byByZW1vdmUgc28gZXZlbnQgaGFuZGxlcnMgZG9uJ3QgbGVha1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucmVmcy5ncmFwaGllRGl2LmdldERPTU5vZGUoKTtcbiAgICAgICAgJChub2RlKS5jaGlsZHJlbigpLnJlbW92ZSgpO1xuXG4gICAgICAgIHRoaXMuYWRkR3JhcGhpZSgpO1xuICAgIH0sXG5cbiAgICBfbGFiZWw6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBncmFwaGllID0gdGhpcy5ncmFwaGllO1xuICAgICAgICB2YXIgbGFiZWxTdHlsZSA9IHRoaXMucHJvcHMubGFiZWxTdHlsZTtcblxuICAgICAgICAvLyBUT0RPKGphY2spOiBGaW5kIG91dCBpZiBhbnkgZXhlcmNpc2VzIGhhdmUgXCJkZWNpbWFsIHRpY2tzXCIgc2V0LFxuICAgICAgICAvLyBhbmQgaWYgc28sIHJlLXNhdmUgdGhlbSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2suXG4gICAgICAgIGlmIChsYWJlbFN0eWxlID09PSBcImRlY2ltYWxcIiB8fCBsYWJlbFN0eWxlID09PSBcImRlY2ltYWwgdGlja3NcIikge1xuICAgICAgICAgICAgZ3JhcGhpZS5sYWJlbChbdmFsdWUsIC0wLjUzXSwgdmFsdWUsIFwiY2VudGVyXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhYmVsU3R5bGUgPT09IFwiaW1wcm9wZXJcIikge1xuICAgICAgICAgICAgdmFyIGZyYWMgPSBLaGFuVXRpbC50b0ZyYWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGdyYXBoaWUubGFiZWwoW3ZhbHVlLCAtMC41M10sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdEltcHJvcGVyKGZyYWNbMF0sIGZyYWNbMV0pLCBcImNlbnRlclwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYWJlbFN0eWxlID09PSBcIm1peGVkXCIpIHtcbiAgICAgICAgICAgIHZhciBmcmFjID0gS2hhblV0aWwudG9GcmFjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBncmFwaGllLmxhYmVsKFt2YWx1ZSwgLTAuNTNdLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRNaXhlZChmcmFjWzBdLCBmcmFjWzFdKSwgXCJjZW50ZXJcIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkR3JhcGhpZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdyYXBoaWUgPSB0aGlzLmdyYXBoaWUgPSBLaGFuVXRpbC5jcmVhdGVHcmFwaGllKFxuICAgICAgICAgICAgICAgIHRoaXMucmVmcy5ncmFwaGllRGl2LmdldERPTU5vZGUoKSk7XG4gICAgICAgIC8vIEVuc3VyZSBhIHNhbmUgY29uZmlndXJhdGlvbiB0byBhdm9pZCBpbmZpbml0ZSBsb29wc1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnByb3BzLnJhbmdlO1xuICAgICAgICB2YXIgdGlja1N0ZXAgPSB0aGlzLnByb3BzLnRpY2tTdGVwO1xuICAgICAgICB2YXIgc2NhbGUgPSA0MDAgLyAocmFuZ2VbMV0gLSByYW5nZVswXSk7XG5cbiAgICAgICAgZ3JhcGhpZS5pbml0KHtcbiAgICAgICAgICAgIHJhbmdlOiBbW3JhbmdlWzBdIC0gMzAgLyBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgIHJhbmdlWzFdICsgMzAgLyBzY2FsZV0sXG4gICAgICAgICAgICAgICAgICAgIFstMSwgMV1dLFxuICAgICAgICAgICAgc2NhbGU6IFtzY2FsZSwgNDBdXG4gICAgICAgIH0pO1xuICAgICAgICBncmFwaGllLmFkZE1vdXNlTGF5ZXIoKTtcblxuICAgICAgICAvLyBMaW5lXG5cbiAgICAgICAgZ3JhcGhpZS5saW5lKFtyYW5nZVswXSAtICgyNSAvIHNjYWxlKSwgMF0sXG4gICAgICAgICAgICAgW3JhbmdlWzFdICsgKDI1IC8gc2NhbGUpLCAwXSwge1xuICAgICAgICAgICAgYXJyb3dzOiBcIi0+XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYXBoaWUubGluZShbcmFuZ2VbMV0gKyAoMjUgLyBzY2FsZSksIDBdLFxuICAgICAgICAgICAgIFtyYW5nZVswXSAtICgyNSAvIHNjYWxlKSwgMF0sIHtcbiAgICAgICAgICAgIGFycm93czogXCItPlwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRpY2tzXG4gICAgICAgIHZhciBsYWJlbFN0eWxlID0gdGhpcy5wcm9wcy5sYWJlbFN0eWxlO1xuICAgICAgICBmb3IgKHZhciB4ID0gTWF0aC5jZWlsKHJhbmdlWzBdIC8gdGlja1N0ZXApICogdGlja1N0ZXA7IHggPD0gcmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgeCArPSB0aWNrU3RlcCkge1xuICAgICAgICAgICAgZ3JhcGhpZS5saW5lKFt4LCAtMC4yXSwgW3gsIDAuMl0pO1xuXG4gICAgICAgICAgICAvLyBUT0RPKGphY2spOiBGaW5kIG91dCBpZiBhbnkgZXhlcmNpc2VzIGhhdmUgXCJkZWNpbWFsIHRpY2tzXCIgc2V0LFxuICAgICAgICAgICAgLy8gYW5kIGlmIHNvLCByZS1zYXZlIHRoZW0gYW5kIHJlbW92ZSB0aGlzIGNoZWNrLlxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMubGFiZWxUaWNrcyB8fCBsYWJlbFN0eWxlID09PSBcImRlY2ltYWwgdGlja3NcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ3JhcGhpZS5zdHlsZSh7XG4gICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkJMVUUsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMy41XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZ3JhcGhpZS5saW5lKFtyYW5nZVswXSwgLTAuMl0sIFtyYW5nZVswXSwgMC4yXSk7XG4gICAgICAgICAgICBncmFwaGllLmxpbmUoW3JhbmdlWzFdLCAtMC4yXSwgW3JhbmdlWzFdLCAwLjJdKTtcbiAgICAgICAgICAgIGlmIChyYW5nZVswXSA8IDAgJiYgMCA8IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhpZS5saW5lKFswLCAtMC4yXSwgWzAsIDAuMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBncmFwaGllLnN0eWxlKHtjb2xvcjogS2hhblV0aWwuQkxVRX0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fbGFiZWwocmFuZ2VbMF0pO1xuICAgICAgICAgICAgc2VsZi5fbGFiZWwocmFuZ2VbMV0pO1xuICAgICAgICAgICAgaWYgKHJhbmdlWzBdIDwgMCAmJiAwIDwgcmFuZ2VbMV0gJiYgIXNlbGYucHJvcHMubGFiZWxUaWNrcykge1xuICAgICAgICAgICAgICAgICAgICBncmFwaGllLmxhYmVsKFswLCAtMC41M10sIFwiMFwiLCBcImNlbnRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUG9pbnRcblxuICAgICAgICB2YXIgaXNJbmVxdWFsaXR5ID0gdGhpcy5wcm9wcy5pc0luZXF1YWxpdHk7XG4gICAgICAgIHZhciByZWwgPSB0aGlzLnByb3BzLnJlbDtcblxuICAgICAgICB2YXIgcG9pbnRTaXplO1xuICAgICAgICB2YXIgcG9pbnRTdHlsZTtcbiAgICAgICAgdmFyIGhpZ2hsaWdodFN0eWxlO1xuICAgICAgICBpZiAoaXNJbmVxdWFsaXR5ICYmIChyZWwgPT09IFwibHRcIiB8fCByZWwgPT09IFwiZ3RcIikpIHtcbiAgICAgICAgICAgIHBvaW50U2l6ZSA9IDU7XG4gICAgICAgICAgICBwb2ludFN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuT1JBTkdFLFxuICAgICAgICAgICAgICAgIGZpbGw6IEtoYW5VdGlsLkJBQ0tHUk9VTkQsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhpZ2hsaWdodFN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuT1JBTkdFLFxuICAgICAgICAgICAgICAgIGZpbGw6IEtoYW5VdGlsLkJBQ0tHUk9VTkQsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogNFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50U2l6ZSA9IDQ7XG4gICAgICAgICAgICBwb2ludFN0eWxlID0gaGlnaGxpZ2h0U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5PUkFOR0UsXG4gICAgICAgICAgICAgICAgZmlsbDogS2hhblV0aWwuT1JBTkdFXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBNYXRoLm1pbihNYXRoLm1heChyYW5nZVswXSwgdGhpcy5wcm9wcy5wb2ludFgpLCByYW5nZVsxXSk7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnQgPSBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICBwb2ludFNpemU6IHBvaW50U2l6ZSxcbiAgICAgICAgICAgIGNvb3JkOiBbeCwgMF0sXG4gICAgICAgICAgICBzbmFwWDogdGhpcy5wcm9wcy50aWNrU3RlcCAvIHRoaXMucHJvcHMuc25hcERpdmlzaW9ucyxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWluWTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgaGlnaGxpZ2h0U3R5bGU6IGhpZ2hsaWdodFN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgICBwb2ludC5vbk1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgocmFuZ2VbMF0sIHgpLCByYW5nZVsxXSk7XG4gICAgICAgICAgICB1cGRhdGVJbmVxdWFsaXR5KHgsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9pbnQub25Nb3ZlRW5kID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7cG9pbnRYOiB4fSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBJbmVxdWFsaXR5IGxpbmVcblxuICAgICAgICB2YXIgaW5lcXVhbGl0eUxpbmU7XG4gICAgICAgIHVwZGF0ZUluZXF1YWxpdHkoeCwgMCk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlSW5lcXVhbGl0eShweCwgcHkpIHtcbiAgICAgICAgICAgIGlmIChpbmVxdWFsaXR5TGluZSkge1xuICAgICAgICAgICAgICAgIGluZXF1YWxpdHlMaW5lLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGluZXF1YWxpdHlMaW5lID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0luZXF1YWxpdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kO1xuICAgICAgICAgICAgICAgIGlmIChyZWwgPT09IFwiZ2VcIiB8fCByZWwgPT09IFwiZ3RcIikge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBbcmFuZ2VbMV0gKyAoMjYgLyBzY2FsZSksIDBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IFtyYW5nZVswXSAtICgyNiAvIHNjYWxlKSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZXF1YWxpdHlMaW5lID0gZ3JhcGhpZS5saW5lKFxuICAgICAgICAgICAgICAgICAgICBbcHgsIHB5XSxcbiAgICAgICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJvd3M6IFwiLT5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAzLjVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcG9pbnQudG9Gcm9udCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludFg6IHRoaXMucHJvcHMucG9pbnRYLFxuICAgICAgICAgICAgcmVsOiB0aGlzLnByb3BzLmlzSW5lcXVhbGl0eSA/IHRoaXMucHJvcHMucmVsIDogXCJlcVwiXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNpbXBsZVZhbGlkYXRlOiBmdW5jdGlvbihydWJyaWMpIHtcbiAgICAgICAgcmV0dXJuIEludGVyYWN0aXZlTnVtYmVyTGluZS52YWxpZGF0ZSh0aGlzLnRvSlNPTigpLCBydWJyaWMpO1xuICAgIH0sXG5cbiAgICBmb2N1czogJC5ub29wXG59KTtcblxuXG5fLmV4dGVuZChJbnRlcmFjdGl2ZU51bWJlckxpbmUsIHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24oc3RhdGUsIHJ1YnJpYykge1xuICAgICAgICB2YXIgcmFuZ2UgPSBydWJyaWMucmFuZ2U7XG4gICAgICAgIHZhciBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KHJhbmdlWzBdLCAwKSwgcmFuZ2VbMV0pO1xuICAgICAgICB2YXIgc3RhcnRSZWwgPSBydWJyaWMuaXNJbmVxdWFsaXR5ID8gXCJnZVwiIDogXCJlcVwiO1xuICAgICAgICB2YXIgY29ycmVjdFJlbCA9IHJ1YnJpYy5jb3JyZWN0UmVsIHx8IFwiZXFcIjtcblxuICAgICAgICBpZiAoZXEoc3RhdGUucG9pbnRYLCBydWJyaWMuY29ycmVjdFggfHwgMCkgJiZcbiAgICAgICAgICAgICAgICBjb3JyZWN0UmVsID09PSBzdGF0ZS5yZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgICAgICBlYXJuZWQ6IDEsXG4gICAgICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5wb2ludFggPT09IHN0YXJ0ICYmIHN0YXRlLnJlbCA9PT0gc3RhcnRSZWwpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIHdoZXJlIHdlIHN0YXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgZWFybmVkOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG52YXIgSW50ZXJhY3RpdmVOdW1iZXJMaW5lRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnSW50ZXJhY3RpdmVOdW1iZXJMaW5lRWRpdG9yJyxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IFswLCAxMF0sXG4gICAgICAgICAgICBsYWJlbFN0eWxlOiBcImRlY2ltYWxcIixcbiAgICAgICAgICAgIGxhYmVsVGlja3M6IGZhbHNlLFxuICAgICAgICAgICAgdGlja1N0ZXA6IDEsXG4gICAgICAgICAgICBzbmFwRGl2aXNpb25zOiA0LFxuICAgICAgICAgICAgY29ycmVjdFJlbDogXCJlcVwiLFxuICAgICAgICAgICAgY29ycmVjdFg6IDBcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgbWluIHg6IFwiLCBSZWFjdC5ET00uaW5wdXQoIHtkZWZhdWx0VmFsdWU6JycgKyB0aGlzLnByb3BzLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI6dGhpcy5vblJhbmdlQmx1ci5iaW5kKHRoaXMsIDApfSApXG4gICAgICAgICAgICApLFJlYWN0LkRPTS5icihudWxsICksXG4gICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgbWF4IHg6IFwiLCBSZWFjdC5ET00uaW5wdXQoIHtkZWZhdWx0VmFsdWU6JycgKyB0aGlzLnByb3BzLnJhbmdlWzFdLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXI6dGhpcy5vblJhbmdlQmx1ci5iaW5kKHRoaXMsIDEpfSApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIkNoYW5nZSBcXFwibGFiZWwgc3R5bGVzXFxcIiBiZWxvdyB0byBkaXNwbGF5IHRoZSBtYXggYW5kIG1pbiB4IGluIFwiK1xuICAgICAgICAgICAgICAgIFwiZGlmZmVyZW50IG51bWJlciBmb3JtYXRzLlwiKVxuICAgICAgICAgICAgKSxSZWFjdC5ET00uYnIobnVsbCApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4obnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgY29ycmVjdDogXCIsXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCgge3ZhbHVlOnRoaXMucHJvcHMuY29ycmVjdFJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMub25DaGFuZ2UuYmluZCh0aGlzLCBcImNvcnJlY3RSZWxcIil9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGdyb3VwKCB7bGFiZWw6XCJFcXVhbGl0eVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJlcVwifSwgXCJ4ID1cIilcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGdyb3VwKCB7bGFiZWw6XCJJbmVxdWFsaXR5XCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImx0XCJ9LCBcInggPFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImd0XCJ9LCBcInggPlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImxlXCJ9LCBcIngg4omkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiZ2VcIn0sIFwieCDiiaVcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7ZGVmYXVsdFZhbHVlOicnICsgdGhpcy5wcm9wcy5jb3JyZWN0WCxcbiAgICAgICAgICAgICAgICAgICAgb25CbHVyOnRoaXMub25OdW1CbHVyLmJpbmQodGhpcywgXCJjb3JyZWN0WFwiKX0gKVxuICAgICAgICAgICAgKSxSZWFjdC5ET00uYnIobnVsbCApLFJlYWN0LkRPTS5icihudWxsICksXG4gICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgbGFiZWwgc3R5bGU6IFwiLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoIHt2YWx1ZTp0aGlzLnByb3BzLmxhYmVsU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcywgXCJsYWJlbFN0eWxlXCIpfSwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImRlY2ltYWxcIn0sIFwiRGVjaW1hbHNcIiksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImltcHJvcGVyXCJ9LCBcIkltcHJvcGVyIGZyYWN0aW9uc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwibWl4ZWRcIn0sIFwiTWl4ZWQgbnVtYmVyc1wiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUHJvcENoZWNrQm94KFxuICAgICAgICAgICAgICAgICAgICB7bGFiZWw6XCJsYWJlbCB0aWNrc1wiLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbFRpY2tzOnRoaXMucHJvcHMubGFiZWxUaWNrcyxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKVxuICAgICAgICAgICAgKSxSZWFjdC5ET00uYnIobnVsbCApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFxuICAgICAgICAgICAgICAgIFwiIHRpY2sgc3RlcDogXCIsIFJlYWN0LkRPTS5pbnB1dCgge2RlZmF1bHRWYWx1ZTonJyArIHRoaXMucHJvcHMudGlja1N0ZXAsXG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cjp0aGlzLm9uTnVtQmx1ci5iaW5kKHRoaXMsIFwidGlja1N0ZXBcIil9IClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiQSB0aWNrIG1hcmsgaXMgcGxhY2VkIGF0IGV2ZXJ5IG51bWJlciBvZiBzdGVwcyBcIitcbiAgICAgICAgICAgICAgICBcImluZGljYXRlZC5cIilcbiAgICAgICAgICAgICksUmVhY3QuRE9NLmJyKG51bGwgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICBcIiBzbmFwIGluY3JlbWVudHMgcGVyIHRpY2s6IFwiLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge2RlZmF1bHRWYWx1ZTonJyArIHRoaXMucHJvcHMuc25hcERpdmlzaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgb25CbHVyOnRoaXMub25OdW1CbHVyLmJpbmQodGhpcywgXCJzbmFwRGl2aXNpb25zXCIpfSApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIkVuc3VyZSB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIHNuYXAgaW5jcmVtZW50cyBpcyBwcm92aWRlZCB0byBcIitcbiAgICAgICAgICAgICAgICBcImFuc3dlciB0aGUgcXVlc3Rpb24uXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uUmFuZ2VCbHVyOiBmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgIHZhciB4ID0gVXRpbC5maXJzdE51bWVyaWNhbFBhcnNlKGUudGFyZ2V0LnZhbHVlKSB8fCAwO1xuICAgICAgICBlLnRhcmdldC52YWx1ZSA9IHg7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5wcm9wcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByYW5nZVtpXSA9IHg7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe3JhbmdlOiByYW5nZX0pO1xuICAgIH0sXG5cbiAgICBvbkNoYW5nZTogZnVuY3Rpb24oa2V5LCBlKSB7XG4gICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgIG9wdHNba2V5XSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG9wdHMpO1xuICAgIH0sXG5cbiAgICBvbk51bUJsdXI6IGZ1bmN0aW9uKGtleSwgZSkge1xuICAgICAgICB2YXIgeCA9IFV0aWwuZmlyc3ROdW1lcmljYWxQYXJzZShlLnRhcmdldC52YWx1ZSkgfHwgMDtcbiAgICAgICAgZS50YXJnZXQudmFsdWUgPSB4O1xuXG4gICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgIG9wdHNba2V5XSA9IHg7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uob3B0cyk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogdGhpcy5wcm9wcy5yYW5nZSxcbiAgICAgICAgICAgIGxhYmVsU3R5bGU6IHRoaXMucHJvcHMubGFiZWxTdHlsZSxcbiAgICAgICAgICAgIGxhYmVsVGlja3M6IHRoaXMucHJvcHMubGFiZWxUaWNrcyxcbiAgICAgICAgICAgIHRpY2tTdGVwOiB0aGlzLnByb3BzLnRpY2tTdGVwLFxuICAgICAgICAgICAgc25hcERpdmlzaW9uczogdGhpcy5wcm9wcy5zbmFwRGl2aXNpb25zLFxuICAgICAgICAgICAgY29ycmVjdFJlbDogdGhpcy5wcm9wcy5jb3JyZWN0UmVsLFxuICAgICAgICAgICAgaXNJbmVxdWFsaXR5OiB0aGlzLnByb3BzLmNvcnJlY3RSZWwgIT09IFwiZXFcIixcbiAgICAgICAgICAgIGNvcnJlY3RYOiB0aGlzLnByb3BzLmNvcnJlY3RYXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cblBlcnNldXMuV2lkZ2V0cy5yZWdpc3RlcihcImludGVyYWN0aXZlLW51bWJlci1saW5lXCIsIEludGVyYWN0aXZlTnVtYmVyTGluZSk7XG5QZXJzZXVzLldpZGdldHNcbiAgICAucmVnaXN0ZXIoXCJpbnRlcmFjdGl2ZS1udW1iZXItbGluZS1lZGl0b3JcIiwgSW50ZXJhY3RpdmVOdW1iZXJMaW5lRWRpdG9yKTtcblxufSkoUGVyc2V1cyk7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbihmdW5jdGlvbihQZXJzZXVzKSB7XG5cbnJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xucmVxdWlyZShcIi4uL3JlbmRlcmVyLmpzeFwiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG5cbnZhciBzaHVmZmxlID0gVXRpbC5zaHVmZmxlO1xudmFyIHNlZWRlZFJORyA9IFV0aWwuc2VlZGVkUk5HO1xuXG52YXIgSW5mb1RpcCAgICAgICAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9pbmZvLXRpcC5qc3hcIik7XG52YXIgUHJvcENoZWNrQm94ICAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9wcm9wLWNoZWNrLWJveC5qc3hcIik7XG52YXIgUmVuZGVyZXIgICAgICAgPSBQZXJzZXVzLlJlbmRlcmVyO1xudmFyIFNvcnRhYmxlICAgICAgID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvc29ydGFibGUuanN4XCIpO1xudmFyIFRleHRMaXN0RWRpdG9yID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvdGV4dC1saXN0LWVkaXRvci5qc3hcIik7XG52YXIgV2lkZ2V0cyAgICAgICAgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy5qc1wiKTtcblxuXG52YXIgTWF0Y2hlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ01hdGNoZXInLFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBsZWZ0OiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIHJpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGxhYmVsczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBvcmRlck1hdHRlcnM6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgICAgICBwYWRkaW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgcHJvYmxlbU51bTogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogW10sXG4gICAgICAgICAgICByaWdodDogW10sXG4gICAgICAgICAgICBsYWJlbHM6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIG9yZGVyTWF0dGVyczogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICBwcm9ibGVtTnVtOiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHRzOiB7bGVmdDogMCwgcmlnaHQ6IDB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2FtZSByYW5kb20oKSBmdW5jdGlvbiB0byBzaHVmZmxlIGJvdGggY29sdW1ucyBzZXF1ZW50aWFsbHlcbiAgICAgICAgdmFyIHJuZyA9IHNlZWRlZFJORyh0aGlzLnByb3BzLnByb2JsZW1OdW0pO1xuXG4gICAgICAgIHZhciBsZWZ0O1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMub3JkZXJNYXR0ZXJzKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3JkZXIgZG9lc24ndCBtYXR0ZXIsIGRvbid0IHNodWZmbGUgdGhlIGxlZnQgY29sdW1uXG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy5wcm9wcy5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IHNodWZmbGUodGhpcy5wcm9wcy5sZWZ0LCBybmcsIC8qIGVuc3VyZVBlcm11dGVkICovIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJpZ2h0ID0gc2h1ZmZsZSh0aGlzLnByb3BzLnJpZ2h0LCBybmcsIC8qIGVuc3VyZVBlcm11dGVkICovIHRydWUpO1xuXG4gICAgICAgIHZhciBzaG93TGFiZWxzID0gXy5hbnkodGhpcy5wcm9wcy5sYWJlbHMpO1xuICAgICAgICB2YXIgY29uc3RyYWludHMgPSB7aGVpZ2h0OiBfLm1heCh0aGlzLnN0YXRlLmhlaWdodHMpfTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtd2lkZ2V0LW1hdGNoZXIgdWktaGVscGVyLWNsZWFyZml4XCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJjb2x1bW5cIn0sIFxuICAgICAgICAgICAgICAgIHNob3dMYWJlbHMgJiYgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImNvbHVtbi1sYWJlbFwifSwgXG4gICAgICAgICAgICAgICAgICAgIFJlbmRlcmVyKCB7Y29udGVudDp0aGlzLnByb3BzLmxhYmVsc1swXSB8fCBcIi4uLlwifSApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBTb3J0YWJsZShcbiAgICAgICAgICAgICAgICAgICAge29wdGlvbnM6bGVmdCxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OlwidmVydGljYWxcIixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzp0aGlzLnByb3BzLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiF0aGlzLnByb3BzLm9yZGVyTWF0dGVycyxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6Y29uc3RyYWludHMsXG4gICAgICAgICAgICAgICAgICAgIG9uTWVhc3VyZTpfLnBhcnRpYWwodGhpcy5vbk1lYXN1cmUsIFwibGVmdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgcmVmOlwibGVmdFwifSApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImNvbHVtblwifSwgXG4gICAgICAgICAgICAgICAgc2hvd0xhYmVscyAmJiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiY29sdW1uLWxhYmVsXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVuZGVyZXIoIHtjb250ZW50OnRoaXMucHJvcHMubGFiZWxzWzFdIHx8IFwiLi4uXCJ9IClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFNvcnRhYmxlKFxuICAgICAgICAgICAgICAgICAgICB7b3B0aW9uczpyaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OlwidmVydGljYWxcIixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzp0aGlzLnByb3BzLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOmNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgICAgICAgICBvbk1lYXN1cmU6Xy5wYXJ0aWFsKHRoaXMub25NZWFzdXJlLCBcInJpZ2h0XCIpLFxuICAgICAgICAgICAgICAgICAgICByZWY6XCJyaWdodFwifSApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uTWVhc3VyZTogZnVuY3Rpb24oc2lkZSwgZGltZW5zaW9ucykge1xuICAgICAgICB2YXIgaGVpZ2h0cyA9IF8uY2xvbmUodGhpcy5zdGF0ZS5oZWlnaHRzKTtcbiAgICAgICAgaGVpZ2h0c1tzaWRlXSA9IF8ubWF4KGRpbWVuc2lvbnMuaGVpZ2h0cyk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe2hlaWdodHM6IGhlaWdodHN9KTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5yZWZzLmxlZnQuZ2V0T3B0aW9ucygpLFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMucmVmcy5yaWdodC5nZXRPcHRpb25zKClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2ltcGxlVmFsaWRhdGU6IGZ1bmN0aW9uKHJ1YnJpYykge1xuICAgICAgICByZXR1cm4gTWF0Y2hlci52YWxpZGF0ZSh0aGlzLnRvSlNPTigpLCBydWJyaWMpO1xuICAgIH0sXG59KTtcblxuXG5fLmV4dGVuZChNYXRjaGVyLCB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHN0YXRlLCBydWJyaWMpIHtcbiAgICAgICAgdmFyIGNvcnJlY3QgPSBfLmlzRXF1YWwoc3RhdGUubGVmdCwgcnVicmljLmxlZnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgXy5pc0VxdWFsKHN0YXRlLnJpZ2h0LCBydWJyaWMucmlnaHQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgZWFybmVkOiBjb3JyZWN0ID8gMSA6IDAsXG4gICAgICAgICAgICB0b3RhbDogMSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59KTtcblxuXG52YXIgTWF0Y2hlckVkaXRvciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ01hdGNoZXJFZGl0b3InLFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBsZWZ0OiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIHJpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGxhYmVsczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgICAgICBvcmRlck1hdHRlcnM6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgICAgICBwYWRkaW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogW1wiJHgkXCIsIFwiJHkkXCIsIFwiJHokXCJdLFxuICAgICAgICAgICAgcmlnaHQ6IFtcIiQxJFwiLCBcIiQyJFwiLCBcIiQzJFwiXSxcbiAgICAgICAgICAgIGxhYmVsczogW1widGVzdFwiLCBcImxhYmVsXCJdLFxuICAgICAgICAgICAgb3JkZXJNYXR0ZXJzOiB0cnVlLFxuICAgICAgICAgICAgcGFkZGluZzogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtbWF0Y2hlci1lZGl0b3JcIn0sIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBcIiBDb3JyZWN0IGFuc3dlcjogXCIsXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJFbnRlciB0aGUgY29ycmVjdCBhbnN3ZXJzIGhlcmUuIFRoZSBwcmV2aWV3IG9uIHRoZSByaWdodCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJ3aWxsIHNob3cgdGhlIGNhcmRzIGluIGEgcmFuZG9taXplZCBvcmRlciwgd2hpY2ggaXMgaG93IHRoZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJzdHVkZW50IHdpbGwgc2VlIHRoZW0uXCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJ1aS1oZWxwZXItY2xlYXJmaXhcIn0sIFxuICAgICAgICAgICAgICAgIFRleHRMaXN0RWRpdG9yKFxuICAgICAgICAgICAgICAgICAgICB7b3B0aW9uczp0aGlzLnByb3BzLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtsZWZ0OiBvcHRpb25zfSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDpcInZlcnRpY2FsXCJ9ICksXG4gICAgICAgICAgICAgICAgVGV4dExpc3RFZGl0b3IoXG4gICAgICAgICAgICAgICAgICAgIHtvcHRpb25zOnRoaXMucHJvcHMucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtyaWdodDogb3B0aW9uc30sIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6XCJ2ZXJ0aWNhbFwifSApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4obnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgTGFiZWxzOiBcIixcbiAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIlRoZXNlIGFyZSBlbnRpcmVseSBvcHRpb25hbC5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoIHt0eXBlOlwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6dGhpcy5wcm9wcy5sYWJlbHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOl8uYmluZCh0aGlzLm9uTGFiZWxDaGFuZ2UsIHRoaXMsIDApfSApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dCgge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTp0aGlzLnByb3BzLmxhYmVsc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6Xy5iaW5kKHRoaXMub25MYWJlbENoYW5nZSwgdGhpcywgMSl9IClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFByb3BDaGVja0JveChcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsOlwiT3JkZXIgb2YgdGhlIG1hdGNoZWQgcGFpcnMgbWF0dGVyczpcIixcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJNYXR0ZXJzOnRoaXMucHJvcHMub3JkZXJNYXR0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCBvbmx5IHRoZSBvcmRlciBwcm92aWRlZCBhYm92ZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJ3aWxsIGJlIHRyZWF0ZWQgYXMgY29ycmVjdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBvcmRlcmluZyBpcyBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJzaWduaWZpY2FudCwgc3VjaCBhcyBpbiB0aGUgY29udGV4dCBvZiBhIHByb29mLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJJZiBkaXNhYmxlZCwgcGFpcndpc2UgbWF0Y2hpbmcgaXMgc3VmZmljaWVudC4gVG8gbWFrZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJ0aGlzIGNsZWFyLCB0aGUgbGVmdCBjb2x1bW4gYmVjb21lcyBmaXhlZCBpbiB0aGUgcHJvdmlkZWQgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwib3JkZXIgYW5kIG9ubHkgdGhlIGNhcmRzIGluIHRoZSByaWdodCBjb2x1bW4gY2FuIGJlIG1vdmVkLiBcIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgUHJvcENoZWNrQm94KFxuICAgICAgICAgICAgICAgICAgICB7bGFiZWw6XCJQYWRkaW5nOlwiLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOnRoaXMucHJvcHMucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIlBhZGRpbmcgaXMgZ29vZCBmb3IgdGV4dCwgYnV0IG5vdCBuZWVkZWQgZm9yIGltYWdlcy5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uTGFiZWxDaGFuZ2U6IGZ1bmN0aW9uKGluZGV4LCBlKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSBfLmNsb25lKHRoaXMucHJvcHMubGFiZWxzKTtcbiAgICAgICAgbGFiZWxzW2luZGV4XSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtsYWJlbHM6IGxhYmVsc30pO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmxlZnQubGVuZ3RoICE9PSB0aGlzLnByb3BzLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsZXJ0KFwiV2FybmluZzogVGhlIHR3byBoYWx2ZXMgb2YgdGhlIG1hdGNoZXIgaGF2ZSBkaWZmZXJlbnRcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIG51bWJlcnMgb2YgY2FyZHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF8ucGljayh0aGlzLnByb3BzLFxuICAgICAgICAgICAgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJsYWJlbHNcIiwgXCJvcmRlck1hdHRlcnNcIiwgXCJwYWRkaW5nXCJcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuV2lkZ2V0cy5yZWdpc3RlcihcIm1hdGNoZXJcIiwgTWF0Y2hlcik7XG5XaWRnZXRzLnJlZ2lzdGVyKFwibWF0Y2hlci1lZGl0b3JcIiwgTWF0Y2hlckVkaXRvcik7XG5cbn0pKFBlcnNldXMpO1xuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG4oZnVuY3Rpb24oUGVyc2V1cykge1xuXG5yZXF1aXJlKFwiLi4vY29yZS5qc1wiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG5yZXF1aXJlKFwiLi4vcmVuZGVyZXIuanN4XCIpO1xuXG52YXIgSW5mb1RpcCAgICAgICAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9pbmZvLXRpcC5qc3hcIik7XG52YXIgVGV4dExpc3RFZGl0b3IgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy90ZXh0LWxpc3QtZWRpdG9yLmpzeFwiKTtcbnZhciBXaWRnZXRzICAgICAgICA9IHJlcXVpcmUoXCIuLi93aWRnZXRzLmpzXCIpO1xuXG52YXIgUGxhY2Vob2xkZXJDYXJkID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnUGxhY2Vob2xkZXJDYXJkJyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImNhcmQtd3JhcFwiLCBzdHlsZTp7d2lkdGg6IHRoaXMucHJvcHMud2lkdGh9fSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KFxuICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6XCJjYXJkIHBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6e2hlaWdodDogdGhpcy5wcm9wcy5oZWlnaHR9fSApXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbnZhciBEcmFnSGludENhcmQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdEcmFnSGludENhcmQnLFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiY2FyZC13cmFwXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJjYXJkIGRyYWctaGludFwifSApXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbnZhciBEcmFnZ2FibGVDYXJkID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnRHJhZ2dhYmxlQ2FyZCcsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YWNrOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMud2lkdGgpIHtcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBbXCJjYXJkXCJdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zdGFjaykge1xuICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goXCJzdGFja1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1bGwgb3V0IHRoZSBjb250ZW50IHRvIGdldCByZW5kZXJlZFxuICAgICAgICB2YXIgcmVuZGVyZXJQcm9wcyA9IF8ucGljayh0aGlzLnByb3BzLCBcImNvbnRlbnRcIik7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJjYXJkLXdyYXBcIixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6c3R5bGV9LCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOmNsYXNzTmFtZS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd246dGhpcy5vbk1vdXNlRG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OnRoaXMub25Nb3VzZURvd259LCBcbiAgICAgICAgICAgICAgICAgICAgUGVyc2V1cy5SZW5kZXJlcihyZW5kZXJlclByb3BzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIShldmVudC5idXR0b24gPT09IDAgfHxcbiAgICAgICAgICAgICAgICAoZXZlbnQudG91Y2hlcyAhPSBudWxsICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChldmVudC50b3VjaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Nb3VzZURvd24odGhpcywge1xuICAgICAgICAgICAgICAgICAgICBwYWdlWDogZXZlbnQudG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Nb3VzZURvd24odGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxudmFyIEZsb2F0aW5nQ2FyZCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0Zsb2F0aW5nQ2FyZCcsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuaW1hdGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vdXNlOiB0aGlzLnByb3BzLnN0YXJ0TW91c2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMucHJvcHMuc3RhcnRPZmZzZXQubGVmdCxcbiAgICAgICAgICAgIHRvcDogdGhpcy5wcm9wcy5zdGFydE9mZnNldC50b3AsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5wcm9wcy53aWR0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBbXCJjYXJkXCJdO1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUucHVzaChcImRyYWdnaW5nXCIpO1xuICAgICAgICAgICAgc3R5bGUubGVmdCArPSB0aGlzLnN0YXRlLm1vdXNlLmxlZnQgLSB0aGlzLnByb3BzLnN0YXJ0TW91c2UubGVmdDtcbiAgICAgICAgICAgIHN0eWxlLnRvcCArPSB0aGlzLnN0YXRlLm1vdXNlLnRvcCAtIHRoaXMucHJvcHMuc3RhcnRNb3VzZS50b3A7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdWxsIG91dCB0aGUgY29udGVudCB0byBnZXQgcmVuZGVyZWRcbiAgICAgICAgdmFyIHJlbmRlcmVyUHJvcHMgPSBfLnBpY2sodGhpcy5wcm9wcywgXCJjb250ZW50XCIpO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiY2FyZC13cmFwXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOnN0eWxlfSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpjbGFzc05hbWUuam9pbihcIiBcIil9LCBcbiAgICAgICAgICAgICAgICAgICAgUGVyc2V1cy5SZW5kZXJlcihyZW5kZXJlclByb3BzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgJChkb2N1bWVudCkub24oXCJ2bW91c2Vtb3ZlXCIsIHRoaXMub25WTW91c2VNb3ZlKTtcbiAgICAgICAgJChkb2N1bWVudCkub24oXCJ2bW91c2V1cFwiLCB0aGlzLm9uVk1vdXNlVXApO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICQoZG9jdW1lbnQpLm9mZihcInZtb3VzZW1vdmVcIiwgdGhpcy5vblZNb3VzZU1vdmUpO1xuICAgICAgICAkKGRvY3VtZW50KS5vZmYoXCJ2bW91c2V1cFwiLCB0aGlzLm9uVk1vdXNlVXApO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcywgcHJldlN0YXRlLCByb290Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hbmltYXRpbmcgJiYgIXByZXZQcm9wcy5hbmltYXRpbmcpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGp1c3Qgd2VyZSBjaGFuZ2VkIGludG8gYW5pbWF0aW5nLCBzdGFydCB0aGUgYW5pbWF0aW9uLlxuICAgICAgICAgICAgLy8gV2UgcGljayB0aGUgYW5pbWF0aW9uIHNwZWVkIGJhc2VkIG9uIHRoZSBkaXN0YW5jZSB0aGF0IHRoZSBjYXJkXG4gICAgICAgICAgICAvLyBuZWVkcyB0byB0cmF2ZWwuIChXaHkgc3FydD8gSnVzdCBiZWNhdXNlIGl0IGxvb2tzIG5pY2UgLS0gd2l0aCBhXG4gICAgICAgICAgICAvLyBsaW5lYXIgc2NhbGUsIGZhciB0aGluZ3MgdGFrZSB0b28gbG9uZyB0byBjb21lIGJhY2suKVxuICAgICAgICAgICAgdmFyIG1zID0gMTUgKiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyh0aGlzLnByb3BzLmFuaW1hdGVUby5sZWZ0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zdGFydE9mZnNldC5sZWZ0LCAyKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KHRoaXMucHJvcHMuYW5pbWF0ZVRvLnRvcCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc3RhcnRPZmZzZXQudG9wLCAyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAkKHRoaXMuZ2V0RE9NTm9kZSgpKS5hbmltYXRlKFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuYW5pbWF0ZVRvLCBNYXRoLm1heChtcywgMSksXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvblZNb3VzZU1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZsb2F0aW5nKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbW91c2U6IHtsZWZ0OiBldmVudC5wYWdlWCwgdG9wOiBldmVudC5wYWdlWX1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk1vdXNlTW92ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvblZNb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5mbG9hdGluZykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Nb3VzZVVwKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgTk9STUFMID0gXCJub3JtYWxcIixcbiAgICBBVVRPID0gXCJhdXRvXCIsXG4gICAgSE9SSVpPTlRBTCA9IFwiaG9yaXpvbnRhbFwiLFxuICAgIFZFUlRJQ0FMID0gXCJ2ZXJ0aWNhbFwiO1xuXG52YXIgT3JkZXJlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ09yZGVyZXInLFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgICAgIG9wdGlvbnM6IFtdLFxuICAgICAgICAgICAgY29ycmVjdE9wdGlvbnM6IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiBOT1JNQUwsXG4gICAgICAgICAgICBsYXlvdXQ6IEhPUklaT05UQUxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJJbmRleDogbnVsbFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3JkZXJlciA9IHRoaXM7XG5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FyZCB3ZSBhcmUgY3VycmVudGx5IGRyYWdnaW5nXG4gICAgICAgIHZhciBkcmFnZ2luZyA9IHRoaXMuc3RhdGUuZHJhZ2dpbmcgJiZcbiAgICAgICAgICAgIEZsb2F0aW5nQ2FyZCgge2Zsb2F0aW5nOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6dGhpcy5zdGF0ZS5kcmFnQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6dGhpcy5zdGF0ZS5vZmZzZXRQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TW91c2U6dGhpcy5zdGF0ZS5ncmFiUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDp0aGlzLnN0YXRlLmRyYWdXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZVVwOnRoaXMub25SZWxlYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZTp0aGlzLm9uTW91c2VNb3ZlLFxuICAgICAgICAgICAgICAgICAgICAgICBrZXk6XCJkcmFnZ2luZ0NhcmRcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXJkIHRoYXQgaXMgY3VycmVudGx5IGFuaW1hdGluZ1xuICAgICAgICB2YXIgYW5pbWF0aW5nID0gdGhpcy5zdGF0ZS5hbmltYXRpbmcgJiZcbiAgICAgICAgICAgIEZsb2F0aW5nQ2FyZCgge2Zsb2F0aW5nOmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpbmc6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDp0aGlzLnN0YXRlLmRyYWdDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldDp0aGlzLnN0YXRlLm9mZnNldFBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6dGhpcy5zdGF0ZS5kcmFnV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVUbzp0aGlzLnN0YXRlLmFuaW1hdGVUbyxcbiAgICAgICAgICAgICAgICAgICAgICAgb25BbmltYXRpb25FbmQ6dGhpcy5zdGF0ZS5vbkFuaW1hdGlvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAga2V5OlwiZHJhZ2dpbmdDYXJkXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGlzdCBvZiBkcmFnZ2FibGUsIHJlYXJyYW5nYWJsZSBjYXJkc1xuICAgICAgICB2YXIgc29ydGFibGVDYXJkcyA9IF8ubWFwKHRoaXMuc3RhdGUuY3VycmVudCwgZnVuY3Rpb24ob3B0LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gRHJhZ2dhYmxlQ2FyZChcbiAgICAgICAgICAgICAgICB7cmVmOlwic29ydGFibGVcIiArIGksXG4gICAgICAgICAgICAgICAgY29udGVudDpvcHQuY29udGVudCxcbiAgICAgICAgICAgICAgICB3aWR0aDpvcHQud2lkdGgsXG4gICAgICAgICAgICAgICAga2V5Om9wdC5rZXksXG4gICAgICAgICAgICAgICAgb25Nb3VzZURvd246b3JkZXJlci5vbkNsaWNrLmJpbmQob3JkZXJlciwgXCJjdXJyZW50XCIsIGkpfSApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wbGFjZWhvbGRlckluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IFBsYWNlaG9sZGVyQ2FyZChcbiAgICAgICAgICAgICAgICB7cmVmOlwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICB3aWR0aDp0aGlzLnN0YXRlLmRyYWdXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6dGhpcy5zdGF0ZS5kcmFnSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGtleTpcInBsYWNlaG9sZGVyXCJ9ICk7XG4gICAgICAgICAgICBzb3J0YWJsZUNhcmRzLnNwbGljZSh0aGlzLnN0YXRlLnBsYWNlaG9sZGVySW5kZXgsIDAsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjYXJkcyBpbiB0aGUgbGlzdCwgdGhlbiBhZGQgYSBcImhpbnRcIiBjYXJkXG4gICAgICAgIHZhciBzb3J0YWJsZSA9IFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJ1aS1oZWxwZXItY2xlYXJmaXggZHJhZ2dhYmxlLWJveFwifSwgXG4gICAgICAgICAgICAhc29ydGFibGVDYXJkcy5sZW5ndGggJiYgRHJhZ0hpbnRDYXJkKG51bGwgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtyZWY6XCJkcmFnTGlzdFwifSwgc29ydGFibGVDYXJkcylcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBiYW5rIG9mIHN0YWNrcyBvZiBjYXJkc1xuICAgICAgICB2YXIgYmFuayA9IFJlYWN0LkRPTS5kaXYoIHtyZWY6XCJiYW5rXCIsIGNsYXNzTmFtZTpcImJhbmsgdWktaGVscGVyLWNsZWFyZml4XCJ9LCBcbiAgICAgICAgICAgIF8ubWFwKHRoaXMucHJvcHMub3B0aW9ucywgZnVuY3Rpb24ob3B0LCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERyYWdnYWJsZUNhcmQoXG4gICAgICAgICAgICAgICAgICAgIHtyZWY6XCJiYW5rXCIgKyBpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Om9wdC5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBzdGFjazp0cnVlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6aSxcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd246b3JkZXJlci5vbkNsaWNrLmJpbmQob3JkZXJlciwgXCJiYW5rXCIsIGkpfSApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImRyYWdneS1ib3h5LXRoaW5nIG9yZGVyZXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHQtXCIgKyB0aGlzLnByb3BzLmhlaWdodCArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGF5b3V0LVwiICsgdGhpcy5wcm9wcy5sYXlvdXQgKyBcIiB1aS1oZWxwZXItY2xlYXJmaXhcIixcbiAgICAgICAgICAgICAgICAgICAgcmVmOlwib3JkZXJlclwifSwgXG4gICAgICAgICAgICAgICAgICAgYmFuayxcbiAgICAgICAgICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgICBhbmltYXRpbmdcbiAgICAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKHR5cGUsIGluZGV4LCBkcmFnZ2FibGUsICBldmVudCkge1xuICAgICAgICB2YXIgJGRyYWdnYWJsZSA9ICQoZHJhZ2dhYmxlLmdldERPTU5vZGUoKSk7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdGF0ZS5jdXJyZW50LnNsaWNlKCk7XG5cbiAgICAgICAgdmFyIG9wdDtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVySW5kZXggPSBudWxsO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImN1cnJlbnRcIikge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBjb21pbmcgZnJvbSB0aGUgb3JpZ2luYWwgbGlzdCwgcmVtb3ZlIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gY2FyZCBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBvcHQgPSB0aGlzLnN0YXRlLmN1cnJlbnRbaW5kZXhdO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXJJbmRleCA9IGluZGV4O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYmFua1wiKSB7XG4gICAgICAgICAgICBvcHQgPSB0aGlzLnByb3BzLm9wdGlvbnNbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjdXJyZW50OiBsaXN0LFxuICAgICAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgICAgICBwbGFjZWhvbGRlckluZGV4OiBwbGFjZWhvbGRlckluZGV4LFxuICAgICAgICAgICAgZHJhZ0NvbnRlbnQ6IG9wdC5jb250ZW50LFxuICAgICAgICAgICAgZHJhZ1dpZHRoOiAkZHJhZ2dhYmxlLndpZHRoKCksXG4gICAgICAgICAgICBkcmFnSGVpZ2h0OiAkZHJhZ2dhYmxlLmhlaWdodCgpLFxuICAgICAgICAgICAgZ3JhYlBvczoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgICAgIHRvcDogZXZlbnQucGFnZVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvZmZzZXRQb3M6ICRkcmFnZ2FibGUucG9zaXRpb24oKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25SZWxlYXNlOiBmdW5jdGlvbihkcmFnZ2FibGUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpbkNhcmRCYW5rID0gdGhpcy5pc0NhcmRJbkJhbmsoZHJhZ2dhYmxlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zdGF0ZS5wbGFjZWhvbGRlckluZGV4O1xuXG4gICAgICAgIC8vIEhlcmUsIHdlIGJ1aWxkIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBjYXJkIHRvIGNhbGwgd2hlbiBpdCBpc1xuICAgICAgICAvLyBkb25lIGFuaW1hdGluZ1xuICAgICAgICB2YXIgb25BbmltYXRpb25FbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdGF0ZS5jdXJyZW50LnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmICghaW5DYXJkQmFuaykge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IGNhcmQgaW50byB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2FyZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5zdGF0ZS5kcmFnQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBfLnVuaXF1ZUlkKFwicGVyc2V1c19kcmFnZ2FibGVfY2FyZF9cIiksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnN0YXRlLmRyYWdXaWR0aFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMCwgbmV3Q2FyZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGxpc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgY3VycmVudDogbGlzdCxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJJbmRleDogbnVsbCxcbiAgICAgICAgICAgICAgICBhbmltYXRpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjYXJkIHdlIHNob3VsZCBhbmltYXRlIHRvXG4gICAgICAgIHZhciBvZmZzZXQgPSAkKGRyYWdnYWJsZS5nZXRET01Ob2RlKCkpLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBmaW5hbE9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmIChpbkNhcmRCYW5rKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY2FyZCBiYW5rLCBnbyB0aHJvdWdoIHRoZSBvcHRpb25zIHRvIGZpbmQgdGhlXG4gICAgICAgICAgICAvLyBvbmUgd2l0aCB0aGUgc2FtZSBjb250ZW50XG4gICAgICAgICAgICBfLmVhY2godGhpcy5wcm9wcy5vcHRpb25zLCBmdW5jdGlvbihvcHQsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmNvbnRlbnQgPT09IHRoaXMuc3RhdGUuZHJhZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhcmQgPSB0aGlzLnJlZnNbXCJiYW5rXCIgKyBpXS5nZXRET01Ob2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsT2Zmc2V0ID0gJChjYXJkKS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBnbyB0byB0aGUgcG9zaXRpb24gdGhhdCB0aGUgcGxhY2Vob2xkZXIgaXMgYXRcbiAgICAgICAgICAgIGZpbmFsT2Zmc2V0ID0gJCh0aGlzLnJlZnMucGxhY2Vob2xkZXIuZ2V0RE9NTm9kZSgpKS5wb3NpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbmFsT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgY2FyZCB0byBnbyB0bywgc2ltcGx5IG1ha2UgdGhlIGNoYW5nZXMgd2VcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUgbWFkZSBhdCB0aGUgZW5kLiAoc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHdlIGFyZVxuICAgICAgICAgICAgLy8gbWVzc2luZyBhcm91bmQgd2l0aCBjYXJkIGNvbnRlbnRzLCBhbmQgbm90IG9uIHRoZSByZWFsIHNpdGUpXG4gICAgICAgICAgICBvbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgb2Zmc2V0UG9zOiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgYW5pbWF0ZVRvOiBmaW5hbE9mZnNldCxcbiAgICAgICAgICAgICAgICBvbkFuaW1hdGlvbkVuZDogb25BbmltYXRpb25FbmQsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKGRyYWdnYWJsZSkge1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FyZEluQmFuayhkcmFnZ2FibGUpKSB7XG4gICAgICAgICAgICBpbmRleCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuZmluZENvcnJlY3RJbmRleChkcmFnZ2FibGUsIHRoaXMuc3RhdGUuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtwbGFjZWhvbGRlckluZGV4OiBpbmRleH0pO1xuICAgIH0sXG5cbiAgICBmaW5kQ29ycmVjdEluZGV4OiBmdW5jdGlvbihkcmFnZ2FibGUsIGxpc3QpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgY29ycmVjdCBpbmRleCBmb3IgYSBjYXJkIGdpdmVuIHRoZSBjdXJyZW50IGNhcmRzLlxuICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5wcm9wcy5sYXlvdXQgPT09IEhPUklaT05UQUwsXG4gICAgICAgICAgICAkZHJhZ0xpc3QgPSAkKHRoaXMucmVmcy5kcmFnTGlzdC5nZXRET01Ob2RlKCkpLFxuICAgICAgICAgICAgbGVmdEVkZ2UgPSAkZHJhZ0xpc3Qub2Zmc2V0KCkubGVmdCxcbiAgICAgICAgICAgIHRvcEVkZ2UgPSAkZHJhZ0xpc3Qub2Zmc2V0KCkudG9wLFxuICAgICAgICAgICAgbWlkV2lkdGggPSAkKGRyYWdnYWJsZS5nZXRET01Ob2RlKCkpLm9mZnNldCgpLmxlZnQgLSBsZWZ0RWRnZSxcbiAgICAgICAgICAgIG1pZEhlaWdodCA9ICQoZHJhZ2dhYmxlLmdldERPTU5vZGUoKSkub2Zmc2V0KCkudG9wIC0gdG9wRWRnZSxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIHN1bVdpZHRoID0gMCxcbiAgICAgICAgICAgIHN1bUhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3QsIGZ1bmN0aW9uKG9wdCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBjYXJkID0gdGhpcy5yZWZzW1wic29ydGFibGVcIiArIGldLmdldERPTU5vZGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ZXJXaWR0aCA9ICQoY2FyZCkub3V0ZXJXaWR0aCh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWlkV2lkdGggPiBzdW1XaWR0aCArIG91dGVyV2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bVdpZHRoICs9IG91dGVyV2lkdGg7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0LCBmdW5jdGlvbihvcHQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FyZCA9IHRoaXMucmVmc1tcInNvcnRhYmxlXCIgKyBpXS5nZXRET01Ob2RlKCk7XG4gICAgICAgICAgICAgICAgdmFyIG91dGVySGVpZ2h0ID0gJChjYXJkKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWlkSGVpZ2h0ID4gc3VtSGVpZ2h0ICsgb3V0ZXJIZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bUhlaWdodCArPSBvdXRlckhlaWdodDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICBpc0NhcmRJbkJhbms6IGZ1bmN0aW9uKGRyYWdnYWJsZSkge1xuICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5wcm9wcy5sYXlvdXQgPT09IEhPUklaT05UQUwsXG4gICAgICAgICAgICAkZHJhZ2dhYmxlID0gJChkcmFnZ2FibGUuZ2V0RE9NTm9kZSgpKSxcbiAgICAgICAgICAgICRiYW5rID0gJCh0aGlzLnJlZnMuYmFuay5nZXRET01Ob2RlKCkpLFxuICAgICAgICAgICAgZHJhZ2dhYmxlT2Zmc2V0ID0gJGRyYWdnYWJsZS5vZmZzZXQoKSxcbiAgICAgICAgICAgIGJhbmtPZmZzZXQgPSAkYmFuay5vZmZzZXQoKSxcbiAgICAgICAgICAgIGRyYWdnYWJsZUhlaWdodCA9ICRkcmFnZ2FibGUub3V0ZXJIZWlnaHQodHJ1ZSksXG4gICAgICAgICAgICBiYW5rSGVpZ2h0ID0gJGJhbmsub3V0ZXJIZWlnaHQodHJ1ZSksXG4gICAgICAgICAgICBiYW5rV2lkdGggPSAkYmFuay5vdXRlcldpZHRoKHRydWUpLFxuICAgICAgICAgICAgZHJhZ0xpc3QgPSB0aGlzLnJlZnMuZHJhZ0xpc3QuZ2V0RE9NTm9kZSgpLFxuICAgICAgICAgICAgZHJhZ0xpc3RXaWR0aCA9ICQoZHJhZ0xpc3QpLndpZHRoKCksXG4gICAgICAgICAgICBkcmFnZ2FibGVXaWR0aCA9ICRkcmFnZ2FibGUub3V0ZXJXaWR0aCh0cnVlKSxcbiAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9XG4gICAgICAgICAgICAgICAgXy5yZWR1Y2UodGhpcy5zdGF0ZS5jdXJyZW50LCBmdW5jdGlvbihzdW0sIG9wdCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FyZCA9IHRoaXMucmVmc1tcInNvcnRhYmxlXCIgKyBpXS5nZXRET01Ob2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyAkKGNhcmQpLm91dGVyV2lkdGgodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgMCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChkcmFnZ2FibGVPZmZzZXQudG9wICsgZHJhZ2dhYmxlSGVpZ2h0IC8gMiA8XG4gICAgICAgICAgICAgICAgICAgIGJhbmtPZmZzZXQudG9wICsgYmFua0hlaWdodCkgfHxcbiAgICAgICAgICAgICAgICAgICAoY3VycmVudFdpZHRoICsgZHJhZ2dhYmxlV2lkdGggPiBkcmFnTGlzdFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoZHJhZ2dhYmxlT2Zmc2V0LmxlZnQgKyBkcmFnZ2FibGVXaWR0aCAvIDIgPFxuICAgICAgICAgICAgICAgICAgICBiYW5rT2Zmc2V0LmxlZnQgKyBiYW5rV2lkdGgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtjdXJyZW50OiBfLm1hcCh0aGlzLnByb3BzLmN1cnJlbnQsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2LmNvbnRlbnQ7XG4gICAgICAgIH0pfTtcbiAgICB9LFxuXG4gICAgc2ltcGxlVmFsaWRhdGU6IGZ1bmN0aW9uKHJ1YnJpYykge1xuICAgICAgICByZXR1cm4gT3JkZXJlci52YWxpZGF0ZSh0aGlzLnRvSlNPTigpLCBydWJyaWMpO1xuICAgIH0sXG59KTtcblxuXy5leHRlbmQoT3JkZXJlciwge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbihzdGF0ZSwgcnVicmljKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvcnJlY3QgPSBfLmlzRXF1YWwoXG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LFxuICAgICAgICAgICAgXy5wbHVjayhydWJyaWMuY29ycmVjdE9wdGlvbnMsICdjb250ZW50JylcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgIGVhcm5lZDogY29ycmVjdCA/IDEgOiAwLFxuICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cblxudmFyIE9yZGVyZXJFZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdPcmRlcmVyRWRpdG9yJyxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29ycmVjdE9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7Y29udGVudDogXCIkeCRcIn1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvdGhlck9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7Y29udGVudDogXCIkeSRcIn1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBoZWlnaHQ6IE5PUk1BTCxcbiAgICAgICAgICAgIGxheW91dDogSE9SSVpPTlRBTFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcztcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtd2lkZ2V0LW9yZGVyZXJcIn0sIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBcIiBDb3JyZWN0IGFuc3dlcjogXCIsXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBSZWFjdC5ET00ucChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgUGxhY2UgdGhlIGNhcmRzIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBUaGUgc2FtZSBjYXJkIGNhbiBiZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJ1c2VkIG1vcmUgdGhhbiBvbmNlIGluIHRoZSBhbnN3ZXIgYnV0IHdpbGwgb25seSBiZSBcIisgXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheWVkIG9uY2UgYXQgdGhlIHRvcCBvZiBhIHN0YWNrIG9mIGlkZW50aWNhbCBjYXJkcy4gXCJcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFRleHRMaXN0RWRpdG9yKFxuICAgICAgICAgICAgICAgIHtvcHRpb25zOl8ucGx1Y2sodGhpcy5wcm9wcy5jb3JyZWN0T3B0aW9ucywgXCJjb250ZW50XCIpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMub25PcHRpb25zQ2hhbmdlLmJpbmQodGhpcywgXCJjb3JyZWN0T3B0aW9uc1wiKSxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6dGhpcy5wcm9wcy5sYXlvdXR9ICksXG5cbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgT3RoZXIgY2FyZHM6IFwiLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiQ3JlYXRlIGNhcmRzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBhbnN3ZXIuXCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFRleHRMaXN0RWRpdG9yKFxuICAgICAgICAgICAgICAgIHtvcHRpb25zOl8ucGx1Y2sodGhpcy5wcm9wcy5vdGhlck9wdGlvbnMsIFwiY29udGVudFwiKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLm9uT3B0aW9uc0NoYW5nZS5iaW5kKHRoaXMsIFwib3RoZXJPcHRpb25zXCIpLFxuICAgICAgICAgICAgICAgIGxheW91dDp0aGlzLnByb3BzLmxheW91dH0gKSxcblxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIExheW91dDogXCIsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoIHt2YWx1ZTp0aGlzLnByb3BzLmxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLm9uTGF5b3V0Q2hhbmdlfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6SE9SSVpPTlRBTH0sIFwiSG9yaXpvbnRhbFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpWRVJUSUNBTH0sIFwiVmVydGljYWxcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJVc2UgdGhlIGhvcml6b250YWwgbGF5b3V0IGZvciBzaG9ydCB0ZXh0IGFuZCBzbWFsbCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJpbWFnZXMuIFRoZSB2ZXJ0aWNhbCBsYXlvdXQgaXMgYmVzdCBmb3IgbG9uZ2VyIHRleHQgKGUuZy4gXCIrXG4gICAgICAgICAgICAgICAgICAgIFwicHJvb2ZzKS5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIEhlaWdodDogXCIsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoIHt2YWx1ZTp0aGlzLnByb3BzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLm9uSGVpZ2h0Q2hhbmdlfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6Tk9STUFMfSwgXCJOb3JtYWxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6QVVUT30sIFwiQXV0b21hdGljXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiVXNlIFxcXCJOb3JtYWxcXFwiIGZvciB0ZXh0LCBcXFwiQXV0b21hdGljXFxcIiBmb3IgaW1hZ2VzLlwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgb25PcHRpb25zQ2hhbmdlOiBmdW5jdGlvbih3aGljaE9wdGlvbnMsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICBwcm9wc1t3aGljaE9wdGlvbnNdID0gXy5tYXAob3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge2NvbnRlbnQ6IG9wdGlvbn07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHByb3BzLCBjYik7XG4gICAgfSxcblxuICAgIG9uTGF5b3V0Q2hhbmdlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2xheW91dDogZS50YXJnZXQudmFsdWV9KTtcbiAgICB9LFxuXG4gICAgb25IZWlnaHRDaGFuZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7aGVpZ2h0OiBlLnRhcmdldC52YWx1ZX0pO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIC8vIFdlIGNvbWJpbmUgdGhlIGNvcnJlY3QgYW5zd2VyIGFuZCB0aGUgb3RoZXIgY2FyZHMgYnkgbWVyZ2luZyB0aGVtLFxuICAgICAgICAvLyByZW1vdmluZyBkdXBsaWNhdGVzIGFuZCBlbXB0eSBjYXJkcywgYW5kIHNvcnRpbmcgdGhlbSBpbnRvXG4gICAgICAgIC8vIGNhdGVnb3JpZXMgYmFzZWQgb24gdGhlaXIgY29udGVudFxuICAgICAgICB2YXIgb3B0aW9ucyA9XG4gICAgICAgICAgICBfLmNoYWluKF8ucGx1Y2sodGhpcy5wcm9wcy5jb3JyZWN0T3B0aW9ucywgJ2NvbnRlbnQnKSlcbiAgICAgICAgICAgICAudW5pb24oXy5wbHVjayh0aGlzLnByb3BzLm90aGVyT3B0aW9ucywgJ2NvbnRlbnQnKSlcbiAgICAgICAgICAgICAudW5pcSgpXG4gICAgICAgICAgICAgLnJlamVjdChmdW5jdGlvbihjb250ZW50KSB7IHJldHVybiBjb250ZW50ID09PSBcIlwiOyB9KVxuICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAuc29ydEJ5KGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgaWYgKC9cXGQvLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9eXFwkP1thLXpBLVpdK1xcJD8kLy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29udGVudDogY29udGVudCB9O1xuICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgLnZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBjb3JyZWN0T3B0aW9uczogdGhpcy5wcm9wcy5jb3JyZWN0T3B0aW9ucyxcbiAgICAgICAgICAgIG90aGVyT3B0aW9uczogdGhpcy5wcm9wcy5vdGhlck9wdGlvbnMsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLnByb3BzLmxheW91dFxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5XaWRnZXRzLnJlZ2lzdGVyKFwib3JkZXJlclwiLCBPcmRlcmVyKTtcbldpZGdldHMucmVnaXN0ZXIoXCJvcmRlcmVyLWVkaXRvclwiLCBPcmRlcmVyRWRpdG9yKTtcblxufSkoUGVyc2V1cyk7XG5cbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xuXG52YXIgSW5mb1RpcCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2luZm8tdGlwLmpzeFwiKTtcbnZhciBUZXh0TGlzdEVkaXRvciA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL3RleHQtbGlzdC1lZGl0b3IuanN4XCIpO1xudmFyIFdpZGdldHMgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy5qc1wiKTtcblxudmFyIGRlZXBFcSA9IFV0aWwuZGVlcEVxO1xuXG52YXIgQkFSID0gXCJiYXJcIixcbiAgICBMSU5FID0gXCJsaW5lXCIsXG4gICAgUElDID0gXCJwaWNcIixcbiAgICBISVNUT0dSQU0gPSBcImhpc3RvZ3JhbVwiO1xuXG52YXIgUGxvdHRlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1Bsb3R0ZXInLFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICB0eXBlOiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoW0JBUiwgTElORSwgUElDLCBISVNUT0dSQU1dKVxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IEJBUixcbiAgICAgICAgICAgIGxhYmVsczogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgY2F0ZWdvcmllczogW1wiXCJdLFxuXG4gICAgICAgICAgICBzY2FsZVk6IDEsXG4gICAgICAgICAgICBtYXhZOiAxMCxcbiAgICAgICAgICAgIHNuYXBzUGVyTGluZTogMixcblxuICAgICAgICAgICAgcGljU2l6ZTogNDAsXG4gICAgICAgICAgICBwaWNCb3hIZWlnaHQ6IDQ4LFxuICAgICAgICAgICAgcGljVXJsOiBcIlwiLFxuXG4gICAgICAgICAgICBwbG90RGltZW5zaW9uczogWzM4MCwgMzAwXSAgICAgICAgXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMucHJvcHMuc3RhcnRpbmcgfHwgWzFdXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwicGVyc2V1cy13aWRnZXQtcGxvdHRlclwiLCByZWY6XCJncmFwaGllRGl2XCJ9KTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2V0dXBHcmFwaGllKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwR3JhcGhpZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXR1cEdyYXBoaWUoKTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFtcInR5cGVcIiwgXCJsYWJlbHNcIiwgXCJjYXRlZ29yaWVzXCIsIFwic2NhbGVZXCIsIFwibWF4WVwiLFxuICAgICAgICAgICAgXCJzbmFwc1BlckxpbmVcIiwgXCJwaWNVcmxcIl07XG5cbiAgICAgICAgdGhpcy5zaG91bGRTZXR1cEdyYXBoaWUgPSBfLmFueShwcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiAhXy5pc0VxdWFsKHRoaXMucHJvcHNbcHJvcF0sIG5leHRQcm9wc1twcm9wXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghXy5pc0VxdWFsKHRoaXMucHJvcHMuc3RhcnRpbmcsIG5leHRQcm9wcy5zdGFydGluZykgJiZcbiAgICAgICAgICAgICFfLmlzRXF1YWwodGhpcy5zdGF0ZS52YWx1ZXMsIG5leHRQcm9wcy5zdGFydGluZykpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkU2V0dXBHcmFwaGllID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlczogbmV4dFByb3BzLnN0YXJ0aW5nfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0dXBHcmFwaGllOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLnNob3VsZFNldHVwR3JhcGhpZSA9IGZhbHNlO1xuICAgICAgICB2YXIgZ3JhcGhpZURpdiA9IHNlbGYucmVmcy5ncmFwaGllRGl2LmdldERPTU5vZGUoKTtcbiAgICAgICAgJChncmFwaGllRGl2KS5lbXB0eSgpO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IEtoYW5VdGlsLmNyZWF0ZUdyYXBoaWUoZ3JhcGhpZURpdik7XG5cbiAgICAgICAgLy8gVE9ETyhqYWtlc2FuZGx1bmQpOiBJdCdzIG5vdCB0aGUgcmVhY3Qgd2F5IHRvIGhhbmdcbiAgICAgICAgLy8gc29tZXRoaW5nIG9mZiB0aGUgY29tcG9uZW50IG9iamVjdCwgYnV0IHNpbmNlIGdyYXBoaWVcbiAgICAgICAgLy8gaXMgb3V0c2lkZSBSZWFjdCwgaXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoaXMuXG4gICAgICAgIHNlbGYuZ3JhcGhpZSA9IGdyYXBoaWU7XG4gICAgICAgIHNlbGYuZ3JhcGhpZS5waWNzID0gW107XG4gICAgICAgIHNlbGYubW91c2Vkb3duUGljID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGlzQmFyID0gc2VsZi5wcm9wcy50eXBlID09PSBCQVIsXG4gICAgICAgICAgICBpc0xpbmUgPSBzZWxmLnByb3BzLnR5cGUgPT09IExJTkUsXG4gICAgICAgICAgICBpc1BpYyA9IHNlbGYucHJvcHMudHlwZSA9PT0gUElDLFxuICAgICAgICAgICAgaXNIaXN0b2dyYW0gPSBzZWxmLnByb3BzLnR5cGUgPT09IEhJU1RPR1JBTTtcblxuICAgICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICAgIHZhciBjID0gY29uZmlnOyAvLyBjIGZvciBzaG9ydFxuXG4gICAgICAgIGMuZ3JhcGggPSB7XG4gICAgICAgICAgICBsaW5lczogW10sXG4gICAgICAgICAgICBiYXJzOiBbXSxcbiAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICBkaXZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICAgICAgYy5zY2FsZVkgPSBzZWxmLnByb3BzLnNjYWxlWTtcbiAgICAgICAgYy5kaW1YID0gc2VsZi5wcm9wcy5jYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBsb3REaW1lbnNpb25zID0gc2VsZi5wcm9wcy5wbG90RGltZW5zaW9ucztcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgYy5kaW1YICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNIaXN0b2dyYW0pIHtcbiAgICAgICAgICAgIGMuYmFyUGFkID0gMDtcbiAgICAgICAgICAgIGMuYmFyV2lkdGggPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQmFyKSB7XG4gICAgICAgICAgICBjLmJhclBhZCA9IDAuMTU7XG4gICAgICAgICAgICBjLmJhcldpZHRoID0gMSAtIDIgKiBjLmJhclBhZDtcbiAgICAgICAgICAgIGMuZGltWCArPSAyICogYy5iYXJQYWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQaWMpIHtcbiAgICAgICAgICAgIGMucGljQm94SGVpZ2h0ID0gc2VsZi5wcm9wcy5waWNCb3hIZWlnaHQ7XG4gICAgICAgICAgICBjLnBpY0JveFdpZHRoUHggPSBjLnBpY0JveEhlaWdodCAqIDEuMztcbiAgICAgICAgICAgIHZhciBwaWNQYWRBbGxXaWR0aCA9IHBsb3REaW1lbnNpb25zWzBdIC0gYy5kaW1YICogYy5waWNCb3hXaWR0aFB4O1xuICAgICAgICAgICAgYy5waWNQYWQgPSBwaWNQYWRBbGxXaWR0aCAvICgyICogYy5kaW1YICsgMik7XG4gICAgICAgICAgICB2YXIgcGljRnVsbFdpZHRoID0gYy5waWNCb3hXaWR0aFB4ICsgMiAqIGMucGljUGFkO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gcHggdG8gXCJ1bnNjYWxlZFwiXG4gICAgICAgICAgICBjLnBpY1BhZCA9IGMucGljUGFkIC8gcGljRnVsbFdpZHRoO1xuICAgICAgICAgICAgYy5waWNCb3hXaWR0aCA9IGMucGljQm94V2lkdGhQeCAvIHBpY0Z1bGxXaWR0aDtcbiAgICAgICAgICAgIGMuZGltWCArPSAyICogYy5waWNQYWQ7XG4gICAgICAgIH1cbiAgICAgICAgYy5kaW1ZID0gTWF0aC5jZWlsKHNlbGYucHJvcHMubWF4WSAvIGMuc2NhbGVZKSAqIGMuc2NhbGVZO1xuICAgICAgICBjLnNjYWxlID0gXy5tYXAoW2MuZGltWCwgYy5kaW1ZXSwgZnVuY3Rpb24gKGRpbSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHBsb3REaW1lbnNpb25zW2ldIC8gZGltO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUGljKSB7XG4gICAgICAgICAgICBjLnNjYWxlWzFdID0gYy5waWNCb3hIZWlnaHQgLyBjLnNjYWxlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWRYID0gMjUgLyBjLnNjYWxlWzBdO1xuICAgICAgICB2YXIgcGFkWSA9IDI1IC8gYy5zY2FsZVsxXTtcblxuICAgICAgICBncmFwaGllLmluaXQoe1xuICAgICAgICAgICAgcmFuZ2U6IFtbLTMgKiBwYWRYLCBjLmRpbVggKyBwYWRYXSwgWy0zICogcGFkWSwgYy5kaW1ZICsgcGFkWV1dLFxuICAgICAgICAgICAgc2NhbGU6IGMuc2NhbGVcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYXBoaWUuYWRkTW91c2VMYXllcigpO1xuXG4gICAgICAgIGlmICghaXNQaWMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IGMuZGltWTsgeSArPSBjLnNjYWxlWSkge1xuICAgICAgICAgICAgICAgIGdyYXBoaWUubGFiZWwoXG4gICAgICAgICAgICAgICAgICAgIFswLCB5XSxcbiAgICAgICAgICAgICAgICAgICAgS2hhblV0aWwucm91bmRUb0FwcHJveCh5LCAyKSxcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzVGVYICovIHRydWUgLyogZm9yIHRoZSBcXGFwcHJveCBzeW1ib2wgKi9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGdyYXBoaWUuc3R5bGUoXG4gICAgICAgICAgICAgICAgICAgIHtzdHJva2U6IFwiIzAwMFwiLCBzdHJva2VXaWR0aDogMSwgb3BhY2l0eTogMC4zfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGllLmxpbmUoWzAsIHldLCBbYy5kaW1YLCB5XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zZXR1cENhdGVnb3JpZXMoY29uZmlnKTtcblxuICAgICAgICBpZiAoaXNQaWMpIHtcbiAgICAgICAgICAgIHNlbGYubW91c2Vkb3duUGljID0gZmFsc2U7XG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbihcIm1vdXNldXAucGxvdHRlclBpY1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vdXNlZG93blBpYyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmRyYXdQaWNIZWlnaHRzKHNlbGYuc3RhdGUudmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoaWUuc3R5bGUoXG4gICAgICAgICAgICB7c3Ryb2tlOiBcIiMwMDBcIiwgc3Ryb2tlV2lkdGg6IDIsIG9wYWNpdHk6IDEuMH0sXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBncmFwaGllLmxpbmUoWzAsIDBdLCBbYy5kaW1YLCAwXSk7XG4gICAgICAgICAgICAgICAgZ3JhcGhpZS5saW5lKFswLCAwXSwgWzAsIGMuZGltWV0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZ3JhcGhpZS5sYWJlbChbYy5kaW1YIC8gMiwgLTM1IC8gYy5zY2FsZVsxXV0sXG4gICAgICAgICAgICBzZWxmLnByb3BzLmxhYmVsc1swXSxcbiAgICAgICAgICAgIFwiYmVsb3dcIiwgZmFsc2UpXG4gICAgICAgICAgICAuY3NzKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpO1xuXG4gICAgICAgIGdyYXBoaWUubGFiZWwoWy02MCAvIGMuc2NhbGVbMF0sIGMuZGltWSAvIDJdLFxuICAgICAgICAgICAgc2VsZi5wcm9wcy5sYWJlbHNbMV0sXG4gICAgICAgICAgICBcImNlbnRlclwiLCBmYWxzZSlcbiAgICAgICAgICAgIC5jc3MoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcInJvdGF0ZVwiKTtcbiAgICB9LFxuXG5cdGxhYmVsQ2F0ZWdvcnk6IGZ1bmN0aW9uKHgsIGNhdGVnb3J5KSB7XG5cdFx0dmFyIGdyYXBoaWUgPSB0aGlzLmdyYXBoaWU7XG5cdFx0Y2F0ZWdvcnkgPSBjYXRlZ29yeSArIFwiXCI7XG5cdFx0dmFyIGlzVGVYID0gZmFsc2U7XG5cdFx0dmFyIG1hdGh5Q2F0ZWdvcnkgPSBjYXRlZ29yeS5tYXRjaCgvXlxcJCguKilcXCQkLyk7XG5cdFx0aWYgKG1hdGh5Q2F0ZWdvcnkpIHtcblx0XHRcdGNhdGVnb3J5ID0gbWF0aHlDYXRlZ29yeVsxXTtcblx0XHRcdGlzVGVYID0gdHJ1ZTtcblx0XHR9XG5cdFx0Z3JhcGhpZS5sYWJlbChbeCwgMF0sIGNhdGVnb3J5LCBcImJlbG93XCIsIGlzVGVYKTtcblx0fSxcblxuICAgIHNldHVwQ2F0ZWdvcmllczogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGMgPSBjb25maWc7XG4gICAgICAgIHZhciBncmFwaGllID0gc2VsZi5ncmFwaGllO1xuXG4gICAgICAgIGlmIChzZWxmLnByb3BzLnR5cGUgPT09IEhJU1RPR1JBTSkge1xuICAgICAgICAgICAgLy8gSGlzdG9ncmFtcyB3aXRoIG4gbGFiZWxzL2NhdGVnb3JpZXMgaGF2ZSBuIC0gMSBidWNrZXRzXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBfLnRpbWVzKHNlbGYucHJvcHMuY2F0ZWdvcmllcy5sZW5ndGggLSAxLCBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2V0dXBIaXN0b2dyYW0oaSwgc2VsZi5zdGF0ZS52YWx1ZXNbaV0sIGNvbmZpZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2NhbGUgYnVja2V0cyAoYmFycykgYW5kIGRpdmlkZXJzXG4gICAgICAgICAgICBfLmludm9rZShzY2FsZSwgXCJjYWxsXCIpO1xuXG4gICAgICAgICAgICAvLyBMYWJlbCBjYXRlZ29yaWVzXG4gICAgICAgICAgICBfLmVhY2goc2VsZi5wcm9wcy5jYXRlZ29yaWVzLCBmdW5jdGlvbihjYXRlZ29yeSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gMC41ICsgaSAqIGMuYmFyV2lkdGg7XG5cblx0XHRcdFx0c2VsZi5sYWJlbENhdGVnb3J5KHgsIGNhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICB2YXIgdGlja0hlaWdodCA9IDYgLyBjLnNjYWxlWzFdO1xuICAgICAgICAgICAgICAgIGdyYXBoaWUuc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMFwiLCBzdHJva2VXaWR0aDogMiwgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWUubGluZShbeCwgLXRpY2tIZWlnaHRdLCBbeCwgMF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLmVhY2goc2VsZi5wcm9wcy5jYXRlZ29yaWVzLCBmdW5jdGlvbiAoY2F0ZWdvcnksIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRIZWlnaHQgPSBzZWxmLnN0YXRlLnZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgeDtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnByb3BzLnR5cGUgPT09IEJBUikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gc2VsZi5zZXR1cEJhcihpLCBzdGFydEhlaWdodCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYucHJvcHMudHlwZSA9PT0gTElORSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gc2VsZi5zZXR1cExpbmUoaSwgc3RhcnRIZWlnaHQsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnByb3BzLnR5cGUgPT09IFBJQykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gc2VsZi5zZXR1cFBpYyhpLCBzdGFydEhlaWdodCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9XG5cblx0XHRcdFx0c2VsZi5sYWJlbENhdGVnb3J5KHgsIGNhdGVnb3J5KTtcblxuICAgICAgICAgICAgICAgIHZhciB0aWNrSGVpZ2h0ID0gNiAvIGMuc2NhbGVbMV07XG4gICAgICAgICAgICAgICAgZ3JhcGhpZS5zdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwXCIsIHN0cm9rZVdpZHRoOiAyLCBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpZS5saW5lKFt4LCAtdGlja0hlaWdodF0sIFt4LCAwXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXR1cEhpc3RvZ3JhbTogZnVuY3Rpb24oaSwgc3RhcnRIZWlnaHQsIGNvbmZpZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjID0gY29uZmlnO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHNlbGYuZ3JhcGhpZTtcbiAgICAgICAgdmFyIGJhckhhbGZXaWR0aCA9IGMuYmFyV2lkdGggLyAyO1xuICAgICAgICB2YXIgeCA9IDAuNSArIGkgKiBjLmJhcldpZHRoICsgYmFySGFsZldpZHRoOyAgICAgICAgXG5cbiAgICAgICAgdmFyIHNjYWxlQmFyID0gZnVuY3Rpb24oaSwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gZ3JhcGhpZS5zY2FsZVBvaW50KDApO1xuXG4gICAgICAgICAgICAvLyBTY2FsZSBmaWxsZWQgYnVja2V0IChiYXIpXG4gICAgICAgICAgICBjLmdyYXBoLmJhcnNbaV0uc2NhbGUoXG4gICAgICAgICAgICAgICAgMSwgTWF0aC5tYXgoMC4wMSwgaGVpZ2h0IC8gYy5zY2FsZVkpLFxuICAgICAgICAgICAgICAgIGNlbnRlclswXSwgY2VudGVyWzFdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBTY2FsZSBkaXZpZGVycyBiZXR3ZWVuIGJ1Y2tldHNcbiAgICAgICAgICAgIHZhciBsZWZ0RGl2aWRlciA9IGMuZ3JhcGguZGl2aWRlcnNbaSAtIDFdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RGl2aWRlciA9IGMuZ3JhcGguZGl2aWRlcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChsZWZ0RGl2aWRlcikge1xuICAgICAgICAgICAgICAgIHZhciBkaXZIZWlnaHQgPSBNYXRoLm1pbihzZWxmLnN0YXRlLnZhbHVlc1tpIC0gMV0sIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGVmdERpdmlkZXIuc2NhbGUoXG4gICAgICAgICAgICAgICAgICAgIDEsIE1hdGgubWF4KDAuMDEsIGRpdkhlaWdodCAvIGMuc2NhbGVZKSxcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyWzBdLCBjZW50ZXJbMV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmlnaHREaXZpZGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpdkhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgc2VsZi5zdGF0ZS52YWx1ZXNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICByaWdodERpdmlkZXIuc2NhbGUoXG4gICAgICAgICAgICAgICAgICAgIDEsIE1hdGgubWF4KDAuMDEsIGRpdkhlaWdodCAvIGMuc2NhbGVZKSxcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyWzBdLCBjZW50ZXJbMV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGlnbiB0b3Agb2YgYmFyIHRvIGVkZ2UgdW5sZXNzIGF0IGJvdHRvbVxuICAgICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGMuZ3JhcGgubGluZXNbaV0udmlzaWJsZUxpbmUudHJhbnNsYXRlKDAsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGdyYXBoaWUuc3R5bGUoe1xuICAgICAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIiwgZmlsbDogXCIjOWFiOGVkXCIsIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGMuZ3JhcGguYmFyc1tpXSA9IGdyYXBoaWUucGF0aChbXG4gICAgICAgICAgICAgICAgW3ggLSBiYXJIYWxmV2lkdGgsIDBdLFxuICAgICAgICAgICAgICAgIFt4IC0gYmFySGFsZldpZHRoLCBjLnNjYWxlWV0sXG4gICAgICAgICAgICAgICAgW3ggKyBiYXJIYWxmV2lkdGgsIGMuc2NhbGVZXSxcbiAgICAgICAgICAgICAgICBbeCArIGJhckhhbGZXaWR0aCwgMF0sXG4gICAgICAgICAgICAgICAgW3ggLSBiYXJIYWxmV2lkdGgsIDBdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGRyYXcgYSBkaXZpZGVyIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBidWNrZXRcbiAgICAgICAgICAgIGdyYXBoaWUuc3R5bGUoe1xuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwXCIsIHN0cm9rZVdpZHRoOiAxLCBvcGFjaXR5OiAwLjNcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGMuZ3JhcGguZGl2aWRlcnMucHVzaChncmFwaGllLnBhdGgoW1xuICAgICAgICAgICAgICAgICAgICBbeCAtIGJhckhhbGZXaWR0aCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFt4IC0gYmFySGFsZldpZHRoLCBjLnNjYWxlWV1cbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMuZ3JhcGgubGluZXNbaV0gPSBncmFwaGllLmFkZE1vdmFibGVMaW5lU2VnbWVudCh7XG4gICAgICAgICAgICBjb29yZEE6IFt4IC0gYmFySGFsZldpZHRoLCBzdGFydEhlaWdodF0sXG4gICAgICAgICAgICBjb29yZFo6IFt4ICsgYmFySGFsZldpZHRoLCBzdGFydEhlaWdodF0sXG4gICAgICAgICAgICBzbmFwWTogYy5zY2FsZVkgLyBzZWxmLnByb3BzLnNuYXBzUGVyTGluZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWluWDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VcIjogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiA0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGMuZ3JhcGgubGluZXNbaV0ub25Nb3ZlID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuY29vcmRBWzFdO1xuICAgICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPiBjLmRpbVkpIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5taW4oTWF0aC5tYXgoeSwgMCksIGMuZGltWSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZEFbMV0gPSB0aGlzLmNvb3JkWlsxXSA9IHk7XG5cbiAgICAgICAgICAgICAgICAvLyBTbmFwIHRoZSBsaW5lIGJhY2sgaW50byByYW5nZS5cbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gXy5jbG9uZShzZWxmLnN0YXRlLnZhbHVlcyk7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSB5O1xuICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZSh7dmFsdWVzOiB2YWx1ZXN9KTtcbiAgICAgICAgICAgIHNlbGYucHJvcHMub25DaGFuZ2UoeyB2YWx1ZXM6IHZhbHVlcyB9KTtcblxuICAgICAgICAgICAgc2NhbGVCYXIoaSwgeSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF8uYmluZChzY2FsZUJhciwgdGhpcywgaSwgc3RhcnRIZWlnaHQpO1xuICAgIH0sXG5cbiAgICBzZXR1cEJhcjogZnVuY3Rpb24oaSwgc3RhcnRIZWlnaHQsIGNvbmZpZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjID0gY29uZmlnO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHNlbGYuZ3JhcGhpZTtcbiAgICAgICAgdmFyIHggPSBpICsgMC41ICsgYy5iYXJQYWQ7XG4gICAgICAgIHZhciBiYXJIYWxmV2lkdGggPSBjLmJhcldpZHRoIC8gMjtcblxuICAgICAgICB2YXIgc2NhbGVCYXIgPSBmdW5jdGlvbihpLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBncmFwaGllLnNjYWxlUG9pbnQoMCk7XG4gICAgICAgICAgICBjLmdyYXBoLmJhcnNbaV0uc2NhbGUoXG4gICAgICAgICAgICAgICAgICAgIDEsIE1hdGgubWF4KDAuMDEsIGhlaWdodCAvIGMuc2NhbGVZKSxcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyWzBdLCBjZW50ZXJbMV0pO1xuXG4gICAgICAgICAgICAvLyBBbGlnbiB0b3Agb2YgYmFyIHRvIGVkZ2UgdW5sZXNzIGF0IGJvdHRvbVxuICAgICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGMuZ3JhcGgubGluZXNbaV0udmlzaWJsZUxpbmUudHJhbnNsYXRlKDAsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGdyYXBoaWUuc3R5bGUoXG4gICAgICAgICAgICB7c3Ryb2tlOiBcIm5vbmVcIiwgZmlsbDogXCIjOWFiOGVkXCIsIG9wYWNpdHk6IDEuMH0sXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjLmdyYXBoLmJhcnNbaV0gPSBncmFwaGllLnBhdGgoW1xuICAgICAgICAgICAgICAgICAgICBbeCAtIGJhckhhbGZXaWR0aCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIFt4IC0gYmFySGFsZldpZHRoLCBjLnNjYWxlWV0sXG4gICAgICAgICAgICAgICAgICAgIFt4ICsgYmFySGFsZldpZHRoLCBjLnNjYWxlWV0sXG4gICAgICAgICAgICAgICAgICAgIFt4ICsgYmFySGFsZldpZHRoLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgW3ggLSBiYXJIYWxmV2lkdGgsIDBdXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjLmdyYXBoLmxpbmVzW2ldID0gZ3JhcGhpZS5hZGRNb3ZhYmxlTGluZVNlZ21lbnQoe1xuICAgICAgICAgICAgY29vcmRBOiBbeCAtIGJhckhhbGZXaWR0aCwgc3RhcnRIZWlnaHRdLFxuICAgICAgICAgICAgY29vcmRaOiBbeCArIGJhckhhbGZXaWR0aCwgc3RhcnRIZWlnaHRdLFxuICAgICAgICAgICAgc25hcFk6IGMuc2NhbGVZIC8gc2VsZi5wcm9wcy5zbmFwc1BlckxpbmUsXG4gICAgICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpblg6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IEtoYW5VdGlsLkJMVUUsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogNFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjLmdyYXBoLmxpbmVzW2ldLm9uTW92ZSA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmNvb3JkQVsxXTtcbiAgICAgICAgICAgIGlmICh5IDwgMCB8fCB5ID4gYy5kaW1ZKSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKE1hdGgubWF4KHksIDApLCBjLmRpbVkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRBWzFdID0gdGhpcy5jb29yZFpbMV0gPSB5O1xuXG4gICAgICAgICAgICAgICAgLy8gU25hcCB0aGUgbGluZSBiYWNrIGludG8gcmFuZ2UuXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF8uY2xvbmUoc2VsZi5zdGF0ZS52YWx1ZXMpO1xuICAgICAgICAgICAgdmFsdWVzW2ldID0geTtcbiAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUoe3ZhbHVlczogdmFsdWVzfSk7XG4gICAgICAgICAgICBzZWxmLnByb3BzLm9uQ2hhbmdlKHsgdmFsdWVzOiB2YWx1ZXMgfSk7XG5cbiAgICAgICAgICAgIHNjYWxlQmFyKGksIHkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjYWxlQmFyKGksIHN0YXJ0SGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgIHNldHVwTGluZTogZnVuY3Rpb24oaSwgc3RhcnRIZWlnaHQsIGNvbmZpZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjID0gY29uZmlnO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHNlbGYuZ3JhcGhpZTtcbiAgICAgICAgdmFyIHggPSBpICsgMTtcbiAgICAgICAgYy5ncmFwaC5wb2ludHNbaV0gPSBncmFwaGllLmFkZE1vdmFibGVQb2ludCh7XG4gICAgICAgICAgICBjb29yZDogW3gsIHN0YXJ0SGVpZ2h0XSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWluWDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogS2hhblV0aWwuQkxVRSxcbiAgICAgICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkJMVUVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbmFwWTogYy5zY2FsZVkgLyBzZWxmLnByb3BzLnNuYXBzUGVyTGluZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGMuZ3JhcGgucG9pbnRzW2ldLm9uTW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHkgPSBNYXRoLm1pbihNYXRoLm1heCh5LCAwKSwgYy5kaW1ZKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBfLmNsb25lKHNlbGYuc3RhdGUudmFsdWVzKTtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHk7XG4gICAgICAgICAgICBzZWxmLnNldFN0YXRlKHt2YWx1ZXM6IHZhbHVlc30pO1xuICAgICAgICAgICAgc2VsZi5wcm9wcy5vbkNoYW5nZSh7IHZhbHVlczogdmFsdWVzIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBjLmdyYXBoLmxpbmVzW2ldID0gZ3JhcGhpZS5hZGRNb3ZhYmxlTGluZVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgIHBvaW50QTogYy5ncmFwaC5wb2ludHNbaSAtIDFdLFxuICAgICAgICAgICAgICAgIHBvaW50WjogYy5ncmFwaC5wb2ludHNbaV0sXG4gICAgICAgICAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZml4ZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjOWFiOGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9LFxuXG4gICAgc2V0dXBQaWM6IGZ1bmN0aW9uKGksIHN0YXJ0SGVpZ2h0LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYyA9IGNvbmZpZztcbiAgICAgICAgdmFyIGdyYXBoaWUgPSBzZWxmLmdyYXBoaWU7XG4gICAgICAgIHZhciBwaWNzID0gZ3JhcGhpZS5waWNzO1xuICAgICAgICB2YXIgeCA9IGkgKyAwLjUgKyBjLnBpY1BhZDtcblxuICAgICAgICBwaWNzW2ldID0gW107XG4gICAgICAgIHZhciBuID0gTWF0aC5yb3VuZChjLmRpbVkgLyBjLnNjYWxlWSkgKyAxO1xuICAgICAgICBfKG4pLnRpbWVzKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgIGogLT0gMTtcbiAgICAgICAgICAgIHZhciBtaWRZID0gKGogKyAwLjUpICogYy5zY2FsZVk7XG4gICAgICAgICAgICB2YXIgbGVmdFggPSB4IC0gYy5waWNCb3hXaWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgdG9wWSA9IG1pZFkgKyAwLjUgKiBjLnNjYWxlWTtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IGdyYXBoaWUuc2NhbGVQb2ludChbbGVmdFgsIHRvcFldKTtcbiAgICAgICAgICAgIHZhciBtb3VzZVJlY3QgPSBncmFwaGllLm1vdXNlbGF5ZXIucmVjdChcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMF0sIGNvb3JkWzFdLCBjLnBpY0JveFdpZHRoUHgsIGMucGljQm94SGVpZ2h0KTtcbiAgICAgICAgICAgICQobW91c2VSZWN0WzBdKVxuICAgICAgICAgICAgICAgIC5jc3Moe2ZpbGw6IFwiIzAwMFwiLCBvcGFjaXR5OiAwLjAsIGN1cnNvcjogXCJwb2ludGVyXCJ9KVxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW91c2Vkb3duUGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRQaWNIZWlnaHQoaSwgdG9wWSk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW91c2Vkb3duUGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFBpY0hlaWdodChpLCB0b3BZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGEgcGljIHVuZGVybmVhdGggdGhlIGF4aXMhXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjYWxlZENlbnRlciA9IGdyYXBoaWUuc2NhbGVQb2ludChbeCwgbWlkWV0pO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBzZWxmLnByb3BzLnBpY1NpemU7XG4gICAgICAgICAgICBwaWNzW2ldW2pdID0gZ3JhcGhpZS5yYXBoYWVsLmltYWdlKFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnByb3BzLnBpY1VybCxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVkQ2VudGVyWzBdIC0gc2l6ZSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlZENlbnRlclsxXSAtIHNpemUgLyAyLFxuICAgICAgICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICAgICAgICBzaXplKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICBzZXRQaWNIZWlnaHQ6IGZ1bmN0aW9uKGksIHkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IF8uY2xvbmUodGhpcy5zdGF0ZS52YWx1ZXMpO1xuICAgICAgICB2YWx1ZXNbaV0gPSB5O1xuICAgICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZXM6IHZhbHVlc30pO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHsgdmFsdWVzOiB2YWx1ZXMgfSk7XG4gICAgICAgIHRoaXMuZHJhd1BpY0hlaWdodHModmFsdWVzKTtcbiAgICB9LFxuXG4gICAgZHJhd1BpY0hlaWdodHM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncmFwaGllID0gc2VsZi5ncmFwaGllO1xuICAgICAgICB2YXIgcGljcyA9IGdyYXBoaWUucGljcztcbiAgICAgICAgXy5lYWNoKHBpY3MsIGZ1bmN0aW9uKHBzLCBpKSB7XG4gICAgICAgICAgICBfLmVhY2gocHMsIGZ1bmN0aW9uKHBpYywgaikge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gKGogKyAxKSAqIHNlbGYucHJvcHMuc2NhbGVZO1xuICAgICAgICAgICAgICAgIHZhciBzaG93ID0geSA8PSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgJChwaWNbMF0pLmNzcyh7b3BhY2l0eTogc2hvdyA/IDEuMCA6IDAuMH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnZhbHVlcztcbiAgICB9LFxuXG4gICAgc2ltcGxlVmFsaWRhdGU6IGZ1bmN0aW9uKHJ1YnJpYykge1xuICAgICAgICByZXR1cm4gUGxvdHRlci52YWxpZGF0ZSh0aGlzLnRvSlNPTigpLCBydWJyaWMpO1xuICAgIH0sXG59KTtcblxuXy5leHRlbmQoUGxvdHRlciwge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZ3Vlc3MsIHJ1YnJpYykge1xuICAgICAgICBpZiAoZGVlcEVxKGd1ZXNzLCBydWJyaWMuc3RhcnRpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgZWFybmVkOiBkZWVwRXEoZ3Vlc3MsIHJ1YnJpYy5jb3JyZWN0KSA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBSZXR1cm4gYSBjb3B5IG9mIGFycmF5IHdpdGggbGVuZ3RoIG4sIHBhZGRlZCB3aXRoIGdpdmVuIHZhbHVlXG5mdW5jdGlvbiBwYWRBcnJheShhcnJheSwgbiwgdmFsdWUpIHtcbiAgICB2YXIgY29weSA9IF8uY2xvbmUoYXJyYXkpO1xuICAgIGNvcHkubGVuZ3RoID0gbjtcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvcHlbaV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciBlZGl0b3JEZWZhdWx0cyA9IHtcbiAgICBzY2FsZVk6IDEsXG4gICAgbWF4WTogMTAsXG4gICAgc25hcHNQZXJMaW5lOiAyXG59O1xuXG52YXIgUGxvdHRlckVkaXRvciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1Bsb3R0ZXJFZGl0b3InLFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICB0eXBlOiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoW0JBUiwgTElORSwgUElDLCBISVNUT0dSQU1dKVxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBlZGl0b3JEZWZhdWx0cywge1xuICAgICAgICAgICAgY29ycmVjdDogWzFdLFxuICAgICAgICAgICAgc3RhcnRpbmc6IFsxXSxcblxuICAgICAgICAgICAgdHlwZTogQkFSLFxuICAgICAgICAgICAgbGFiZWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBbXCJcIl0sXG5cbiAgICAgICAgICAgIHBpY1NpemU6IDMwLFxuICAgICAgICAgICAgcGljQm94SGVpZ2h0OiAzNixcbiAgICAgICAgICAgIHBpY1VybDogS2hhbi5pbWFnZUJhc2UgKyBcImJhZGdlcy9lYXJ0aC1zbWFsbC5wbmdcIixcblxuICAgICAgICAgICAgcGxvdERpbWVuc2lvbnM6IFsyNzUsIDIwMF1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGl0aW5nOiBcImNvcnJlY3RcIlxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2V0RnJvbVNjYWxlID0gdGhpcy5wcm9wcy50eXBlID09PSBMSU5FIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnR5cGUgPT09IEhJU1RPR1JBTTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLXdpZGdldC1wbG90dGVyLWVkaXRvclwifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFwiIENoYXJ0IHR5cGU6IFwiLFxuICAgICAgICAgICAgICAgIF8ubWFwKFtCQVIsIExJTkUsIFBJQywgSElTVE9HUkFNXSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmxhYmVsKCB7a2V5OnR5cGV9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTpcInJhZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcImNoYXJ0LXR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOnRoaXMucHJvcHMudHlwZSA9PT0gdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpfLnBhcnRpYWwodGhpcy5jaGFuZ2VUeXBlLCB0eXBlKX0gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgTGFiZWxzOiBcIixcbiAgICAgICAgICAgICAgICBfLm1hcChbXCJ4XCIsIFwieVwiXSwgZnVuY3Rpb24oYXhpcywgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmxhYmVsKCB7a2V5OmF4aXN9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMgKyBcIjpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTpfLnBhcnRpYWwodGhpcy5jaGFuZ2VMYWJlbCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOnRoaXMucHJvcHMubGFiZWxzW2ldfSApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBzZXRGcm9tU2NhbGUgJiYgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBTY2FsZSAoeCk6IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOlwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcInNjYWxlWFwifSApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIE1heCB4OiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6XCJtYXhYXCJ9IClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmJ1dHRvbigge29uQ2xpY2s6dGhpcy5zZXRDYXRlZ29yaWVzRnJvbVNjYWxlfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBTZXQgY2F0ZWdvcmllcyBmcm9tIHNjYWxlIFwiXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJBdXRvbWF0aWNhbGx5IHNldHMgY2F0ZWdvcmllcyBhY2NvcmRpbmcgdG8gdGhlIHgtYXhpcyBcIitcbiAgICAgICAgICAgICAgICAgICAgICBcInNjYWxlIGFuZCBtYXggdmFsdWVzLlwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMudHlwZSA9PT0gUElDICYmIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBQaWN0dXJlOiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3R5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6XCJwaWMtdXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6dGhpcy5wcm9wcy5waWNVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleVByZXNzOnRoaXMuY2hhbmdlUGljVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25CbHVyOnRoaXMuY2hhbmdlUGljVXJsfSApLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiVXNlIHRoZSBkZWZhdWx0IHBpY3R1cmUgb2YgRWFydGgsIG9yIGluc2VydCB0aGUgVVJMIGZvciBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJhIGRpZmZlcmVudCBwaWN0dXJlIHVzaW5nIHRoZSBcXFwiQWRkIGltYWdlXFxcIiBmdW5jdGlvbi5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBDYXRlZ29yaWVzOiBcIixcbiAgICAgICAgICAgICAgICAgICAgVGV4dExpc3RFZGl0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwiY2F0ZWdvcmllc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OlwiaG9yaXpvbnRhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczp0aGlzLnByb3BzLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmNoYW5nZUNhdGVnb3JpZXN9IClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIFNjYWxlICh5KTogXCIsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOlwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5jaGFuZ2VTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTp0aGlzLnByb3BzLnNjYWxlWX0gKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgTWF4IHk6IFwiLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpcIm1heFlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuY2hhbmdlTWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOnRoaXMucHJvcHMubWF4WX0gKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aGlzLnByb3BzLnR5cGUgIT09IFBJQyAmJiBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgU25hcHMgcGVyIGxpbmU6IFwiLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuY2hhbmdlU25hcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6dGhpcy5wcm9wcy5zbmFwc1BlckxpbmV9IClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiQ3JlYXRlcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkaXZpc2lvbnMgYmV0d2VlbiB0aGUgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwiaG9yaXpvbnRhbCBsaW5lcy4gRmV3ZXIgc25hcHMgYmV0d2VlbiBsaW5lcyBtYWtlcyB0aGUgZ3JhcGggXCIrXG4gICAgICAgICAgICAgICAgICAgIFwiZWFzaWVyIGZvciB0aGUgc3R1ZGVudCB0byBjcmVhdGUgY29ycmVjdGx5LlwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFwiIEVkaXRpbmcgdmFsdWVzOiBcIixcbiAgICAgICAgICAgICAgICBfLm1hcChbXCJjb3JyZWN0XCIsIFwic3RhcnRpbmdcIl0sIGZ1bmN0aW9uKGVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5sYWJlbCgge2tleTplZGl0aW5nfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uaW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3R5cGU6XCJyYWRpb1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6XCJlZGl0aW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDp0aGlzLnN0YXRlLmVkaXRpbmcgPT09IGVkaXRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6Xy5wYXJ0aWFsKHRoaXMuY2hhbmdlRWRpdGluZywgZWRpdGluZyl9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRpbmdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFJlYWN0LkRPTS5wKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBVc2UgdGhpcyB0b2dnbGUgdG8gc3dpdGNoIGJldHdlZW4gZWRpdGluZyB0aGUgY29ycmVjdCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJhbnN3ZXIgKHdoYXQgdGhlIHN0dWRlbnQgd2lsbCBiZSBncmFkZWQgb24pIGFuZCB0aGUgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwic3RhcnRpbmcgdmFsdWVzICh3aGF0IHRoZSBzdHVkZW50IHdpbGwgc2VlIHBsb3R0ZWQgd2hlbiBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJ0aGV5IHN0YXJ0IHRoZSBwcm9ibGVtKS4gTm90ZTogVGhlc2UgY2Fubm90IGJlIHRoZSBzYW1lLiBcIlxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdGhpcy50cmFuc2ZlclByb3BzVG8oXG4gICAgICAgICAgICAgICAgUGxvdHRlcihcbiAgICAgICAgICAgICAgICAgICAge3N0YXJ0aW5nOnRoaXMucHJvcHNbdGhpcy5zdGF0ZS5lZGl0aW5nXSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5oYW5kbGVQbG90dGVyQ2hhbmdlfSApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGhhbmRsZVBsb3R0ZXJDaGFuZ2U6IGZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICBwcm9wc1t0aGlzLnN0YXRlLmVkaXRpbmddID0gbmV3UHJvcHMudmFsdWVzO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHByb3BzKTtcbiAgICB9LFxuXG4gICAgY2hhbmdlVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcztcbiAgICAgICAgaWYgKHR5cGUgPT09IEhJU1RPR1JBTSkge1xuICAgICAgICAgICAgLy8gU3dpdGNoaW5nIHRvIGhpc3RvZ3JhbSwgYWRkIGEgbGFiZWwgKDApIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gW1wiMFwiXS5jb25jYXQodGhpcy5wcm9wcy5jYXRlZ29yaWVzKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe3R5cGU6IHR5cGUsIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXN9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnR5cGUgPT09IEhJU1RPR1JBTSkge1xuICAgICAgICAgICAgLy8gU3dpdGNoaW5nIGZyb20gaGlzdG9ncmFtLCByZW1vdmUgYSBsYWJlbCBmcm9tIHRoZSBsZWZ0XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gdGhpcy5wcm9wcy5jYXRlZ29yaWVzLnNsaWNlKDEpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7dHlwZTogdHlwZSwgY2F0ZWdvcmllczogY2F0ZWdvcmllc30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7dHlwZTogdHlwZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcy5jYXRlZ29yaWVzLmdldERPTU5vZGUoKS52YWx1ZSA9IGNhdGVnb3JpZXMuam9pbihcIiwgXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNoYW5nZUxhYmVsOiBmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSBfLmNsb25lKHRoaXMucHJvcHMubGFiZWxzKTtcbiAgICAgICAgbGFiZWxzW2ldID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2xhYmVsczogbGFiZWxzfSk7XG4gICAgfSxcblxuICAgIGNoYW5nZVBpY1VybDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBPbmx5IGNvbnRpbnVlIG9uIGJsdXIgb3IgXCJlbnRlclwiXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwia2V5cHJlc3NcIiAmJiBlLmtleUNvZGUgIT09IDEzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtwaWNVcmw6IGUudGFyZ2V0LnZhbHVlfSk7XG4gICAgfSxcblxuICAgIGNoYW5nZUNhdGVnb3JpZXM6IGZ1bmN0aW9uKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgdmFyIG4gPSBjYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudHlwZSA9PT0gSElTVE9HUkFNKSB7XG4gICAgICAgICAgICAvLyBIaXN0b2dyYW1zIHdpdGggbiBsYWJlbHMvY2F0ZWdvcmllcyBoYXZlIG4gLSAxIGJ1Y2tldHNcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnByb3BzLnNjYWxlWTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMsXG4gICAgICAgICAgICBjb3JyZWN0OiBwYWRBcnJheSh0aGlzLnByb3BzLmNvcnJlY3QsIG4sIHZhbHVlKSxcbiAgICAgICAgICAgIHN0YXJ0aW5nOiBwYWRBcnJheSh0aGlzLnByb3BzLnN0YXJ0aW5nLCBuLCB2YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNoYW5nZVNjYWxlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBvbGRTY2FsZSA9IHRoaXMucHJvcHMuc2NhbGVZO1xuICAgICAgICB2YXIgbmV3U2NhbGUgPSArZS50YXJnZXQudmFsdWUgfHwgZWRpdG9yRGVmYXVsdHMuc2NhbGVZO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKiBuZXdTY2FsZSAvIG9sZFNjYWxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtYXhZID0gc2NhbGUodGhpcy5wcm9wcy5tYXhZKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIHNjYWxlWTogbmV3U2NhbGUsXG4gICAgICAgICAgICBtYXhZOiBtYXhZLFxuICAgICAgICAgICAgY29ycmVjdDogXy5tYXAodGhpcy5wcm9wcy5jb3JyZWN0LCBzY2FsZSksXG4gICAgICAgICAgICBzdGFydGluZzogXy5tYXAodGhpcy5wcm9wcy5zdGFydGluZywgc2NhbGUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVmcy5tYXhZLmdldERPTU5vZGUoKS52YWx1ZSA9IG1heFk7XG4gICAgfSxcblxuICAgIGNoYW5nZU1heDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIG1heFk6ICtlLnRhcmdldC52YWx1ZSB8fCBlZGl0b3JEZWZhdWx0cy5tYXhZXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VTbmFwczogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIHNuYXBzUGVyTGluZTogK2UudGFyZ2V0LnZhbHVlIHx8IGVkaXRvckRlZmF1bHRzLnNuYXBzUGVyTGluZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY2hhbmdlRWRpdGluZzogZnVuY3Rpb24oZWRpdGluZykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtlZGl0aW5nOiBlZGl0aW5nfSk7XG4gICAgfSxcblxuICAgIHNldENhdGVnb3JpZXNGcm9tU2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NhbGUgPSArdGhpcy5yZWZzW1wic2NhbGVYXCJdLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgdmFyIG1heCA9ICt0aGlzLnJlZnNbXCJtYXhYXCJdLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHNjYWxlKSAqIHNjYWxlO1xuXG4gICAgICAgIHZhciBjYXRlZ29yaWVzO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy50eXBlID09PSBISVNUT0dSQU0pIHtcbiAgICAgICAgICAgIC8vIFJhbmdlcyBmb3IgaGlzdG9ncmFtIGxhYmVscyBzaG91bGQgc3RhcnQgYXQgemVyb1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IF8ucmFuZ2UoMCwgbWF4ICsgc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSBfLnJhbmdlKHNjYWxlLCBtYXggKyBzY2FsZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlQ2F0ZWdvcmllcyhjYXRlZ29yaWVzKTtcblxuICAgICAgICB0aGlzLnJlZnMuY2F0ZWdvcmllcy5nZXRET01Ob2RlKCkudmFsdWUgPSBjYXRlZ29yaWVzLmpvaW4oXCIsIFwiKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICB2YXIganNvbiA9IF8ucGljayh0aGlzLnByb3BzLCBcImNvcnJlY3RcIiwgXCJzdGFydGluZ1wiLCBcInR5cGVcIiwgXCJsYWJlbHNcIixcbiAgICAgICAgICAgIFwiY2F0ZWdvcmllc1wiLCBcInNjYWxlWVwiLCBcIm1heFlcIiwgXCJzbmFwc1BlckxpbmVcIik7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMudHlwZSA9PT0gUElDKSB7XG4gICAgICAgICAgICBqc29uLnBpY1VybCA9IHRoaXMucHJvcHMucGljVXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufSk7XG5cbldpZGdldHMucmVnaXN0ZXIoXCJwbG90dGVyXCIsIFBsb3R0ZXIpO1xuV2lkZ2V0cy5yZWdpc3RlcihcInBsb3R0ZXItZWRpdG9yXCIsIFBsb3R0ZXJFZGl0b3IpO1xuXG59KShQZXJzZXVzKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG5cbnZhciBJbmZvVGlwID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvaW5mby10aXAuanN4XCIpO1xudmFyIFdpZGdldHMgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy5qc1wiKTtcblxudmFyIFByb3RyYWN0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdQcm90cmFjdG9yJyxcbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IDQ4MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgaW1hZ2VVcmw6IG51bGwsXG4gICAgICAgICAgICBpbWFnZVRvcDogMCxcbiAgICAgICAgICAgIGltYWdlTGVmdDogMCxcbiAgICAgICAgICAgIHByb3RyYWN0b3JYOiA3LjUsXG4gICAgICAgICAgICBwcm90cmFjdG9yWTogMC41XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLXdpZGdldCBwZXJzZXVzLXdpZGdldC1wcm90cmFjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6e3dpZHRoOiB0aGlzLnByb3BzLndpZHRoLCBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0fX0sIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmltYWdlVXJsICYmIFJlYWN0LkRPTS5pbWcoIHtzcmM6dGhpcy5wcm9wcy5pbWFnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOnt0b3A6IHRoaXMucHJvcHMuaW1hZ2VUb3AgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnByb3BzLmltYWdlTGVmdCArIFwicHhcIn19ICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJncmFwaGllXCIsIHJlZjpcImdyYXBoaWVEaXZcIn0gKVxuICAgICAgICAgICAgICAgICk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXR1cEdyYXBoaWUoKTtcbiAgICB9LFxuXG4gICAgc2V0dXBHcmFwaGllOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyYXBoaWVEaXYgPSB0aGlzLnJlZnMuZ3JhcGhpZURpdi5nZXRET01Ob2RlKCk7XG4gICAgICAgICQoZ3JhcGhpZURpdikuZW1wdHkoKTtcbiAgICAgICAgdmFyIGdyYXBoaWUgPSB0aGlzLmdyYXBoaWUgPSBLaGFuVXRpbC5jcmVhdGVHcmFwaGllKGdyYXBoaWVEaXYpO1xuXG4gICAgICAgIGdyYXBoaWUuaW5pdCh7XG4gICAgICAgICAgICByYW5nZTogW1swLCB0aGlzLnByb3BzLndpZHRoIC8gNDBdLCBbMCwgdGhpcy5wcm9wcy5oZWlnaHQgLyA0MF1dXG4gICAgICAgIH0pO1xuICAgICAgICBncmFwaGllLmFkZE1vdXNlTGF5ZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5wcm90cmFjdG9yID0gZ3JhcGhpZS5wcm90cmFjdG9yKFtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnByb3RyYWN0b3JYLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucHJvdHJhY3RvclldKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5zdGF0ZS5wcm90cmFjdG9yLmNlbnRlclBvaW50LmNvb3JkLFxuICAgICAgICAgICAgYW5nbGU6IHRoaXMuc3RhdGUucHJvdHJhY3Rvci5yb3RhdGlvblxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzaW1wbGVWYWxpZGF0ZTogZnVuY3Rpb24ocnVicmljKSB7XG4gICAgICAgIHJldHVybiBQcm90cmFjdG9yLnZhbGlkYXRlKHRoaXMudG9KU09OKCksIHJ1YnJpYyk7XG4gICAgfSxcblxuICAgIGZvY3VzOiAkLm5vb3Bcbn0pO1xuXG5cbl8uZXh0ZW5kKFByb3RyYWN0b3IsIHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24oc3RhdGUsIHJ1YnJpYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgIGVhcm5lZDogMSxcbiAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5cbnZhciBQcm90cmFjdG9yRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnUHJvdHJhY3RvckVkaXRvcicsXG4gICAgY2xhc3NOYW1lOiBcInBlcnNldXMtd2lkZ2V0LXByb3RyYWN0b3JcIixcblxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZVVybDogbnVsbCxcbiAgICAgICAgICAgIGltYWdlVG9wOiAwLFxuICAgICAgICAgICAgaW1hZ2VMZWZ0OiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwicGVyc2V1cy13aWRnZXQtcHJvdHJhY3RvclwifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFwiSW1hZ2UgZGlzcGxheWVkIHVuZGVyIHByb3RyYWN0b3I6XCIpLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcIlVSTDogXCIsXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTpcInBlcnNldXMtd2lkZ2V0LXByb3RyYWN0b3ItdXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6XCJpbWFnZS11cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTp0aGlzLnByb3BzLmltYWdlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlQcmVzczp0aGlzLmNoYW5nZUltYWdlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25CbHVyOnRoaXMuY2hhbmdlSW1hZ2VVcmx9ICksXG4gICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiQ3JlYXRlIGFuIGltYWdlIGluIGdyYXBoaWUsIG9yIHVzZSB0aGUgXFxcIkFkZCBpbWFnZVxcXCIgZnVuY3Rpb24gXCIrXG4gICAgICAgICAgICAgICAgXCJ0byBjcmVhdGUgYSBiYWNrZ3JvdW5kLlwiKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuaW1hZ2VVcmwgJiYgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFwiUGl4ZWxzIGZyb20gdG9wOiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmltYWdlVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ6XG4gICAgICAgICAgICAgICAgICAgIF8ucGFydGlhbCh0aGlzLmNoYW5nZVNldHRpbmcsIFwiaW1hZ2VUb3BcIil9IClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXCJQaXhlbHMgZnJvbSBsZWZ0OiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KCB7dHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmltYWdlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0OlxuICAgICAgICAgICAgICAgICAgICBfLnBhcnRpYWwodGhpcy5jaGFuZ2VTZXR0aW5nLCBcImltYWdlTGVmdFwiKX0gKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgY2hhbmdlSW1hZ2VVcmw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gT25seSBjb250aW51ZSBvbiBibHVyIG9yIFwiZW50ZXJcIlxuICAgICAgICBpZiAoZS50eXBlID09PSBcImtleXByZXNzXCIgJiYgZS5rZXlDb2RlICE9PSAxMykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICBpbWFnZVVybDogdGhpcy5yZWZzW1wiaW1hZ2UtdXJsXCJdLmdldERPTU5vZGUoKS52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY2hhbmdlU2V0dGluZzogZnVuY3Rpb24odHlwZSwgZSkge1xuICAgICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgbmV3UHJvcHNbdHlwZV0gPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShuZXdQcm9wcyk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBqc29uID0ge1xuICAgICAgICAgICAgaW1hZ2VVcmw6IHRoaXMucHJvcHMuaW1hZ2VVcmwsXG4gICAgICAgICAgICBpbWFnZVRvcDogdGhpcy5wcm9wcy5pbWFnZVRvcCxcbiAgICAgICAgICAgIGltYWdlTGVmdDogdGhpcy5wcm9wcy5pbWFnZUxlZnRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufSk7XG5cbldpZGdldHMucmVnaXN0ZXIoXCJwcm90cmFjdG9yXCIsIFByb3RyYWN0b3IpO1xuV2lkZ2V0cy5yZWdpc3RlcihcInByb3RyYWN0b3ItZWRpdG9yXCIsIFByb3RyYWN0b3JFZGl0b3IpO1xuXG59KShQZXJzZXVzKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xucmVxdWlyZShcIi4uL3JlbmRlcmVyLmpzeFwiKTtcbnJlcXVpcmUoXCIuLi9lZGl0b3IuanN4XCIpO1xuXG52YXIgSW5mb1RpcCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2luZm8tdGlwLmpzeFwiKTtcbnZhciBXaWRnZXRzID0gcmVxdWlyZShcIi4uL3dpZGdldHMuanNcIik7XG5cbnZhciBzaHVmZmxlID0gVXRpbC5zaHVmZmxlO1xuXG52YXIgQmFzZVJhZGlvID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnQmFzZVJhZGlvJyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFkaW9Hcm91cE5hbWUgPSBfLnVuaXF1ZUlkKFwicGVyc2V1c19yYWRpb19cIik7XG4gICAgICAgIHZhciBpbnB1dFR5cGUgPSB0aGlzLnByb3BzLm11bHRpcGxlU2VsZWN0ID8gXCJjaGVja2JveFwiIDogXCJyYWRpb1wiO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00udWwoIHtjbGFzc05hbWU6XCJwZXJzZXVzLXdpZGdldC1yYWRpb1wifSwgXG4gICAgICAgICAgICB0aGlzLnByb3BzLm11bHRpcGxlU2VsZWN0ICYmXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImluc3RydWN0aW9uc1wifSwgXG4gICAgICAgICAgICAgICAgICAgICRfKG51bGwsIFwiU2VsZWN0IGFsbCB0aGF0IGFwcGx5LlwiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSwgaSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJyYWRpb1wiICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOmlucHV0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOnJhZGlvR3JvdXBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6Y2hvaWNlLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMsIGkpfSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmxhYmVsV3JhcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmxpKG51bGwsIFJlYWN0LkRPTS5sYWJlbChudWxsLCBjb250ZW50KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5saShudWxsLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihyYWRpb0luZGV4LCBlKSB7XG4gICAgICAgIHZhciBuZXdDaGVja2VkID0gXy5tYXAodGhpcy5wcm9wcy5jaG9pY2VzLCBmdW5jdGlvbihjaG9pY2UsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnNbXCJyYWRpb1wiICsgaV0uZ2V0RE9NTm9kZSgpLmNoZWNrZWQ7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25DaGVja2VkQ2hhbmdlKG5ld0NoZWNrZWQpO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24oaSkge1xuICAgICAgICB0aGlzLnJlZnNbXCJyYWRpb1wiICsgKGkgfHwgMCldLmdldERPTU5vZGUoKS5mb2N1cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxudmFyIFJhZGlvID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnUmFkaW8nLFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaG9pY2VzOiBbe31dLFxuICAgICAgICAgICAgcmFuZG9taXplOiBmYWxzZSxcbiAgICAgICAgICAgIG11bHRpcGxlU2VsZWN0OiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5wcm9wcy52YWx1ZXMgfHwgXy5tYXAodGhpcy5wcm9wcy5jaG9pY2VzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY2hvaWNlcyA9IHRoaXMucHJvcHMuY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBhIGNvcHksIHdoaWNoIF8ucGljayBkb2VzXG4gICAgICAgICAgICAgICAgY29udGVudDogUGVyc2V1cy5SZW5kZXJlcihfLnBpY2soY2hvaWNlLCBcImNvbnRlbnRcIikpLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4OiBpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY2hvaWNlcyA9IHRoaXMucmFuZG9taXplKGNob2ljZXMpO1xuXG4gICAgICAgIHJldHVybiBCYXNlUmFkaW8oXG4gICAgICAgICAgICB7cmVmOlwiYmFzZVJhZGlvXCIsXG4gICAgICAgICAgICBsYWJlbFdyYXA6dHJ1ZSxcbiAgICAgICAgICAgIG11bHRpcGxlU2VsZWN0OnRoaXMucHJvcHMubXVsdGlwbGVTZWxlY3QsXG4gICAgICAgICAgICBjaG9pY2VzOmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLnBpY2soY2hvaWNlLCBcImNvbnRlbnRcIiwgXCJjaGVja2VkXCIpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U6dGhpcy5vbkNoZWNrZWRDaGFuZ2V9ICk7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMuYmFzZVJhZGlvLmZvY3VzKGkpO1xuICAgIH0sXG5cbiAgICBvbkNoZWNrZWRDaGFuZ2U6IGZ1bmN0aW9uKGNoZWNrZWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMuZGVyYW5kb21pemUoY2hlY2tlZClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgLy8gUmV0dXJuIGNoZWNrZWQgaW5wdXRzIGluIHRoZSBmb3JtIHt2YWx1ZXM6IFtib29sXX0uIChEZWFyIGZ1dHVyZVxuICAgICAgICAvLyB0aW1lbGluZSBpbXBsZW1lbnRlcnM6IHRoaXMgdXNlZCB0byBiZSB7dmFsdWU6IGl9IGJlZm9yZSBtdWx0aXBsZVxuICAgICAgICAvLyBzZWxlY3Qgd2FzIGFkZGVkKVxuICAgICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfLnBpY2sodGhpcy5wcm9wcywgXCJ2YWx1ZXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGNoZWNrZWRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBfLm1hcCh0aGlzLnByb3BzLmNob2ljZXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2ltcGxlVmFsaWRhdGU6IGZ1bmN0aW9uKHJ1YnJpYykge1xuICAgICAgICByZXR1cm4gUmFkaW8udmFsaWRhdGUodGhpcy50b0pTT04oKSwgcnVicmljKTtcbiAgICB9LFxuXG4gICAgcmFuZG9taXplOiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yYW5kb21pemUgJiYgdGhpcy5wcm9wcy5wcm9ibGVtTnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc2h1ZmZsZShhcnJheSwgdGhpcy5wcm9wcy5wcm9ibGVtTnVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXJhbmRvbWl6ZTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmFuZG9taXplICYmIHRoaXMucHJvcHMucHJvYmxlbU51bSkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IHNodWZmbGUoXy5yYW5nZShhcnJheS5sZW5ndGgpLCB0aGlzLnByb3BzLnByb2JsZW1OdW0pO1xuICAgICAgICAgICAgdmFyIGRlcmFuZG9taXplZCA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuICAgICAgICAgICAgXy5lYWNoKG1hcCwgZnVuY3Rpb24oc2h1ZmZsZWRJbmRleCwgb3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgIGRlcmFuZG9taXplZFtzaHVmZmxlZEluZGV4XSA9IGFycmF5W29yaWdpbmFsSW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGVyYW5kb21pemVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbl8uZXh0ZW5kKFJhZGlvLCB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHN0YXRlLCBydWJyaWMpIHtcbiAgICAgICAgaWYgKCFfLmFueShzdGF0ZS52YWx1ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTggKi9cbiAgICAgICAgICAgIHZhciBjb3JyZWN0ID0gXy5hbGwoc3RhdGUudmFsdWVzLCBmdW5jdGlvbihzZWxlY3RlZCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXJ1YnJpYy5jaG9pY2VzW2ldLmNvcnJlY3QgPT09IHNlbGVjdGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBqc2hpbnQgK1cwMTggKi9cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgIGVhcm5lZDogY29ycmVjdCA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFJhZGlvRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnUmFkaW9FZGl0b3InLFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaG9pY2VzOiBbe31dLFxuICAgICAgICAgICAgcmFuZG9taXplOiBmYWxzZSxcbiAgICAgICAgICAgIG11bHRpcGxlU2VsZWN0OiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgIEJhc2VSYWRpbyhcbiAgICAgICAgICAgICAgICB7cmVmOlwiYmFzZVJhZGlvXCIsXG4gICAgICAgICAgICAgICAgbXVsdGlwbGVTZWxlY3Q6dGhpcy5wcm9wcy5tdWx0aXBsZVNlbGVjdCxcbiAgICAgICAgICAgICAgICBsYWJlbFdyYXA6ZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hvaWNlczp0aGlzLnByb3BzLmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRpdG9yID0gUGVyc2V1cy5FZGl0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBcImVkaXRvclwiICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNob2ljZS5jb250ZW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXRFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImNvbnRlbnRcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29udGVudENoYW5nZShpLCBuZXdQcm9wcy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVMaW5rID0gUmVhY3QuRE9NLmEoIHtocmVmOlwiI1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTpcInNpbXBsZS1idXR0b24gb3JhbmdlIGRlbGV0ZS1jaG9pY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTpcIlJlbW92ZSB0aGlzIGNob2ljZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy5vbkRlbGV0ZS5iaW5kKHRoaXMsIGkpfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uc3Bhbigge2NsYXNzTmFtZTpcImljb24tdHJhc2hcIn0gKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImNob2ljZS1lZGl0b3JcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNob2ljZXMubGVuZ3RoID49IDIgJiYgZGVsZXRlTGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGNob2ljZS5jb3JyZWN0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlOnRoaXMub25DaGVja2VkQ2hhbmdlfSApLFxuXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwiYWRkLWNob2ljZS1jb250YWluZXJcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5hKCB7aHJlZjpcIiNcIiwgY2xhc3NOYW1lOlwic2ltcGxlLWJ1dHRvbiBvcmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy5hZGRDaG9pY2V9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJpY29uLXBsdXNcIn0gKSxcbiAgICAgICAgICAgICAgICAgICAgXCIgQWRkIGEgY2hvaWNlIFwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICB7dHlwZTpcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6dGhpcy5wcm9wcy5yYW5kb21pemUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe3JhbmRvbWl6ZTogZS50YXJnZXQuY2hlY2tlZH0pO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyl9ICksXG4gICAgICAgICAgICAgICAgXCIgUmFuZG9taXplIGFuc3dlciBvcmRlciBcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJGb3IgdGhpcyBvcHRpb24gdG8gd29yaywgZG9u4oCZdCBsYWJlbCBjaG9pY2VzIG9yIGhhdmUgXFxcIk5vbmUgXCIrXG4gICAgICAgICAgICAgICAgXCJvZiB0aGUgYWJvdmVcXFwiIGFzIGFuIG9wdGlvbi4gRm9yIHRydWUvZmFsc2UgcXVlc3Rpb25zLCBtYWtlIHRoZSBcIitcbiAgICAgICAgICAgICAgICBcImZpcnN0IGNob2ljZSBUcnVlIGFuZCB0aGUgc2Vjb25kIGNob2ljZSBGYWxzZSwgYW5kIGRvIE5PVCBcIitcbiAgICAgICAgICAgICAgICBcInNlbGVjdCByYW5kb21pemUgYW5zd2VyIG9yZGVyLlwiKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICB7dHlwZTpcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6dGhpcy5wcm9wcy5tdWx0aXBsZVNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5vbk11bHRpcGxlU2VsZWN0Q2hhbmdlfSApLFxuICAgICAgICAgICAgICAgIFwiIEFsbG93IG11bHRpcGxlIHNlbGVjdGlvbnMgXCJcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uTXVsdGlwbGVTZWxlY3RDaGFuZ2U6IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICB2YXIgYWxsb3dNdWx0aXBsZSA9IGUudGFyZ2V0LmNoZWNrZWQ7XG5cbiAgICAgICAgdmFyIG51bVNlbGVjdGVkID0gXy5yZWR1Y2UodGhpcy5wcm9wcy5jaG9pY2VzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKG1lbW8sIGNob2ljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNob2ljZS5jb3JyZWN0ID8gbWVtbyArIDEgOiBtZW1vO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBpZiAoIWFsbG93TXVsdGlwbGUgJiYgbnVtU2VsZWN0ZWQgPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2hvaWNlcyA9IF8ubWFwKHRoaXMucHJvcHMuY2hvaWNlcywgZnVuY3Rpb24oY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sIGNob2ljZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIG11bHRpcGxlU2VsZWN0OiBhbGxvd011bHRpcGxlLFxuICAgICAgICAgICAgICAgIGNob2ljZXM6IGNob2ljZXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsZVNlbGVjdDogYWxsb3dNdWx0aXBsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25DaGVja2VkQ2hhbmdlOiBmdW5jdGlvbihjaGVja2VkKSB7XG4gICAgICAgIHZhciBjaG9pY2VzID0gXy5tYXAodGhpcy5wcm9wcy5jaG9pY2VzLCBmdW5jdGlvbihjaG9pY2UsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgY2hvaWNlLCB7Y29ycmVjdDogY2hlY2tlZFtpXX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Y2hvaWNlczogY2hvaWNlc30pO1xuICAgIH0sXG5cbiAgICBvbkNvbnRlbnRDaGFuZ2U6IGZ1bmN0aW9uKGNob2ljZUluZGV4LCBuZXdDb250ZW50LCBlKSB7XG4gICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5wcm9wcy5jaG9pY2VzLnNsaWNlKCk7XG4gICAgICAgIGNob2ljZXNbY2hvaWNlSW5kZXhdID0gXy5leHRlbmQoe30sIGNob2ljZXNbY2hvaWNlSW5kZXhdLCB7XG4gICAgICAgICAgICBjb250ZW50OiBuZXdDb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtjaG9pY2VzOiBjaG9pY2VzfSk7XG4gICAgfSxcblxuICAgIG9uRGVsZXRlOiBmdW5jdGlvbihjaG9pY2VJbmRleCwgZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5wcm9wcy5jaG9pY2VzLnNsaWNlKCk7XG4gICAgICAgIGNob2ljZXMuc3BsaWNlKGNob2ljZUluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7Y2hvaWNlczogY2hvaWNlc30pO1xuICAgIH0sXG5cbiAgICBhZGRDaG9pY2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBjaG9pY2VzID0gdGhpcy5wcm9wcy5jaG9pY2VzO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtjaG9pY2VzOiBjaG9pY2VzLmNvbmNhdChbe31dKX0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZWZzW1wiZWRpdG9yXCIgKyBjaG9pY2VzLmxlbmd0aF0uZm9jdXMoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnMuZWRpdG9yMC5mb2N1cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uICYmXG4gICAgICAgICAgICAgICAgIV8uc29tZShfLnBsdWNrKHRoaXMucHJvcHMuY2hvaWNlcywgXCJjb3JyZWN0XCIpKSkge1xuICAgICAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBObyBjaG9pY2UgaXMgbWFya2VkIGFzIGNvcnJlY3QuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF8ucGljayh0aGlzLnByb3BzLCBcImNob2ljZXNcIiwgXCJyYW5kb21pemVcIiwgXCJtdWx0aXBsZVNlbGVjdFwiKTtcbiAgICB9XG59KTtcblxuV2lkZ2V0cy5yZWdpc3RlcihcInJhZGlvXCIsIFJhZGlvKTtcbldpZGdldHMucmVnaXN0ZXIoXCJyYWRpby1lZGl0b3JcIiwgUmFkaW9FZGl0b3IpO1xuXG59KShQZXJzZXVzKTtcbiIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuKGZ1bmN0aW9uKFBlcnNldXMpIHtcblxucmVxdWlyZShcIi4uL2NvcmUuanNcIik7XG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xuXG52YXIgc2h1ZmZsZSA9IFV0aWwuc2h1ZmZsZTtcblxudmFyIEluZm9UaXAgICAgICAgID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvaW5mby10aXAuanN4XCIpO1xudmFyIFByb3BDaGVja0JveCAgID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvcHJvcC1jaGVjay1ib3guanN4XCIpO1xudmFyIFNvcnRhYmxlICAgICAgID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvc29ydGFibGUuanN4XCIpO1xudmFyIFRleHRMaXN0RWRpdG9yID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvdGV4dC1saXN0LWVkaXRvci5qc3hcIik7XG52YXIgV2lkZ2V0cyAgICAgICAgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy5qc1wiKTtcblxudmFyIEhPUklaT05UQUwgPSBcImhvcml6b250YWxcIixcbiAgICBWRVJUSUNBTCA9IFwidmVydGljYWxcIjtcblxudmFyIFNvcnRlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1NvcnRlcicsXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvcnJlY3Q6IFJlYWN0LlByb3BUeXBlcy5hcnJheSxcbiAgICAgICAgbGF5b3V0OiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoW0hPUklaT05UQUwsIFZFUlRJQ0FMXSksXG4gICAgICAgIHBhZGRpbmc6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgICAgICBwcm9ibGVtTnVtOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgfSxcblxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb3JyZWN0OiBbXSxcbiAgICAgICAgICAgIGxheW91dDogSE9SSVpPTlRBTCxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICBwcm9ibGVtTnVtOiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gc2h1ZmZsZShcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY29ycmVjdCxcbiAgICAgICAgICAgIHRoaXMucHJvcHMucHJvYmxlbU51bSxcbiAgICAgICAgICAgIC8qIGVuc3VyZVBlcm11dGVkICovIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInBlcnNldXMtd2lkZ2V0LXNvcnRlciB1aS1oZWxwZXItY2xlYXJmaXhcIn0sIFxuICAgICAgICAgICAgU29ydGFibGUoXG4gICAgICAgICAgICAgICAge29wdGlvbnM6b3B0aW9ucyxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6dGhpcy5wcm9wcy5sYXlvdXQsXG4gICAgICAgICAgICAgICAgcGFkZGluZzp0aGlzLnByb3BzLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmVmOlwic29ydGFibGVcIn0gKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7b3B0aW9uczogdGhpcy5yZWZzLnNvcnRhYmxlLmdldE9wdGlvbnMoKX07XG4gICAgfSxcblxuICAgIHNpbXBsZVZhbGlkYXRlOiBmdW5jdGlvbihydWJyaWMpIHtcbiAgICAgICAgcmV0dXJuIFNvcnRlci52YWxpZGF0ZSh0aGlzLnRvSlNPTigpLCBydWJyaWMpO1xuICAgIH0sXG59KTtcblxuXG5fLmV4dGVuZChTb3J0ZXIsIHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24oc3RhdGUsIHJ1YnJpYykge1xuICAgICAgICB2YXIgY29ycmVjdCA9IF8uaXNFcXVhbChzdGF0ZS5vcHRpb25zLCBydWJyaWMuY29ycmVjdCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICBlYXJuZWQ6IGNvcnJlY3QgPyAxIDogMCxcbiAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5cbnZhciBTb3J0ZXJFZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdTb3J0ZXJFZGl0b3InLFxuICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb3JyZWN0OiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgICAgIGxheW91dDogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKFtIT1JJWk9OVEFMLCBWRVJUSUNBTF0pLFxuICAgICAgICBwYWRkaW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29ycmVjdDogW1wiJHgkXCIsIFwiJHkkXCIsIFwiJHokXCJdLFxuICAgICAgICAgICAgbGF5b3V0OiBIT1JJWk9OVEFMLFxuICAgICAgICAgICAgcGFkZGluZzogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcztcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgXCIgQ29ycmVjdCBhbnN3ZXI6IFwiLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgUmVhY3QuRE9NLnAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIEVudGVyIHRoZSBjb3JyZWN0IGFuc3dlciAoaW4gdGhlIGNvcnJlY3Qgb3JkZXIpIGhlcmUuIFRoZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJwcmV2aWV3IG9uIHRoZSByaWdodCB3aWxsIGhhdmUgdGhlIGNhcmRzIGluIGEgcmFuZG9taXplZCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJvcmRlciwgd2hpY2ggaXMgaG93IHRoZSBzdHVkZW50IHdpbGwgc2VlIHRoZW0uIFwiXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBUZXh0TGlzdEVkaXRvcihcbiAgICAgICAgICAgICAgICB7b3B0aW9uczp0aGlzLnByb3BzLmNvcnJlY3QsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6ZnVuY3Rpb24ob3B0aW9ucywgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnByb3BzLm9uQ2hhbmdlKHtjb3JyZWN0OiBvcHRpb25zfSwgY2IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5b3V0OnRoaXMucHJvcHMubGF5b3V0fSApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIExheW91dDogXCIsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoIHt2YWx1ZTp0aGlzLnByb3BzLmxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLm9uTGF5b3V0Q2hhbmdlfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6SE9SSVpPTlRBTH0sIFwiSG9yaXpvbnRhbFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpWRVJUSUNBTH0sIFwiVmVydGljYWxcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXCJVc2UgdGhlIGhvcml6b250YWwgbGF5b3V0IGZvciBzaG9ydCB0ZXh0IGFuZCBzbWFsbCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJpbWFnZXMuIFRoZSB2ZXJ0aWNhbCBsYXlvdXQgaXMgYmVzdCBmb3IgbG9uZ2VyIHRleHQgYW5kIFwiK1xuICAgICAgICAgICAgICAgICAgICBcImxhcmdlciBpbWFnZXMuXCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgUHJvcENoZWNrQm94KFxuICAgICAgICAgICAgICAgICAgICB7bGFiZWw6XCJQYWRkaW5nOlwiLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOnRoaXMucHJvcHMucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ucChudWxsLCBcIlBhZGRpbmcgaXMgZ29vZCBmb3IgdGV4dCwgYnV0IG5vdCBuZWVkZWQgZm9yIGltYWdlcy5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIG9uTGF5b3V0Q2hhbmdlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe2xheW91dDogZS50YXJnZXQudmFsdWV9KTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihza2lwVmFsaWRhdGlvbikge1xuICAgICAgICByZXR1cm4gXy5waWNrKHRoaXMucHJvcHMsIFwiY29ycmVjdFwiLCBcImxheW91dFwiLCBcInBhZGRpbmdcIik7XG4gICAgfVxufSk7XG5cbldpZGdldHMucmVnaXN0ZXIoXCJzb3J0ZXJcIiwgU29ydGVyKTtcbldpZGdldHMucmVnaXN0ZXIoXCJzb3J0ZXItZWRpdG9yXCIsIFNvcnRlckVkaXRvcik7XG5cbn0pKFBlcnNldXMpO1xuIiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG4oZnVuY3Rpb24oUGVyc2V1cykge1xuXG5yZXF1aXJlKFwiLi4vY29yZS5qc1wiKTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XG5yZXF1aXJlKFwiLi4vZWRpdG9yLmpzeFwiKTtcbnJlcXVpcmUoXCIuLi9yZW5kZXJlci5qc3hcIik7XG52YXIgSW5mb1RpcCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2luZm8tdGlwLmpzeFwiKTtcblxudmFyIFdpZGdldHMgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy5qc1wiKTtcbnZhciBFZGl0b3IgID0gUGVyc2V1cy5FZGl0b3I7XG5cblxudmFyIFRhYmxlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnVGFibGUnLFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5wcm9wcy5oZWFkZXJzO1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLnRhYmxlKCB7Y2xhc3NOYW1lOlwicGVyc2V1cy13aWRnZXQtdGFibGUtb2YtdmFsdWVzIG5vbi1tYXJrZG93blwifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00udGhlYWQobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnRyKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBfLm1hcChoZWFkZXJzLCBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00udGgobnVsbCwgUGVyc2V1cy5SZW5kZXJlcih7Y29udGVudDogaGVhZGVyfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00udGJvZHkobnVsbCwgXG4gICAgICAgICAgICAgICAgXyh0aGlzLnByb3BzLnJvd3MpLnRpbWVzKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS50cihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIF8odGhpcy5wcm9wcy5jb2x1bW5zKS50aW1lcyhmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS50ZChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcImFuc3dlclwiICsgciArIFwiLFwiICsgYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6XCJ0ZXh0XCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gXy5tYXAoc2VsZi5wcm9wcy5hbnN3ZXJzLCBmdW5jdGlvbihhbnN3ZXIsIHIpIHtcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChzZWxmLnByb3BzLmhlYWRlcnMsIGZ1bmN0aW9uKGhlYWRlciwgYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJlZnNbXCJhbnN3ZXJcIiArIHIgKyBcIixcIiArIGNdLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2ltcGxlVmFsaWRhdGU6IGZ1bmN0aW9uKHJ1YnJpYykge1xuICAgICAgICByZXR1cm4gVGFibGUudmFsaWRhdGUodGhpcy50b0pTT04oKSwgcnVicmljKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnNbXCJhbnN3ZXIwLDBcIl0uZ2V0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG5fLmV4dGVuZChUYWJsZSwge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbihzdGF0ZSwgcnVicmljKSB7XG4gICAgICAgIHZhciBmaWx0ZXJOb25FbXB0eSA9IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZmlsdGVyKHRhYmxlLCBmdW5jdGlvbiAocm93KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiByb3cgaGFzIGEgY2VsbCB0aGF0IGlzIG5vbmVtcHR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc29tZShyb3csIF8uaWRlbnRpdHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzb2x1dGlvbiA9IGZpbHRlck5vbkVtcHR5KHJ1YnJpYy5hbnN3ZXJzKTtcbiAgICAgICAgdmFyIHN1cHBsaWVkID0gZmlsdGVyTm9uRW1wdHkoc3RhdGUpO1xuICAgICAgICB2YXIgaGFzRW1wdHlDZWxsID0gXy5zb21lKHN1cHBsaWVkLCBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBfLnNvbWUocm93LCBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwgPT09IFwiXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNFbXB0eUNlbGwgfHwgIXN1cHBsaWVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBwbGllZC5sZW5ndGggIT09IHNvbHV0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50c1wiLFxuICAgICAgICAgICAgICAgIGVhcm5lZDogMCxcbiAgICAgICAgICAgICAgICB0b3RhbDogMSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcmVhdGVWYWxpZGF0b3IgPSBLaGFuLmFuc3dlclR5cGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm51bWJlci5jcmVhdGVWYWxpZGF0b3JGdW5jdGlvbmFsO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHZhciBhbGxDb3JyZWN0ID0gXy5ldmVyeShzb2x1dGlvbiwgZnVuY3Rpb24gKHJvd1NvbHV0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdXBwbGllZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByb3dTdXBwbGllZCA9IHN1cHBsaWVkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ID0gXy5ldmVyeShyb3dTdXBwbGllZCwgZnVuY3Rpb24gKGNlbGxTdXBwbGllZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbFNvbHV0aW9uID0gcm93U29sdXRpb25baV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBjcmVhdGVWYWxpZGF0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFNvbHV0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWZ5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWxpZGF0b3IoY2VsbFN1cHBsaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3JyZWN0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsaWVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICBlYXJuZWQ6IGFsbENvcnJlY3QgPyAxIDogMCxcbiAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG52YXIgVGFibGVFZGl0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdUYWJsZUVkaXRvcicsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRSb3dzID0gNDtcbiAgICAgICAgdmFyIGRlZmF1bHRDb2x1bW5zID0gMTtcbiAgICAgICAgdmFyIGJsYW5rQW5zd2VycyA9IF8oZGVmYXVsdFJvd3MpLnRpbWVzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwuc3RyaW5nQXJyYXlPZlNpemUoZGVmYXVsdENvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IFtcIlwiXSxcbiAgICAgICAgICAgIHJvd3M6IGRlZmF1bHRSb3dzLFxuICAgICAgICAgICAgY29sdW1uczogZGVmYXVsdENvbHVtbnMsXG4gICAgICAgICAgICBudW1SYXdSb3dzOiBkZWZhdWx0Um93cyxcbiAgICAgICAgICAgIG51bVJhd0NvbHVtbnM6IGRlZmF1bHRDb2x1bW5zLFxuICAgICAgICAgICAgYW5zd2VyczogYmxhbmtBbnN3ZXJzLFxuICAgICAgICAgICAgdHlwZTogXCJzZXRcIlxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVmcy5udW1iZXJPZkNvbHVtbnMuZ2V0RE9NTm9kZSgpLmZvY3VzKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLnByb3BzLnJvd3M7XG4gICAgICAgIHZhciBjb2xzID0gdGhpcy5wcm9wcy5jb2x1bW5zO1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBOdW1iZXIgb2YgY29sdW1uczogXCIsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJudW1iZXJPZkNvbHVtbnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6XCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLm51bVJhd0NvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbklucHV0OnRoaXMub25TaXplSW5wdXR9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIE51bWJlciBvZiByb3dzOiBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcIm51bWJlck9mUm93c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMucHJvcHMubnVtUmF3Um93cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ6dGhpcy5vblNpemVJbnB1dH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFwiIFRhYmxlIG9mIGFuc3dlcnMgdHlwZTogXCIsXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnVsKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGkobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmlucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTpcInJhZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6XCJjaGVja2VkXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBTZXQgb2YgdmFsdWVzIChjb21wbGV0ZSkgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFwiVGhlIHN0dWRlbnQgaGFzIHRvIGZpbGwgb3V0IGFsbCBjZWxscyBpbiB0aGUgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YWJsZS4gIEZvciBwYXJ0aWFsbHkgZmlsbGVkIHRhYmxlcyBjcmVhdGUgYSB0YWJsZSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVzaW5nIHRoZSB0ZW1wbGF0ZSwgYW5kIGluc2VydCB0ZXh0IGlucHV0IGJveGVzIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXMgZGVzaXJlZC5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS50YWJsZSgge2NsYXNzTmFtZTpcInBlcnNldXMtd2lkZ2V0LXRhYmxlLW9mLXZhbHVlcyBub24tbWFya2Rvd25cIn0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00udGhlYWQobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00udHIobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXyhjb2xzKS50aW1lcyhmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00udGgobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcImNvbHVtbkhlYWRlclwiICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OnNlbGYucHJvcHMuaGVhZGVyc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXRFbmFibGVkOmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uSGVhZGVyQ2hhbmdlLmJpbmQoc2VsZiwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnRib2R5KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgXyhyb3dzKS50aW1lcyhmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS50cihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXyhjb2xzKS50aW1lcyhmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLnRkKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5pbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcImFuc3dlclwiICsgciArIFwiLFwiICsgYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTpcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25JbnB1dDpzZWxmLm9uQW5zd2VySW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnNlbGYucHJvcHMuYW5zd2Vyc1tyXVtjXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBvbkhlYWRlckNoYW5nZTogZnVuY3Rpb24oaW5kZXgsIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChfLmhhcyhuZXdQcm9wcywgXCJjb250ZW50XCIpKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMucHJvcHMuaGVhZGVycy5zbGljZSgpO1xuICAgICAgICAgICAgaGVhZGVyc1tpbmRleF0gPSBuZXdQcm9wcy5jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7aGVhZGVyczogaGVhZGVyc30pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uU2l6ZUlucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bVJhd1Jvd3MgPSB0aGlzLnJlZnMubnVtYmVyT2ZSb3dzLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgdmFyIG51bVJhd0NvbHMgPSB0aGlzLnJlZnMubnVtYmVyT2ZDb2x1bW5zLmdldERPTU5vZGUoKS52YWx1ZTtcbiAgICAgICAgdmFyIHJvd3MgPSArbnVtUmF3Um93cyB8fCAwO1xuICAgICAgICB2YXIgY29scyA9ICtudW1SYXdDb2xzIHx8IDA7XG4gICAgICAgIHJvd3MgPSBNYXRoLm1pbihNYXRoLm1heCgxLCByb3dzKSwgMzApO1xuICAgICAgICBjb2xzID0gTWF0aC5taW4oTWF0aC5tYXgoMSwgY29scyksIDYpO1xuICAgICAgICB2YXIgb2xkQ29sdW1ucyA9IHRoaXMucHJvcHMuY29sdW1ucztcbiAgICAgICAgdmFyIG9sZFJvd3MgPSB0aGlzLnByb3BzLnJvd3M7XG5cbiAgICAgICAgdmFyIGFuc3dlcnMgPSB0aGlzLnByb3BzLmFuc3dlcnM7XG4gICAgICAgIGlmIChvbGRSb3dzIDwgcm93cykge1xuICAgICAgICAgICAgXyhyb3dzIC0gb2xkUm93cykudGltZXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYW5zd2Vycy5wdXNoKFV0aWwuc3RyaW5nQXJyYXlPZlNpemUob2xkQ29sdW1ucykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMucHJvcHMuaGVhZGVycztcblxuICAgICAgICBmdW5jdGlvbiBmaXhDb2x1bW5TaXppbmcoYXJyYXkpIHtcbiAgICAgICAgICAgIF8oY29scyAtIG9sZENvbHVtbnMpLnRpbWVzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRDb2x1bW5zIDwgY29scykge1xuICAgICAgICAgICAgZml4Q29sdW1uU2l6aW5nKGhlYWRlcnMpO1xuICAgICAgICAgICAgXy5lYWNoKGFuc3dlcnMsIGZpeENvbHVtblNpemluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIHJvd3M6IHJvd3MsXG4gICAgICAgICAgICBjb2x1bW5zOiBjb2xzLFxuICAgICAgICAgICAgbnVtUmF3Um93czogbnVtUmF3Um93cyxcbiAgICAgICAgICAgIG51bVJhd0NvbHVtbnM6IG51bVJhd0NvbHMsXG4gICAgICAgICAgICBhbnN3ZXJzOiBhbnN3ZXJzLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25BbnN3ZXJJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFuc3dlcnMgPSBfKHNlbGYucHJvcHMucm93cykudGltZXMoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgcmV0dXJuIF8oc2VsZi5wcm9wcy5jb2x1bW5zKS50aW1lcyhmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVmc1tcImFuc3dlclwiICsgciArIFwiLFwiICsgY10uZ2V0RE9NTm9kZSgpLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHthbnN3ZXJzOiBhbnN3ZXJzfSk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFuc3dlcnMgPSB0aGlzLnByb3BzLmFuc3dlcnMuc2xpY2UoMCwgdGhpcy5wcm9wcy5yb3dzKTtcbiAgICAgICAgYW5zd2VycyA9IF8ubWFwKGFuc3dlcnMsIGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5zbGljZSgwLCBzZWxmLnByb3BzLmNvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGpzb24gPSBfLnBpY2sodGhpcy5wcm9wcywgJ3Jvd3MnLCAnY29sdW1ucycpO1xuICAgICAgICBqc29uLmFuc3dlcnMgPSBhbnN3ZXJzO1xuICAgICAgICBqc29uLmhlYWRlcnMgPSB0aGlzLnByb3BzLmhlYWRlcnMuc2xpY2UoMCwgdGhpcy5wcm9wcy5jb2x1bW5zKTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufSk7XG5cbldpZGdldHMucmVnaXN0ZXIoXCJ0YWJsZVwiLCBUYWJsZSk7XG5XaWRnZXRzLnJlZ2lzdGVyKFwidGFibGUtZWRpdG9yXCIsIFRhYmxlRWRpdG9yKTtcblxufSkoUGVyc2V1cyk7XG4iLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbihmdW5jdGlvbihQZXJzZXVzKSB7XG5cbnJlcXVpcmUoXCIuLi9jb3JlLmpzXCIpO1xudmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcblxudmFyIEdyYXBoICAgICAgICAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9ncmFwaC5qc3hcIik7XG52YXIgR3JhcGhTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2dyYXBoLXNldHRpbmdzLmpzeFwiKTtcbnZhciBJbmZvVGlwICAgICAgID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvaW5mby10aXAuanN4XCIpO1xudmFyIE51bWJlcklucHV0ICAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9udW1iZXItaW5wdXQuanN4XCIpO1xudmFyIFByb3BDaGVja0JveCAgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9wcm9wLWNoZWNrLWJveC5qc3hcIik7XG52YXIgVGVYICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi90ZXguanN4XCIpO1xudmFyIFdpZGdldHMgICAgICAgPSByZXF1aXJlKFwiLi4vd2lkZ2V0cy5qc1wiKTtcblxudmFyIFJPVEFURV9TTkFQX0RFR1JFRVMgPSAxNTtcbnZhciBERUdSRUVfU0lHTiA9IFwiXFx1MDBCMFwiO1xudmFyIFJFTkRFUl9UUkFOU0ZPUk1fREVMQVlfSU5fTVMgPSAzMDA7XG52YXIgUk9UQVRFX0hBTkRMRV9ESVNUID0gMS41O1xudmFyIFJFRkxFQ1RfUk9UQVRFX0hBTkRMRV9ESVNUID0gMjtcbnZhciBSRUZMRUNUX0JVVFRPTl9TSVpFID0gMTtcblxudmFyIGRlZXBFcSA9IFV0aWwuZGVlcEVxO1xudmFyIGtudW1iZXIgPSBLaGFuVXRpbC5rbnVtYmVyO1xudmFyIGt2ZWN0b3IgPSBLaGFuVXRpbC5rdmVjdG9yO1xudmFyIGtwb2ludCA9IEtoYW5VdGlsLmtwb2ludDtcbnZhciBrcmF5ID0gS2hhblV0aWwua3JheTtcbnZhciBrbGluZSA9IEtoYW5VdGlsLmtsaW5lO1xuXG52YXIgZGVmYXVsdEJveFNpemUgPSA0MDA7XG52YXIgZGVmYXVsdEJhY2tncm91bmRJbWFnZSA9IHtcbiAgICB1cmw6IG51bGwsXG4gICAgc2NhbGU6IDEsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG59O1xuXG5mdW5jdGlvbiBhcnJheVN1bShhcnJheSkge1xuICAgIHJldHVybiBfLnJlZHVjZShhcnJheSwgZnVuY3Rpb24obWVtbywgYXJnKSB7IHJldHVybiBtZW1vICsgYXJnOyB9LCAwKTtcbn1cblxuLyogRG9lcyBhIHBsdWNrIG9uIGtleXMgaW5zaWRlIG9iamVjdHMgaW4gYW4gb2JqZWN0XG4gKlxuICogRXg6XG4gKiB0b29scyA9IHtcbiAqICAgICB0cmFuc2xhdGlvbjoge1xuICogICAgICAgICBlbmFibGVkOiB0cnVlXG4gKiAgICAgfSxcbiAqICAgICByb3RhdGlvbjoge1xuICogICAgICAgICBlbmFibGVkOiBmYWxzZVxuICogICAgIH1cbiAqIH07XG4gKiBwbHVja09iamVjdCh0b29scywgXCJlbmFibGVkXCIpIHJldHVybnMge1xuICogICAgIHRyYW5zbGF0aW9uOiB0cnVlXG4gKiAgICAgcm90YXRpb246IGZhbHNlXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHBsdWNrT2JqZWN0KG9iamVjdCwgc3ViS2V5KSB7XG4gICAgcmV0dXJuIF8ub2JqZWN0KF8ubWFwKG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlW3N1YktleV1dO1xuICAgIH0pKTtcbn1cblxudmFyIGRlZmF1bHRHcmFwaFByb3BzID0gZnVuY3Rpb24oc2V0UHJvcHMsIGJveFNpemUpIHtcbiAgICBzZXRQcm9wcyA9IHNldFByb3BzIHx8IHt9O1xuICAgIHZhciBsYWJlbHMgPSBzZXRQcm9wcy5sYWJlbHMgfHwgW1wieFwiLCBcInlcIl07XG4gICAgdmFyIHJhbmdlID0gc2V0UHJvcHMucmFuZ2UgfHwgW1stMTAsIDEwXSwgWy0xMCwgMTBdXTtcbiAgICB2YXIgc3RlcCA9IHNldFByb3BzLnN0ZXAgfHwgWzEsIDFdO1xuICAgIHZhciBncmlkU3RlcCA9IHNldFByb3BzLmdyaWRTdGVwIHx8XG4gICAgICAgICAgICAgICBVdGlsLmdldEdyaWRTdGVwKHJhbmdlLCBzdGVwLCBib3hTaXplKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBib3g6IFtib3hTaXplLCBib3hTaXplXSxcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgZ3JpZFN0ZXA6IGdyaWRTdGVwLFxuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBkZWZhdWx0QmFja2dyb3VuZEltYWdlLFxuICAgICAgICBtYXJraW5nczogXCJncmlkXCIsXG4gICAgICAgIHNob3dQcm90cmFjdG9yOiBmYWxzZVxuICAgIH07XG59O1xuXG52YXIgZGVmYXVsdFRyYW5zZm9ybWVyUHJvcHMgPSB7XG4gICAgZ3JhZGVFbXB0eTogZmFsc2UsXG4gICAgZ3JhcGhNb2RlOiBcImludGVyYWN0aXZlXCIsXG4gICAgbGlzdE1vZGU6IFwiZHluYW1pY1wiLFxuICAgIHRvb2xzOiB7XG4gICAgICAgIHRyYW5zbGF0aW9uOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29uc3RyYWludHM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgICAgICBmaXhlZDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb29yZDogWzEsIDZdXG4gICAgICAgIH0sXG4gICAgICAgIHJlZmxlY3Rpb246IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgIGZpeGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvb3JkczogW1syLCAtNF0sIFsyLCAyXV1cbiAgICAgICAgfSxcbiAgICAgICAgZGlsYXRpb246IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgICAgIGZpeGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvb3JkOiBbNiwgNl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZHJhd1NvbHV0aW9uU2hhcGU6IHRydWUsXG4gICAgc3RhcnRpbmc6IHtcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicG9seWdvbi0zXCIsXG4gICAgICAgICAgICBjb29yZHM6IFtbMiwgMl0sIFsyLCA2XSwgWzcsIDJdXSxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zOiBbXVxuICAgIH0sXG4gICAgY29ycmVjdDoge1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgdHlwZTogXCJwb2x5Z29uLTNcIixcbiAgICAgICAgICAgIGNvb3JkczogW1syLCAyXSwgWzIsIDZdLCBbNywgMl1dLFxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1hdGlvbnM6IFtdXG4gICAgfVxufTtcblxuZnVuY3Rpb24gY29sb3JGb3JUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gdG9vbC5jb25zdHJhaW50cy5maXhlZCA/IEtoYW5VdGlsLkdSQVkgOiBLaGFuVXRpbC5PUkFOR0U7XG59XG5cblxuLyogU2NhbGVzIGEgZGlzdGFuY2UgZnJvbSB0aGUgZGVmYXVsdCByYW5nZSBvZlxuICogWy0xMCwgMTBdIHRvIGEgZ2l2ZW4gcHJvcHMucmFuZ2UgcGFpclxuICpcbiAqIFVzZWQgZm9yIHNpemluZyB2YXJpb3VzIHRyYW5zZm9ybWF0aW9uIHRvb2xzXG4gKiAocm90YXRpb24gaGFuZGxlLCBkaWxhdGlvbiBjaXJjbGUpXG4gKi9cbmZ1bmN0aW9uIHNjYWxlVG9SYW5nZShkaXN0LCByYW5nZSkge1xuICAgIHZhciBzcHJlYWRYID0gcmFuZ2VbMF1bMV0gLSByYW5nZVswXVswXTtcbiAgICB2YXIgc3ByZWFkWSA9IHJhbmdlWzFdWzFdIC0gcmFuZ2VbMV1bMF07XG5cbiAgICByZXR1cm4gZGlzdCAqIE1hdGgubWF4KHNwcmVhZFgsIHNwcmVhZFkpIC8gMjA7XG59XG5cbmZ1bmN0aW9uIGRpbGF0ZVBvaW50RnJvbUNlbnRlcihwb2ludCwgZGlsYXRpb25DZW50ZXIsIHNjYWxlKSB7XG4gICAgdmFyIHB2ID0gS2hhblV0aWwua3ZlY3Rvci5zdWJ0cmFjdChwb2ludCwgZGlsYXRpb25DZW50ZXIpO1xuICAgIHZhciBwdlNjYWxlZCA9IEtoYW5VdGlsLmt2ZWN0b3Iuc2NhbGUocHYsIHNjYWxlKTtcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IEtoYW5VdGlsLmt2ZWN0b3IuYWRkKGRpbGF0aW9uQ2VudGVyLCBwdlNjYWxlZCk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0Zyb21EZWNpbWFsKG51bWJlcikge1xuICAgIHJldHVybiBTdHJpbmcoS2hhblV0aWwucm91bmRUbyg5LCBudW1iZXIpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nRnJvbUZyYWN0aW9uKG51bWJlcikge1xuICAgIHZhciBmcmFjID0gS2hhblV0aWwudG9GcmFjdGlvbihudW1iZXIsIGtudW1iZXIuREVGQVVMVF9UT0xFUkFOQ0UpO1xuICAgIGlmIChmcmFjWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tRGVjaW1hbChudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tRGVjaW1hbChmcmFjWzBdKSArIFwiL1wiICtcbiAgICAgICAgICAgICAgICBzdHJpbmdGcm9tRGVjaW1hbChmcmFjWzFdKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRleEZyb21Qb2ludChwb2ludCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIFRlWChudWxsLCBcIihcIiksXG4gICAgICAgIHN0cmluZ0Zyb21EZWNpbWFsKHBvaW50WzBdKSxcbiAgICAgICAgVGVYKG51bGwsIFwiLCB7fVwiKSxcbiAgICAgICAgc3RyaW5nRnJvbURlY2ltYWwocG9pbnRbMV0pLFxuICAgICAgICBUZVgobnVsbCwgXCIpXCIpXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gdGV4RnJvbVZlY3Rvcih2ZWN0b3IpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBUZVgobnVsbCwgXCJcXFxcbGFuZ2xlXCIpLFxuICAgICAgICBzdHJpbmdGcm9tRGVjaW1hbCh2ZWN0b3JbMF0pLFxuICAgICAgICBUZVgobnVsbCwgXCIsIHt9XCIpLFxuICAgICAgICBzdHJpbmdGcm9tRGVjaW1hbCh2ZWN0b3JbMV0pLFxuICAgICAgICBUZVgobnVsbCwgXCJcXFxccmFuZ2xlXCIpXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gdGV4RnJvbUFuZ2xlRGVnKGFuZ2xlRGVnKSB7XG4gICAgcmV0dXJuIHN0cmluZ0Zyb21EZWNpbWFsKGFuZ2xlRGVnKSArIERFR1JFRV9TSUdOO1xufVxuXG5mdW5jdGlvbiBvcmRlckluc2Vuc2l0aXZlQ29vcmRzRXF1YWwoY29vcmRzMSwgY29vcmRzMikge1xuICAgIGNvb3JkczEgPSBfLmNsb25lKGNvb3JkczEpLnNvcnQoa3BvaW50LmNvbXBhcmUpO1xuICAgIGNvb3JkczIgPSBfLmNsb25lKGNvb3JkczIpLnNvcnQoa3BvaW50LmNvbXBhcmUpO1xuICAgIHJldHVybiBfLmFsbChfLm1hcChjb29yZHMxLCBmdW5jdGlvbihjb29yZDEsIGkpIHtcbiAgICAgICAgdmFyIGNvb3JkMiA9IGNvb3JkczJbaV07XG4gICAgICAgIHJldHVybiBrcG9pbnQuZXF1YWwoY29vcmQxLCBjb29yZDIpO1xuICAgIH0pKTtcbn1cblxuXG5cbi8qIFBlcmZvcm0gb3BlcmF0aW9ucyBvbiByYXcgdHJhbnNmb3JtIG9iamVjdHMgKi9cbnZhciBUcmFuc2Zvcm1PcHMgPSB7XG4gICAgYXBwbHk6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAvLyBBbnkgdHJhbnNmb3JtYXRpb24gd2l0aCBlbXB0eSB0ZXh0IGJveGVzIGlzIGEgbm8tb3AgdW50aWxcbiAgICAgICAgLy8gZmlsbGVkIG91dCAodGhlc2Ugc2hvdyB1cCBhcyBudWxscyBpbiB0cmFuc2Zvcm0udmVjdG9yL2xpbmUvZXRjKS5cbiAgICAgICAgLy8gVE9ETyAoamFjayk6IE1lcmdlIHRoaXMganVzdCBpbnRvIHJlZmxlY3Rpb25zIG5vdyB0aGF0IG90aGVyXG4gICAgICAgIC8vIHRyYW5zZm9ybXMgYXJlIGFsd2F5cyB2YWxpZCAoYWZ0ZXIgbWVyZ2luZyB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAvLyBjb2xsYXBzaW5nLCB3aGljaCBtYXkgdXNlIGlzVmFsaWQpXG4gICAgICAgIGlmICghVHJhbnNmb3JtYXRpb25zW3RyYW5zZm9ybS50eXBlXS5pc1ZhbGlkKHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmlkZW50aXR5OyAgLy8gZG8gbm90IHRyYW5zZm9ybSB0aGUgY29vcmRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1hdGlvbnNbdHJhbnNmb3JtLnR5cGVdLmFwcGx5KHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwZW5kOiBmdW5jdGlvbih0cmFuc2Zvcm1MaXN0LCBuZXdUcmFuc2Zvcm0pIHtcbiAgICAgICAgLy8gQXBwZW5kIG5ld1RyYW5zZm9ybSB0byB0cmFuc2Zvcm1MaXN0LCBhbmQgY29sbGFwc2UgdGhlIGxhc3RcbiAgICAgICAgLy8gdHdvIHRyYW5zZm9ybXMgaWYgdGhleSBhcmUgY29sbGFwc2FibGVcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBUcmFuc2Zvcm1PcHMuX2FwcGVuZEFuZENvbGxhcHNlTGFzdFR3byhcbiAgICAgICAgICAgIHRyYW5zZm9ybUxpc3QsXG4gICAgICAgICAgICBuZXdUcmFuc2Zvcm1cbiAgICAgICAgKTtcbiAgICAgICAgLy8gQ29sbGFwc2UgYW55IG5vLW9wcyBhdCB0aGUgZW5kIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiBsaXN0XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1PcHMuX2NvbGxhcHNlRmluYWxOb09wcyhyZXN1bHRzKTtcbiAgICB9LFxuXG4gICAgX2NvbGxhcHNlRmluYWxOb09wczogZnVuY3Rpb24odHJhbnNmb3Jtcykge1xuICAgICAgICAvLyBDb2xsYXBzZSBuby1vcCB0cmFuc2Zvcm1hdGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgICBpZiAodHJhbnNmb3Jtcy5sZW5ndGggJiYgVHJhbnNmb3JtT3BzLmlzTm9PcChfLmxhc3QodHJhbnNmb3JtcykpKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pbml0aWFsKHRyYW5zZm9ybXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybXM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2FwcGVuZEFuZENvbGxhcHNlTGFzdFR3bzogZnVuY3Rpb24odHJhbnNmb3JtTGlzdCwgbmV3VHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICghdHJhbnNmb3JtTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3VHJhbnNmb3JtXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2xsYXBzZWQgPSBUcmFuc2Zvcm1PcHMuY29sbGFwc2UoXG4gICAgICAgICAgICAgICAgXy5sYXN0KHRyYW5zZm9ybUxpc3QpLFxuICAgICAgICAgICAgICAgIG5ld1RyYW5zZm9ybVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBfLmluaXRpYWwodHJhbnNmb3JtTGlzdCkuY29uY2F0KGNvbGxhcHNlZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNOb09wOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybWF0aW9uc1t0cmFuc2Zvcm0udHlwZV0uaXNOb09wKHRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbih0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGNvbGxhcHNlIHRyYW5zZm9ybXMgdGhhdCBoYXZlIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgaWYgKHRyYW5zZm9ybTEudHlwZSAhPT0gdHJhbnNmb3JtMi50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RyYW5zZm9ybTEsIHRyYW5zZm9ybTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xpY2tpbmcgdGhlIGJ1dHRvbiBhZ2FpbiByZW1vdmVzIGVtcHR5IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBpZiAoVHJhbnNmb3JtT3BzLmlzRW1wdHkodHJhbnNmb3JtMSkgJiZcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1PcHMuaXNFbXB0eSh0cmFuc2Zvcm0yKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgY29sbGFwc2UgaW52YWxpZCB0cmFuc2Zvcm1hdGlvbnMgb3RoZXJ3aXNlXG4gICAgICAgIGlmICghVHJhbnNmb3JtT3BzLmlzVmFsaWQodHJhbnNmb3JtMSkgfHxcbiAgICAgICAgICAgICAgICAhVHJhbnNmb3JtT3BzLmlzVmFsaWQodHJhbnNmb3JtMikpIHtcbiAgICAgICAgICAgIHJldHVybiBbdHJhbnNmb3JtMSwgdHJhbnNmb3JtMl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtT3BzLl9jb2xsYXBzZVZhbGlkTW9ub3R5cGVkVHJhbnNmb3JtcyhcbiAgICAgICAgICAgIHRyYW5zZm9ybTEsXG4gICAgICAgICAgICB0cmFuc2Zvcm0yXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3JtYXRpb25zW3RyYW5zZm9ybS50eXBlXS5pc1ZhbGlkKHRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3JtYXRpb25zW3RyYW5zZm9ybS50eXBlXS5pc0VtcHR5KHRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIF9jb2xsYXBzZVZhbGlkTW9ub3R5cGVkVHJhbnNmb3JtczogZnVuY3Rpb24odHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICAgICAgICB2YXIgY29sbGFwc2VkID0gVHJhbnNmb3JtYXRpb25zW3RyYW5zZm9ybTEudHlwZV0uY29sbGFwc2UoXG4gICAgICAgICAgICB0cmFuc2Zvcm0xLFxuICAgICAgICAgICAgdHJhbnNmb3JtMlxuICAgICAgICApO1xuICAgICAgICBpZiAoY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAvLyBGb3JjZSBhbGwgYW5zd2VycyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBpZiAoIV8uaXNBcnJheShjb2xsYXBzZWQpKSB7XG4gICAgICAgICAgICAgICAgY29sbGFwc2VkID0gW2NvbGxhcHNlZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdHlwZXMgdG8gYWxsIHRyYW5zZm9ybXMgaW4gdGhlIGFuc3dlclxuICAgICAgICAgICAgXy5lYWNoKGNvbGxhcHNlZCwgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnR5cGUgPSB0cmFuc2Zvcm0xLnR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsYXBzZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVzZSB0cmFuc2Zvcm1zIGNhbid0IGJlIGNvbGxhcHNlZCB0b2dldGhlclxuICAgICAgICAgICAgcmV0dXJuIFt0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0b1RlWDogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1hdGlvbnNbdHJhbnNmb3JtLnR5cGVdLnRvVGVYKHRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIC8qIEEgcmVhY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0cmFuc2Zvcm0gb2JqZWN0ICovXG4gICAgTGlzdEl0ZW06IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm1vZGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybU9wcy50b1RlWCh0aGlzLnByb3BzLnRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLm1vZGUgPT09IFwiaW50ZXJhY3RpdmVcIikge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1DbGFzcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1hdGlvbnNbdGhpcy5wcm9wcy50cmFuc2Zvcm0udHlwZV0uSW5wdXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNsYXNzKF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2VcbiAgICAgICAgICAgICAgICB9LCB0aGlzLnByb3BzLnRyYW5zZm9ybSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGU6IFwiICsgdGhpcy5wcm9wcy5tb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMubW9kZSA9PT0gXCJpbnRlcmFjdGl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5wcm9wcy50cmFuc2Zvcm0udHlwZSxcbiAgICAgICAgICAgICAgICB9LCB0aGlzLnJlZnMudHJhbnNmb3JtLnZhbHVlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50cmFuc2Zvcm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZUNoYW5nZTogXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy52YWx1ZSgpKTtcbiAgICAgICAgfSwgUkVOREVSX1RSQU5TRk9STV9ERUxBWV9JTl9NUyksXG4gICAgICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcy50cmFuc2Zvcm0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0pXG59O1xuXG52YXIgVHJhbnNmb3JtYXRpb25zID0ge1xuICAgIHRyYW5zbGF0aW9uOiB7XG4gICAgICAgIHZlcmJOYW1lOiBcIlRyYW5zbGF0ZVwiLFxuICAgICAgICBub3VuTmFtZTogXCJUcmFuc2xhdGlvblwiLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gS2hhblV0aWwua3ZlY3Rvci5hZGQoY29vcmQsIHRyYW5zZm9ybS52ZWN0b3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pc0Zpbml0ZSh0cmFuc2Zvcm0udmVjdG9yWzBdKSAmJlxuICAgICAgICAgICAgICAgIF8uaXNGaW5pdGUodHJhbnNmb3JtLnZlY3RvclsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS52ZWN0b3JbMF0gPT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udmVjdG9yWzFdID09PSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBpc05vT3A6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGt2ZWN0b3IuZXF1YWwodHJhbnNmb3JtLnZlY3RvciwgWzAsIDBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uKHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVjdG9yOiBrdmVjdG9yLmFkZChcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtMS52ZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTIudmVjdG9yXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9UZVg6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcIlRyYW5zbGF0aW9uIGJ5IFwiLCB0ZXhGcm9tVmVjdG9yKHRyYW5zZm9ybS52ZWN0b3IpXTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5wdXQ6IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFwiIFRyYW5zbGF0aW9uIGJ5IFwiLFxuICAgICAgICAgICAgICAgICAgICBUZVgobnVsbCwgXCJcXFxcbGFuZ2xlXCIpLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJJbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJ4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjowLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy52ZWN0b3JbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApLFxuICAgICAgICAgICAgICAgICAgICBUZVgobnVsbCwgXCIsIHt9XCIpLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJJbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjowLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy52ZWN0b3JbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApLFxuICAgICAgICAgICAgICAgICAgICBUZVgobnVsbCwgXCJcXFxccmFuZ2xlXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLnJlZnMueC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5yZWZzLnkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2ZWN0b3I6IFt4LCB5XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcy54LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIHJvdGF0aW9uOiB7XG4gICAgICAgIHZlcmJOYW1lOiBcIlJvdGF0ZVwiLFxuICAgICAgICBub3VuTmFtZTogXCJSb3RhdGlvblwiLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gS2hhblV0aWwua3BvaW50LnJvdGF0ZURlZyhjb29yZCwgdHJhbnNmb3JtLmFuZ2xlRGVnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmNlbnRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBfLmlzRmluaXRlKHRyYW5zZm9ybS5hbmdsZURlZykgJiZcbiAgICAgICAgICAgICAgICBfLmlzRmluaXRlKHRyYW5zZm9ybS5jZW50ZXJbMF0pICYmXG4gICAgICAgICAgICAgICAgXy5pc0Zpbml0ZSh0cmFuc2Zvcm0uY2VudGVyWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtLmFuZ2xlRGVnID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLmNlbnRlclswXSA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5jZW50ZXJbMV0gPT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTm9PcDogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4ga251bWJlci5lcXVhbCh0cmFuc2Zvcm0uYW5nbGVEZWcsIDApO1xuICAgICAgICB9LFxuICAgICAgICBjb2xsYXBzZTogZnVuY3Rpb24odHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICAgICAgICAgICAgaWYgKCFrcG9pbnQuZXF1YWwodHJhbnNmb3JtMS5jZW50ZXIsIHRyYW5zZm9ybTIuY2VudGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2VudGVyOiB0cmFuc2Zvcm0xLmNlbnRlcixcbiAgICAgICAgICAgICAgICBhbmdsZURlZzogdHJhbnNmb3JtMS5hbmdsZURlZyArIHRyYW5zZm9ybTIuYW5nbGVEZWdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHRvVGVYOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXCJSb3RhdGlvbiBieSBcIixcbiAgICAgICAgICAgICAgICB0ZXhGcm9tQW5nbGVEZWcodHJhbnNmb3JtLmFuZ2xlRGVnKSxcbiAgICAgICAgICAgICAgICBcIiBhYm91dCBcIixcbiAgICAgICAgICAgICAgICB0ZXhGcm9tUG9pbnQodHJhbnNmb3JtLmNlbnRlcilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICAgIElucHV0OiBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBSb3RhdGlvbiBhYm91dCBcIiwgVGVYKG51bGwsIFwiKFwiKSxcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVySW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwiY2VudGVyWFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMucHJvcHMuY2VudGVyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgICAgICAgICAgVGVYKG51bGwsIFwiLCB7fVwiKSxcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVySW5wdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwiY2VudGVyWVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMucHJvcHMuY2VudGVyWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgICAgICAgICAgVGVYKG51bGwsIFwiKVwiKSwgXCIgYnkgXCIsXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcklucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcImFuZ2xlRGVnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjowLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy5hbmdsZURlZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMucHJvcHMub25DaGFuZ2V9ICksXG4gICAgICAgICAgICAgICAgICAgIERFR1JFRV9TSUdOXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlRGVnID0gdGhpcy5yZWZzLmFuZ2xlRGVnLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlclggPSB0aGlzLnJlZnMuY2VudGVyWC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJZID0gdGhpcy5yZWZzLmNlbnRlclkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZURlZzogYW5nbGVEZWcsXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjogW2NlbnRlclgsIGNlbnRlclldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZzLmNlbnRlclguZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgcmVmbGVjdGlvbjoge1xuICAgICAgICB2ZXJiTmFtZTogXCJSZWZsZWN0XCIsXG4gICAgICAgIG5vdW5OYW1lOiBcIlJlZmxlY3Rpb25cIixcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtoYW5VdGlsLmtwb2ludC5yZWZsZWN0T3ZlckxpbmUoXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ubGluZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEEgYml0IGhhY2t5LCBidXQgd2UnbGwgYWxzbyBkZWZpbmUgcmVmbGVjdGluZyBvdmVyIGFcbiAgICAgICAgICAgIC8vIHNpbmdsZSBwb2ludCBhcyBhIG5vLW9wLCB0byBhdm9pZCBOYU4gZnVuLlxuICAgICAgICAgICAgcmV0dXJuIF8uYWxsKF8uZmxhdHRlbih0cmFuc2Zvcm0ubGluZSksIF8uaXNGaW5pdGUpICYmXG4gICAgICAgICAgICAgICAgICAgICFrcG9pbnQuZXF1YWwodHJhbnNmb3JtLmxpbmVbMF0sIHRyYW5zZm9ybS5saW5lWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5hbGwoXy5mbGF0dGVuKHRyYW5zZm9ybS5saW5lKSwgXy5pc051bGwpO1xuICAgICAgICB9LFxuICAgICAgICBpc05vT3A6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gSW52YWxpZCB0cmFuc2Zvcm1zIGFyZSBpbXBsaWNpdGx5IG5vLW9wcywgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gY2F0Y2ggdGhhdCBjYXNlIGhlcmUuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhcHNlOiBmdW5jdGlvbih0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gICAgICAgICAgICBpZiAoIWtsaW5lLmVxdWFsKHRyYW5zZm9ybTEubGluZSwgdHJhbnNmb3JtMi5saW5lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9UZVg6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIHBvaW50MSA9IHRyYW5zZm9ybS5saW5lWzBdO1xuICAgICAgICAgICAgdmFyIHBvaW50MiA9IHRyYW5zZm9ybS5saW5lWzFdO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBcIlJlZmxlY3Rpb24gb3ZlciB0aGUgbGluZSBmcm9tIFwiLFxuICAgICAgICAgICAgICAgIHRleEZyb21Qb2ludChwb2ludDEpLFxuICAgICAgICAgICAgICAgIFwiIHRvIFwiLFxuICAgICAgICAgICAgICAgIHRleEZyb21Qb2ludChwb2ludDIpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBJbnB1dDogUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgUmVmbGVjdGlvbiBvdmVyIHRoZSBsaW5lIGZyb20gXCIsXG4gICAgICAgICAgICAgICAgICAgIFRlWChudWxsLCBcIihcIiksXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcklucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcIngxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0VtcHR5OnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmxpbmVbMF1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApLFxuICAgICAgICAgICAgICAgICAgICBUZVgobnVsbCwgXCIsIHt9XCIpLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJJbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJ5MVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dFbXB0eTp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy5saW5lWzBdWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgICAgICAgICAgVGVYKG51bGwsIFwiKVwiKSwgXCIgdG8gXCIsIFRlWChudWxsLCBcIihcIiksXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcklucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcIngyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0VtcHR5OnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmxpbmVbMV1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApLFxuICAgICAgICAgICAgICAgICAgICBUZVgobnVsbCwgXCIsIHt9XCIpLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJJbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJ5MlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dFbXB0eTp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6dGhpcy5wcm9wcy5saW5lWzFdWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgICAgICAgICAgVGVYKG51bGwsIFwiKVwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB4MSA9IHRoaXMucmVmcy54MS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IHRoaXMucmVmcy55MS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciB4MiA9IHRoaXMucmVmcy54Mi5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciB5MiA9IHRoaXMucmVmcy55Mi5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IFtbeDEsIHkxXSwgW3gyLCB5Ml1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZzLngxLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIGRpbGF0aW9uOiB7XG4gICAgICAgIHZlcmJOYW1lOiBcIkRpbGF0ZVwiLFxuICAgICAgICBub3VuTmFtZTogXCJEaWxhdGlvblwiLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlsYXRlUG9pbnRGcm9tQ2VudGVyKGNvb3JkLCB0cmFuc2Zvcm0uY2VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLnNjYWxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uaXNGaW5pdGUodHJhbnNmb3JtLnNjYWxlKSAmJlxuICAgICAgICAgICAgICAgIF8uaXNGaW5pdGUodHJhbnNmb3JtLmNlbnRlclswXSkgJiZcbiAgICAgICAgICAgICAgICBfLmlzRmluaXRlKHRyYW5zZm9ybS5jZW50ZXJbMV0pO1xuICAgICAgICB9LFxuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0uc2NhbGUgPT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uY2VudGVyWzBdID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLmNlbnRlclsxXSA9PT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNOb09wOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBrbnVtYmVyLmVxdWFsKHRyYW5zZm9ybS5zY2FsZSwgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhcHNlOiBmdW5jdGlvbih0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gICAgICAgICAgICBpZiAoIWtwb2ludC5lcXVhbCh0cmFuc2Zvcm0xLmNlbnRlciwgdHJhbnNmb3JtMi5jZW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IHRyYW5zZm9ybTEuY2VudGVyLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB0cmFuc2Zvcm0xLnNjYWxlICogdHJhbnNmb3JtMi5zY2FsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9UZVg6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIHNjYWxlU3RyaW5nID0gc3RyaW5nRnJvbUZyYWN0aW9uKHRyYW5zZm9ybS5zY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFwiRGlsYXRpb24gb2Ygc2NhbGUgXCIsXG4gICAgICAgICAgICAgICAgc2NhbGVTdHJpbmcsXG4gICAgICAgICAgICAgICAgXCIgYWJvdXQgXCIsXG4gICAgICAgICAgICAgICAgdGV4RnJvbVBvaW50KHRyYW5zZm9ybS5jZW50ZXIpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBJbnB1dDogUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgRGlsYXRpb24gYWJvdXQgXCIsXG4gICAgICAgICAgICAgICAgICAgIFRlWChudWxsLCBcIihcIiksXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcklucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcInhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOjAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmNlbnRlclswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMucHJvcHMub25DaGFuZ2V9ICksXG4gICAgICAgICAgICAgICAgICAgIFRlWChudWxsLCBcIiwge31cIiksXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcklucHV0KFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlZjpcInlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOjAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLnByb3BzLmNlbnRlclsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMucHJvcHMub25DaGFuZ2V9ICksXG4gICAgICAgICAgICAgICAgICAgIFRlWChudWxsLCBcIilcIiksIFwiIGJ5IHNjYWxlIFwiLFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXJJbnB1dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZWY6XCJzY2FsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOnRoaXMucHJvcHMuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5yZWZzLnNjYWxlLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLnJlZnMueC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5yZWZzLnkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjogW3gsIHldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZzLnguZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59O1xuXG5cbi8qIFZhcmlvdXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBkaWZmZXJlbnQgc2hhcGUgdHlwZXMgKi9cbnZhciBTaGFwZVR5cGVzID0ge1xuICAgIGdldFBvaW50Q291bnRGb3JUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBzcGxpdFR5cGUgPSB0eXBlLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgaWYgKHNwbGl0VHlwZVswXSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFR5cGVbMV0gfHwgMztcbiAgICAgICAgfSBlbHNlIGlmIChzcGxpdFR5cGVbMF0gPT09IFwibGluZVwiIHx8XG4gICAgICAgICAgICAgICAgc3BsaXRUeXBlWzBdID09PSBcImxpbmVTZWdtZW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHNwbGl0VHlwZVswXSA9PT0gXCJhbmdsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfSBlbHNlIGlmIChzcGxpdFR5cGVbMF0gPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHNwbGl0VHlwZVswXSA9PT0gXCJwb2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRNb3ZhYmxlU2hhcGU6IGZ1bmN0aW9uKGdyYXBoaWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZWRpdGFibGUgJiYgb3B0aW9ucy50cmFuc2xhdGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBoYXZlIGEgbW92YWJsZSBzaGFwZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwid2hlcmUgeW91IGNhbiBzdHJldGNoIHRoZSBwb2ludHMgYW5kIHRyYW5zbGF0ZSB0aGVtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzaW11bHRhbmVvdXNseS4gb3B0aW9uczogXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhcGU7XG4gICAgICAgIHZhciBwb2ludHMgPSBfLm1hcChvcHRpb25zLnNoYXBlLmNvb3JkcywgZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9pbnQ7XG4gICAgICAgICAgICB2YXIgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0Nvb3JkID0gY29vcmQ7XG5cbiAgICAgICAgICAgIHZhciBvbk1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdmluZykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0Nvb3JkID0gY3VycmVudFBvaW50LmNvb3JkO1xuICAgICAgICAgICAgICAgICAgICBpc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1vdmVWZWN0b3IgPSBLaGFuVXRpbC5rdmVjdG9yLnN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICBbeCwgeV0sXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludC5jb29yZFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgZnJvbSAoeCwgeSkgc2VtYW50aWNzIHRvIChkWCwgZFkpIHNlbWFudGljc1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbW9yZSB1c2VmdWwgZm9yIHRyYW5zbGF0aW9ucyBvbiBtdWx0aXBsZSBwb2ludHMsXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgd2UgY2FyZSBhYm91dCBob3cgdGhlIHBvaW50cyBtb3ZlZCwgbm90IHdoZXJlIGFueVxuICAgICAgICAgICAgICAgIC8vIGluZGl2aWR1YWwgcG9pbnQgZW5kZWQgdXBcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbk1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVZlY3RvciA9IG9wdGlvbnMub25Nb3ZlKG1vdmVWZWN0b3JbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVZlY3RvclsxXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIHRyYW5zbGF0aW9uIG9uIGFsbCBwb2ludHMgaW4gdGhpcyBzaGFwZSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gYW55IHBvaW50IG1vdmVzXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNsYXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChwb2ludHMsIGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcG9pbnQgaXRzZWxmIHdpbGwgYmUgdXBkYXRlZCBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmFibGVQb2ludCBjbGFzcywgc28gb25seSB0cmFuc2xhdGUgdGhlIG90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCAhPT0gY3VycmVudFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQuc2V0Q29vcmQoS2hhblV0aWwua3ZlY3Rvci5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LmNvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlVmVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgc2hhcGUgYW5kIG91ciBjdXJyZW50UG9pbnRcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMsIHNvbWUgc2hhcGVzIChjaXJjbGVzLCBhbmdsZXMpIGFwcGVhclxuICAgICAgICAgICAgICAgIC8vIFwiYm91bmN5XCIgYXMgdGhleSBhcmUgdXBkYXRlZCB3aXRoIGN1cnJlbnRQb2ludCBhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IG1vdXNlIGNvb3JkaW5hdGUgKG9sZENvb3JkKSwgcmF0aGVyIHRoYW4gbmV3Q29vcmRcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ29vcmQgPSBjdXJyZW50UG9pbnQuY29vcmQ7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0Nvb3JkID0gS2hhblV0aWwua3ZlY3Rvci5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludC5jb29yZCxcbiAgICAgICAgICAgICAgICAgICAgbW92ZVZlY3RvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgY2hhbmdlIG91ciBjb29yZGluYXRlIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBzaGFwZS51cGRhdGUoKSBzZWVzIHRoZSBuZXcgY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludC5jb29yZCA9IG5ld0Nvb3JkO1xuICAgICAgICAgICAgICAgIHNoYXBlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIC4uLkJ1dCBkb24ndCBicmVhayBvbk1vdmUsIHdoaWNoIGFzc3VtZXMgaXRcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgb25seSB0aGluZyBjaGFuZ2luZyBvdXIgY29vcmRcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQuY29vcmQgPSBvbGRDb29yZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29vcmQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgb25Nb3ZlRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gb25Nb3ZlIGlzbid0IGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIGJlZm9yZSBvbk1vdmVFbmQsIHNvXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCB0aGF0IHdlIG1heSBub3QgaGF2ZSBtb3ZlZCBhbmRcbiAgICAgICAgICAgICAgICAvLyBzZXQgcHJldmlvdXNDb29yZC5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbk1vdmVFbmQgJiYgaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIHRoZSBzdXBwbGllZCB4IGFuZCB5IHBhcmFtZXRlcnMgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIE1vdmFibGVQb2ludCdzIG9uTW92ZUVuZCBzZW1hbnRpY3Mgc3Vjay5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgcmV0dXJucyB0aGUgbW91c2VYLCBtb3VzZVkgd2l0aG91dCBwcm9jZXNzaW5nIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3VnaCBvbk1vdmUsIGxlYXZpbmcgdXMgd2l0aCB3ZWlyZCBmcmFjdGlvbmFsIG1vdmVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBLaGFuVXRpbC5rdmVjdG9yLnN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50LmNvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDb29yZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uTW92ZUVuZChjaGFuZ2VbMF0sIGNoYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNoYXBlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY3VycmVudFBvaW50ID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9pbnQoe1xuICAgICAgICAgICAgICAgIGNvb3JkOiBjb29yZCxcbiAgICAgICAgICAgICAgICBub3JtYWxTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZml4ZWQ6ICFvcHRpb25zLnRyYW5zbGF0YWJsZSAmJiAhb3B0aW9ucy5lZGl0YWJsZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogb3B0aW9ucy5zaG93UG9pbnRzLFxuICAgICAgICAgICAgICAgIHNuYXBYOiBvcHRpb25zLnNuYXAgJiYgb3B0aW9ucy5zbmFwWzBdIHx8IDAsXG4gICAgICAgICAgICAgICAgc25hcFk6IG9wdGlvbnMuc25hcCAmJiBvcHRpb25zLnNuYXBbMV0gfHwgMCxcbiAgICAgICAgICAgICAgICBib3VuZGVkOiBmYWxzZSwgLy8gRG9uJ3QgYm91bmQgaXQgd2hlbiBwbGFjaW5nIGl0IG9uIHRoZSBncmFwaFxuICAgICAgICAgICAgICAgIG9uTW92ZTogb25Nb3ZlLFxuICAgICAgICAgICAgICAgIG9uTW92ZUVuZDogb25Nb3ZlRW5kXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQm91bmQgaXQgd2hlbiBtb3ZpbmdcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IHNldCB0aGlzIGVhcmxpZXIsIGJlY2F1c2UgZG9pbmcgc28gd291bGQgbWVhbiBhbnlcbiAgICAgICAgICAgIC8vIHBvaW50cyBvdXRzaWRlIG9mIHRoZSBncmFwaCB3b3VsZCBiZSBtb3ZlZCBpbnRvIGEgbW92ZWQgaW50b1xuICAgICAgICAgICAgLy8gYSBwb3NpdGlvbiB0aGF0IGRvZXNuJ3QgcHJlc2VydmUgdGhlIHNoYXBlXG4gICAgICAgICAgICBjdXJyZW50UG9pbnQuYm91bmRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UG9pbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNoYXBlID0gU2hhcGVUeXBlcy5hZGRTaGFwZShncmFwaGllLCBvcHRpb25zLCBwb2ludHMpO1xuICAgICAgICB2YXIgcmVtb3ZlU2hhcGVXaXRob3V0UG9pbnRzID0gc2hhcGUucmVtb3ZlO1xuICAgICAgICBzaGFwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZVNoYXBlV2l0aG91dFBvaW50cy5hcHBseShzaGFwZSk7XG4gICAgICAgICAgICBfLmludm9rZShwb2ludHMsIFwicmVtb3ZlXCIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSxcblxuICAgIGFkZFNoYXBlOiBmdW5jdGlvbihncmFwaGllLCBvcHRpb25zLCBwb2ludHMpIHtcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzIHx8IG9wdGlvbnMuc2hhcGUuY29vcmRzO1xuXG4gICAgICAgIHZhciB0eXBlcyA9IFNoYXBlVHlwZXMuX3R5cGVzT2Yob3B0aW9ucy5zaGFwZSk7XG4gICAgICAgIHZhciB0eXBlT3B0aW9ucyA9IG9wdGlvbnMuc2hhcGUub3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgIFNoYXBlVHlwZXMuZGVmYXVsdE9wdGlvbnModHlwZXMpO1xuXG4gICAgICAgIHZhciBzaGFwZXMgPSBTaGFwZVR5cGVzLl9tYXBUeXBlcyh0eXBlcywgcG9pbnRzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHR5cGUsIHBvaW50cywgaSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlT3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB0eXBlT3B0aW9uc1tpXSk7XG4gICAgICAgICAgICByZXR1cm4gU2hhcGVUeXBlcy5fYWRkVHlwZShncmFwaGllLCB0eXBlLCBwb2ludHMsIHNoYXBlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB1cGRhdGVGdW5jcyA9IF8uZmlsdGVyKF8ucGx1Y2soc2hhcGVzLCBcInVwZGF0ZVwiKSwgXy5pZGVudGl0eSk7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF8uaW52b2tlKHVwZGF0ZUZ1bmNzLCBcImNhbGxcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUZ1bmNzID0gXy5maWx0ZXIoXy5wbHVjayhzaGFwZXMsIFwicmVtb3ZlXCIpLCBfLmlkZW50aXR5KTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXy5pbnZva2UocmVtb3ZlRnVuY3MsIFwiY2FsbFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHNoYXBlcywgZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuZ2V0T3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGUuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gXy5tYXAocG9pbnRzLCBmdW5jdGlvbihwdCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHQuY29vcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVzLFxuICAgICAgICAgICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGdldE9wdGlvbnMoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZXMsXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICAgICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgICAgICAgICB0b0pTT046IHRvSlNPTixcbiAgICAgICAgICAgIGdldE9wdGlvbnM6IGdldE9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZXF1YWw6IGZ1bmN0aW9uKHNoYXBlMSwgc2hhcGUyKSB7XG4gICAgICAgIHZhciB0eXBlczEgPSBTaGFwZVR5cGVzLl90eXBlc09mKHNoYXBlMSk7XG4gICAgICAgIHZhciB0eXBlczIgPSBTaGFwZVR5cGVzLl90eXBlc09mKHNoYXBlMik7XG4gICAgICAgIGlmICh0eXBlczEubGVuZ3RoICE9PSB0eXBlczIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNoYXBlczEgPSBTaGFwZVR5cGVzLl9tYXBUeXBlcyh0eXBlczEsIHNoYXBlMS5jb29yZHMsXG4gICAgICAgICAgICAgICAgU2hhcGVUeXBlcy5fY29tYmluZSk7XG4gICAgICAgIHZhciBzaGFwZXMyID0gU2hhcGVUeXBlcy5fbWFwVHlwZXModHlwZXMyLCBzaGFwZTIuY29vcmRzLFxuICAgICAgICAgICAgICAgIFNoYXBlVHlwZXMuX2NvbWJpbmUpO1xuICAgICAgICByZXR1cm4gXy5hbGwoXy5tYXAoc2hhcGVzMSwgZnVuY3Rpb24ocGFydGlhbFNoYXBlMSwgaSkge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxTaGFwZTIgPSBzaGFwZXMyW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnRpYWxTaGFwZTEudHlwZSAhPT0gcGFydGlhbFNoYXBlMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNoYXBlVHlwZXMuX2ZvclR5cGUocGFydGlhbFNoYXBlMS50eXBlKS5lcXVhbChcbiAgICAgICAgICAgICAgICBwYXJ0aWFsU2hhcGUxLmNvb3JkcyxcbiAgICAgICAgICAgICAgICBwYXJ0aWFsU2hhcGUyLmNvb3Jkc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBfdHlwZXNPZjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgdmFyIHR5cGVzID0gc2hhcGUudHlwZTtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkodHlwZXMpKSB7XG4gICAgICAgICAgICB0eXBlcyA9IFt0eXBlc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8ubWFwKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwb2x5Z29uLTNcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0T3B0aW9uczogZnVuY3Rpb24odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIF8ubWFwKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZURlZmF1bHRPcHRpb25zID0gU2hhcGVUeXBlcy5fZm9yVHlwZSh0eXBlKS5kZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgdHlwZURlZmF1bHRPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9mb3JUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBiYXNlVHlwZSA9IHR5cGUuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgICByZXR1cm4gU2hhcGVUeXBlc1tiYXNlVHlwZV07XG4gICAgfSxcblxuICAgIF9tYXBUeXBlczogZnVuY3Rpb24odHlwZXMsIHBvaW50cywgZnVuYywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gXy5tYXAodHlwZXMsIGZ1bmN0aW9uKHR5cGUsIGkpIHtcbiAgICAgICAgICAgIHZhciBwb2ludENvdW50ID0gU2hhcGVUeXBlcy5nZXRQb2ludENvdW50Rm9yVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9pbnRzID0gXy5maXJzdChwb2ludHMsIHBvaW50Q291bnQpO1xuICAgICAgICAgICAgcG9pbnRzID0gXy5yZXN0KHBvaW50cywgcG9pbnRDb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHR5cGUsIGN1cnJlbnRQb2ludHMsIGkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2FkZFR5cGU6IGZ1bmN0aW9uKGdyYXBoaWUsIHR5cGUsIHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGluZUNvb3JkcyA9IF8uaXNBcnJheShwb2ludHNbMF0pID8ge1xuICAgICAgICAgICAgY29vcmRBOiBwb2ludHNbMF0sXG4gICAgICAgICAgICBjb29yZFo6IHBvaW50c1sxXSxcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIHBvaW50QTogcG9pbnRzWzBdLFxuICAgICAgICAgICAgcG9pbnRaOiBwb2ludHNbMV0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdHlwZSA9IHR5cGUuc3BsaXQoXCItXCIpWzBdO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9seWdvbihfLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGZpeGVkOiAhb3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgICAgICAgICBzbmFwWDogb3B0aW9ucy5zbmFwICYmIG9wdGlvbnMuc25hcFswXSB8fCAwLFxuICAgICAgICAgICAgICAgIHNuYXBZOiBvcHRpb25zLnNuYXAgJiYgb3B0aW9ucy5zbmFwWzFdIHx8IDAsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICAgICAgY29uc3RyYWluVG9HcmFwaDogZmFsc2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBfLmJpbmQocG9seWdvbi50cmFuc2Zvcm0sIHBvbHlnb24pLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogXy5iaW5kKHBvbHlnb24ucmVtb3ZlLCBwb2x5Z29uKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImxpbmVcIiB8fCB0eXBlID09PSBcImxpbmVTZWdtZW50XCIpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gZ3JhcGhpZS5hZGRNb3ZhYmxlTGluZVNlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCBsaW5lQ29vcmRzLCB7XG4gICAgICAgICAgICAgICAgbW92ZVBvaW50c1dpdGhMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpeGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHRlbmRMaW5lOiAodHlwZSA9PT0gXCJsaW5lXCIpXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIC8vIEhpZGUgcG9pbnRzIG9uIHVuZWRpdGFibGUgbGluZXNcbiAgICAgICAgICAgIC8vIFRPRE8oamFjayk6IFRoaXMgaXMgZGlzYWJsZWQgYmVjYXVzZSB0cmFuc2xhdGlvbiBjdXJyZW50bHlcbiAgICAgICAgICAgIC8vIHVzZXMgdGhlc2UgcG9pbnRzLiByZS1lbmFibGUgdGhpcyBjb2RlIHdoZW4gdHJhbnNsYXRpb24gdXNlc1xuICAgICAgICAgICAgLy8gYSB2ZWN0b3Jcbi8vICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibGluZVwiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgIV8uaXNBcnJheShwb2ludHNbMF0pICYmXG4vLyAgICAgICAgICAgICAgICAgICAgIW9wdGlvbnMuZWRpdGFibGUpIHtcbi8vICAgICAgICAgICAgICAgIF8uaW52b2tlKHBvaW50cywgXCJyZW1vdmVcIik7XG4vLyAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBfLmJpbmQobGluZS50cmFuc2Zvcm0sIGxpbmUsIHRydWUpLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogXy5iaW5kKGxpbmUucmVtb3ZlLCBsaW5lKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImFuZ2xlXCIpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgYW5nbGUgaXMgZWRpdGFibGUsIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBtYWtlIGFuZ2xlc1xuICAgICAgICAgICAgLy8gYm90aCBsYXJnZXIgYW5kIHNtYWxsZXIgdGhhbiAxODAgZGVncmVlcy5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgYW5nbGUgaXMgbm90IGVkaXRhYmxlLCBpdCBzaG91bGQgYWx3YXlzIG1haW50YWluXG4gICAgICAgICAgICAvLyBpdCdzIGFuZ2xlIG1lYXN1cmUsIGV2ZW4gaWYgaXQgaXMgcmVmbGVjdGVkIChjYXVzaW5nIHRoZVxuICAgICAgICAgICAgLy8gY2xvY2t3aXNlLW5lc3Mgb2YgdGhlIHBvaW50cyB0byBjaGFuZ2UpXG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2hhbmdlUmVmbGV4aXZpdHkgPSBvcHRpb25zLmVkaXRhYmxlID8gbnVsbCA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBncmFwaGllLmFkZE1vdmFibGVBbmdsZSh7XG4gICAgICAgICAgICAgICAgYW5nbGVMYWJlbDogXCIkZGVnMFwiLFxuICAgICAgICAgICAgICAgIGZpeGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlOiBvcHRpb25zLm5vcm1hbFN0eWxlLFxuICAgICAgICAgICAgICAgIHJlZmxleDogb3B0aW9ucy5yZWZsZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBIaWRlIG5vbi12ZXJ0ZXggcG9pbnRzIG9uIHVuZWRpdGFibGUgYW5nbGVzXG4gICAgICAgICAgICBpZiAoIV8uaXNBcnJheShwb2ludHNbMF0pICYmICFvcHRpb25zLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzBdLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBfLmJpbmQoYW5nbGUudXBkYXRlLCBhbmdsZSwgc2hvdWxkQ2hhbmdlUmVmbGV4aXZpdHkpLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogXy5iaW5kKGFuZ2xlLnJlbW92ZSwgYW5nbGUpLFxuICAgICAgICAgICAgICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmbGV4OiBhbmdsZS5pc1JlZmxleCgpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNpcmNsZVwiKSB7XG4gICAgICAgICAgICB2YXIgcGVyaW1ldGVyID0ge1xuICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBvYmplY3QgZm9yIHRoZSBmaXJzdCByZW1vdmFsXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBfLmlkZW50aXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlZHJhd1BlcmltID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkMCA9IHBvaW50c1swXS5jb29yZCB8fCBwb2ludHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkMSA9IHBvaW50c1sxXS5jb29yZCB8fCBwb2ludHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IGtwb2ludC5kaXN0YW5jZVRvUG9pbnQoY29vcmQwLCBjb29yZDEpO1xuICAgICAgICAgICAgICAgIHBlcmltZXRlci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBwZXJpbWV0ZXIgPSBncmFwaGllLmNpcmNsZShjb29yZDAsIHJhZGl1cywgXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkJMVUUsXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDJcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLm5vcm1hbFN0eWxlKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZWRyYXdQZXJpbSgpO1xuICAgICAgICAgICAgaWYgKHBvaW50c1sxXS5yZW1vdmUgJiYgIW9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbMV0ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiByZWRyYXdQZXJpbSxcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgXy5iaW5kIGJlY2F1c2UgdGhlIHJlbW92ZSBmdW5jdGlvbiBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHBlcmltZXRlciBpcyByZWRyYXduXG4gICAgICAgICAgICAgICAgICAgIHBlcmltZXRlci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicG9pbnRcIikge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaGFwZSB0eXBlIFwiICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbWJpbmU6IGZ1bmN0aW9uKHR5cGUsIGNvb3Jkcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvb3JkczogY29vcmRzXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBvbHlnb246IHtcbiAgICAgICAgZXF1YWw6IG9yZGVySW5zZW5zaXRpdmVDb29yZHNFcXVhbFxuICAgIH0sXG5cbiAgICBsaW5lOiB7XG4gICAgICAgIGVxdWFsOiBrbGluZS5lcXVhbFxuICAgIH0sXG5cbiAgICBsaW5lU2VnbWVudDoge1xuICAgICAgICBlcXVhbDogb3JkZXJJbnNlbnNpdGl2ZUNvb3Jkc0VxdWFsXG4gICAgfSxcblxuICAgIGFuZ2xlOiB7XG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbihwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgICAgICAgICBpZiAoIWtwb2ludC5lcXVhbChwb2ludHMxWzFdLCBwb2ludHMyWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpbmUxXzAgPSBbcG9pbnRzMVsxXSwgcG9pbnRzMVswXV07XG4gICAgICAgICAgICB2YXIgbGluZTFfMiA9IFtwb2ludHMxWzFdLCBwb2ludHMxWzJdXTtcbiAgICAgICAgICAgIHZhciBsaW5lMl8wID0gW3BvaW50czJbMV0sIHBvaW50czJbMF1dO1xuICAgICAgICAgICAgdmFyIGxpbmUyXzIgPSBbcG9pbnRzMlsxXSwgcG9pbnRzMlsyXV07XG5cbiAgICAgICAgICAgIHZhciBlcXVhbFVuZmxpcHBlZCA9IGtyYXkuZXF1YWwobGluZTFfMCwgbGluZTJfMCkgJiZcbiAgICAgICAgICAgICAgICAgICAga3JheS5lcXVhbChsaW5lMV8yLCBsaW5lMl8yKTtcbiAgICAgICAgICAgIHZhciBlcXVhbEZsaXBwZWQgPSBrcmF5LmVxdWFsKGxpbmUxXzAsIGxpbmUyXzIpICYmXG4gICAgICAgICAgICAgICAgICAgIGtyYXkuZXF1YWwobGluZTFfMiwgbGluZTJfMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBlcXVhbFVuZmxpcHBlZCB8fCBlcXVhbEZsaXBwZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJlZmxleDogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjaXJjbGU6IHtcbiAgICAgICAgZXF1YWw6IGZ1bmN0aW9uKHBvaW50czEsIHBvaW50czIpIHtcbiAgICAgICAgICAgIHZhciByYWRpdXMxID0ga3BvaW50LmRpc3RhbmNlVG9Qb2ludChwb2ludHMxWzBdLCBwb2ludHMxWzFdKTtcbiAgICAgICAgICAgIHZhciByYWRpdXMyID0ga3BvaW50LmRpc3RhbmNlVG9Qb2ludChwb2ludHMyWzBdLCBwb2ludHMyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBrcG9pbnQuZXF1YWwocG9pbnRzMVswXSwgcG9pbnRzMlswXSkgJiZcbiAgICAgICAgICAgICAgICBrbnVtYmVyLmVxdWFsKHJhZGl1czEsIHJhZGl1czIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBvaW50OiB7XG4gICAgICAgIGVxdWFsOiBrcG9pbnQuZXF1YWxcbiAgICB9XG59O1xuXG5cbnZhciBUb29sU2V0dGluZ3MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdUb29sU2V0dGluZ3MnLFxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxvd0ZpeGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5uYW1lLFwiOiBcIixcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgUHJvcENoZWNrQm94KFxuICAgICAgICAgICAgICAgIHtsYWJlbDpcImVuYWJsZWQ6XCIsXG4gICAgICAgICAgICAgICAgZW5hYmxlZDp0aGlzLnByb3BzLnNldHRpbmdzLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXR0aW5ncy5lbmFibGVkICYmXG4gICAgICAgICAgICAgICAgUHJvcENoZWNrQm94KFxuICAgICAgICAgICAgICAgICAgICB7bGFiZWw6XCJyZXF1aXJlZDpcIixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6dGhpcy5wcm9wcy5zZXR0aW5ncy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5wcm9wcy5vbkNoYW5nZX0gKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXR0aW5ncy5lbmFibGVkICYmXG4gICAgICAgICAgICAgICAgSW5mb1RpcChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgXCIgJ1JlcXVpcmVkJyB3aWxsIG9ubHkgZ3JhZGUgdGhlIGFuc3dlciBhcyBjb3JyZWN0IGlmIHRoZSBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJzdHVkZW50IGhhcyB1c2VkIGF0IGxlYXN0IG9uZSBzdWNoIHRyYW5zZm9ybWF0aW9uLiBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5hbGxvd0ZpeGVkICYmIHRoaXMucHJvcHMuc2V0dGluZ3MuZW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgIFByb3BDaGVja0JveChcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsOlwiZml4ZWQ6XCIsXG4gICAgICAgICAgICAgICAgICAgIGZpeGVkOnRoaXMucHJvcHMuc2V0dGluZ3MuY29uc3RyYWludHMuZml4ZWQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuY2hhbmdlQ29uc3RyYWludHN9ICksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucHJvcHMuYWxsb3dGaXhlZCAmJiB0aGlzLnByb3BzLnNldHRpbmdzLmVuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICBJbmZvVGlwKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICBcIiBFbmFibGUgJ2ZpeGVkJyB0byBwcmV2ZW50IHRoZSBzdHVkZW50IGZyb20gcmVwb3NpdGlvbmluZyBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJ0aGUgdG9vbC4gVGhlIHRvb2wgd2lsbCBhcHBlYXIgaW4gdGhlIHBvc2l0aW9uIGF0IHdoaWNoIGl0IFwiK1xuICAgICAgICAgICAgICAgICAgICBcImlzIHBsYWNlZCBpbiB0aGUgZWRpdG9yIGJlbG93LiBcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VDb25zdHJhaW50czogZnVuY3Rpb24oY2hhbmdlZCkge1xuICAgICAgICB2YXIgbmV3Q29uc3RyYWludHMgPSBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy5jb25zdHJhaW50cywgY2hhbmdlZCk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgY29uc3RyYWludHM6IG5ld0NvbnN0cmFpbnRzXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5cbnZhciBUcmFuc2Zvcm1hdGlvbkV4cGxvcmVyU2V0dGluZ3MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdUcmFuc2Zvcm1hdGlvbkV4cGxvcmVyU2V0dGluZ3MnLFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJ0cmFuc2Zvcm1lci1zZXR0aW5nc1wifSwgXG4gICAgICAgICAgICBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgICAgIFwiIE1vZGU6IFwiLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoIHt2YWx1ZTp0aGlzLmdldE1vZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuY2hhbmdlTW9kZX0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJpbnRlcmFjdGl2ZSxkeW5hbWljXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEV4cGxvcmF0aW9uIHdpdGggdGV4dCBcIlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJpbnRlcmFjdGl2ZSxzdGF0aWNcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgRXhwbG9yYXRpb24gd2l0aG91dCB0ZXh0IFwiXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImR5bmFtaWMsaW50ZXJhY3RpdmVcIn0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgRm9ybWFsIHdpdGggbW92ZW1lbnQgXCJcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwic3RhdGljLGludGVyYWN0aXZlXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEZvcm1hbCB3aXRob3V0IG1vdmVtZW50IFwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS51bChudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5saShudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uYihudWxsLCBcIkV4cGxvcmF0aW9uOlwiKSwgXCIgU3R1ZGVudHMgY3JlYXRlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJhbnNmb3JtYXRpb25zIHdpdGggdG9vbHMgb24gdGhlIGdyYXBoLiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5saShudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00uYihudWxsLCBcIkZvcm1hbCB3aXRoIG1vdmVtZW50OlwiKSwgXCIgU3R1ZGVudHMgc3BlY2lmeSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zZm9ybWF0aW9ucyBtYXRoZW1hdGljYWxseSBpbiB0aGUgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2Zvcm1hdGlvbiBsaXN0LiBHcmFwaCBzaG93cyB0aGUgcmVzdWx0cyBvZiBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRoZXNlIHRyYW5zZm9ybWF0aW9ucy4gXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5ET00ubGkobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLmIobnVsbCwgXCJGb3JtYWwgd2l0aG91dCBtb3ZlbWVudDpcIiksIFwiIFN0dWRlbnRzIHNwZWNpZnkgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2Zvcm1hdGlvbnMgbWF0aGVtYXRpY2FsbHkgaW4gdGhlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJhbnNmb3JtYXRpb24gbGlzdC4gR3JhcGggZG9lcyBub3QgdXBkYXRlLiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFRvb2xTZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAgICAge25hbWU6XCJUcmFuc2xhdGlvbnNcIixcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6dGhpcy5wcm9wcy50b29scy50cmFuc2xhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dGaXhlZDpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5jaGFuZ2VIYW5kbGVyRm9yKFwidHJhbnNsYXRpb25cIil9ICksXG4gICAgICAgICAgICBUb29sU2V0dGluZ3MoXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOlwiUm90YXRpb25zXCIsXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOnRoaXMucHJvcHMudG9vbHMucm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuY2hhbmdlSGFuZGxlckZvcihcInJvdGF0aW9uXCIpfSApLFxuICAgICAgICAgICAgVG9vbFNldHRpbmdzKFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTpcIlJlZmxlY3Rpb25zXCIsXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOnRoaXMucHJvcHMudG9vbHMucmVmbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5jaGFuZ2VIYW5kbGVyRm9yKFwicmVmbGVjdGlvblwiKX0gKSxcbiAgICAgICAgICAgIFRvb2xTZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAgICAge25hbWU6XCJEaWxhdGlvbnNcIixcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6dGhpcy5wcm9wcy50b29scy5kaWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5jaGFuZ2VIYW5kbGVyRm9yKFwiZGlsYXRpb25cIil9ICksXG4gICAgICAgICAgICBQcm9wQ2hlY2tCb3goXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbDpcIkRyYXcgU29sdXRpb246XCIsXG4gICAgICAgICAgICAgICAgICAgIGRyYXdTb2x1dGlvblNoYXBlOnRoaXMucHJvcHMuZHJhd1NvbHV0aW9uU2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMucHJvcHMub25DaGFuZ2V9IClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmdyYXBoTW9kZSArIFwiLFwiICsgdGhpcy5wcm9wcy5saXN0TW9kZTtcbiAgICB9LFxuXG4gICAgY2hhbmdlTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgdmFyIG1vZGVzID0gc2VsZWN0ZWQuc3BsaXQoXCIsXCIpO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgZ3JhcGhNb2RlOiBtb2Rlc1swXSxcbiAgICAgICAgICAgIGxpc3RNb2RlOiBtb2Rlc1sxXVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY2hhbmdlSGFuZGxlckZvcjogZnVuY3Rpb24odG9vbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF8uYmluZChmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBuZXdUb29scyA9IF8uY2xvbmUodGhpcy5wcm9wcy50b29scyk7XG4gICAgICAgICAgICBuZXdUb29sc1t0b29sTmFtZV0gPSBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy50b29sc1t0b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSk7XG5cbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHRvb2xzOiBuZXdUb29sc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn0pO1xuXG5cbnZhciBUcmFuc2Zvcm1hdGlvbnNTaGFwZUVkaXRvciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1RyYW5zZm9ybWF0aW9uc1NoYXBlRWRpdG9yJyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgIEdyYXBoKFxuICAgICAgICAgICAgICAgIHtyZWY6XCJncmFwaFwiLFxuICAgICAgICAgICAgICAgIGJveDp0aGlzLnByb3BzLmdyYXBoLmJveCxcbiAgICAgICAgICAgICAgICByYW5nZTp0aGlzLnByb3BzLmdyYXBoLnJhbmdlLFxuICAgICAgICAgICAgICAgIGxhYmVsczp0aGlzLnByb3BzLmdyYXBoLmxhYmVscyxcbiAgICAgICAgICAgICAgICBzdGVwOnRoaXMucHJvcHMuZ3JhcGguc3RlcCxcbiAgICAgICAgICAgICAgICBncmlkU3RlcDp0aGlzLnByb3BzLmdyYXBoLmdyaWRTdGVwLFxuICAgICAgICAgICAgICAgIG1hcmtpbmdzOnRoaXMucHJvcHMuZ3JhcGgubWFya2luZ3MsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOnRoaXMucHJvcHMuZ3JhcGguYmFja2dyb3VuZEltYWdlLFxuICAgICAgICAgICAgICAgIG9uTmV3R3JhcGhpZTp0aGlzLnNldHVwR3JhcGhpZX0gKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6XCJ0eXBlLXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTp0aGlzLmdldFR5cGVTdHJpbmcodGhpcy5wcm9wcy5zaGFwZS50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5jaGFuZ2VUeXBlfSAsIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcInBvbHlnb24tM1wifSwgXCJUcmlhbmdsZVwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJwb2x5Z29uLTRcIn0sIFwiUXVhZHJpbGF0ZXJhbFwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJwb2x5Z29uLTVcIn0sIFwiUGVudGFnb25cIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwicG9seWdvbi02XCJ9LCBcIkhleGFnb25cIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwibGluZVwifSwgXCJMaW5lXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImxpbmUsbGluZVwifSwgXCIyIGxpbmVzXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oIHt2YWx1ZTpcImxpbmVTZWdtZW50XCJ9LCBcIkxpbmUgc2VnbWVudFwiKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKCB7dmFsdWU6XCJsaW5lU2VnbWVudCxsaW5lU2VnbWVudFwifSwgXG4gICAgICAgICAgICAgICAgICAgIFwiIDIgbGluZSBzZWdtZW50cyBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiYW5nbGVcIn0sIFwiQW5nbGVcIiksXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbigge3ZhbHVlOlwiY2lyY2xlXCJ9LCBcIkNpcmNsZVwiKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKiBSZXR1cm4gdGhlIG9wdGlvbiBzdHJpbmcgZm9yIGEgZ2l2ZW4gdHlwZSAqL1xuICAgIGdldFR5cGVTdHJpbmc6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHR5cGUsIHRoaXMuZ2V0VHlwZVN0cmluZykuam9pbihcIixcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tXCIgKyB0aGlzLnByb3BzLnNoYXBlLmNvb3Jkcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBDaGFuZ2UgdGhlIHR5cGUgb24gdGhlIHdpbmRvdyBldmVudCBlXG4gICAgICpcbiAgICAgKiBlLnRhcmdldC52YWx1ZSBpcyB0aGUgbmV3IHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgY2hhbmdlVHlwZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdHlwZXMgPSBTdHJpbmcoZS50YXJnZXQudmFsdWUpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgdmFyIHBvaW50Q291bnQgPSBhcnJheVN1bShfLm1hcChcbiAgICAgICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgICAgICBTaGFwZVR5cGVzLmdldFBvaW50Q291bnRGb3JUeXBlXG4gICAgICAgICkpO1xuXG4gICAgICAgIHZhciByYWRpdXMgPSBzY2FsZVRvUmFuZ2UoNCwgdGhpcy5yZWZzLmdyYXBoLnByb3BzLnJhbmdlKTtcbiAgICAgICAgdmFyIG9mZnNldCA9ICgxIC8gMiAtIDEgLyBwb2ludENvdW50KSAqIDE4MDtcbiAgICAgICAgdmFyIGNvb3JkcyA9IF8udGltZXMocG9pbnRDb3VudCwgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgcmV0dXJuIEtoYW5VdGlsLmtwb2ludC5yb3RhdGVEZWcoW3JhZGl1cywgMF0sXG4gICAgICAgICAgICAgICAgMzYwICogaSAvIHBvaW50Q291bnQgKyBvZmZzZXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZXMsXG4gICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogU2hhcGVUeXBlcy5kZWZhdWx0T3B0aW9ucyh0eXBlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzKSB7XG4gICAgICAgIGlmICghZGVlcEVxKHByZXZQcm9wcy5zaGFwZSwgdGhpcy5wcm9wcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcy5ncmFwaC5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgc2hhcGU6IHRoaXMuc2hhcGUudG9KU09OKClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldHVwR3JhcGhpZTogZnVuY3Rpb24oZ3JhcGhpZSkge1xuICAgICAgICB0aGlzLnNoYXBlID0gU2hhcGVUeXBlcy5hZGRNb3ZhYmxlU2hhcGUoZ3JhcGhpZSwge1xuICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBzbmFwOiBncmFwaGllLnNuYXAsXG4gICAgICAgICAgICBzaGFwZTogdGhpcy5wcm9wcy5zaGFwZSxcbiAgICAgICAgICAgIG9uTW92ZUVuZDogdGhpcy51cGRhdGVDb29yZHNcbiAgICAgICAgfSk7XG4gICAgfSxcblxufSk7XG5cbnZhciBUcmFuc2Zvcm1hdGlvbkxpc3RJdGVtID0gVHJhbnNmb3JtT3BzLkxpc3RJdGVtO1xuXG52YXIgVHJhbnNmb3JtYXRpb25MaXN0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnVHJhbnNmb3JtYXRpb25MaXN0JyxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb2RlID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuRE9NLnNwYW4obnVsbCApOyAgLy8gZG9uJ3QgcmVuZGVyIGFueXRoaW5nXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uTGlzdCA9IF8ubWFwKFxuICAgICAgICAgICAgdGhpcy5wcm9wcy50cmFuc2Zvcm1hdGlvbnMsXG4gICAgICAgICAgICBmdW5jdGlvbih0cmFuc2Zvcm0sIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtYXRpb25MaXN0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVmOlwidHJhbnNmb3JtYXRpb25cIiArIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OlwidHJhbnNmb3JtYXRpb25cIiArIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOnRoaXMucHJvcHMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmhhbmRsZUNoYW5nZX0gKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJwZXJzZXVzLXRyYW5zZm9ybWF0aW9uLWxpc3RcIn0sIFxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbkxpc3RcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy50aW1lcyh0aGlzLnByb3BzLnRyYW5zZm9ybWF0aW9ucy5sZW5ndGgsIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnNbXCJ0cmFuc2Zvcm1hdGlvblwiICsgaV0udmFsdWUoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy52YWx1ZSgpKTtcbiAgICB9LFxuXG4gICAgZm9jdXNMYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtYXRpb25MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgXy5sYXN0KHRoaXMudHJhbnNmb3JtYXRpb25MaXN0KS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBUb29sQnV0dG9uID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnVG9vbEJ1dHRvbicsXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLnByb3BzLnRvZ2dsZWQgP1xuICAgICAgICAgICAgXCJzaW1wbGUtYnV0dG9uIGV4ZXJjaXNlLW9yYW5nZSB0b2dnbGVkIGhpZ2hsaWdodGVkLXRvb2wtYnV0dG9uXCIgOlxuICAgICAgICAgICAgXCJzaW1wbGUtYnV0dG9uXCI7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LkRPTS5idXR0b24oXG4gICAgICAgICAgICAgICAge3R5cGU6XCJidXR0b25cIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6Y2xhc3NlcyxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOnRoaXMucHJvcHMub25DbGlja30sIFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG52YXIgVG9vbHNCYXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdUb29sc0JhcicsXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBudWxsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b29scyA9IF8ubWFwKFRyYW5zZm9ybWF0aW9ucywgZnVuY3Rpb24odG9vbCwgdHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlZFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUb29sQnV0dG9uKFxuICAgICAgICAgICAgICAgICAgICAgICAge2tleTp0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlZDp0aGlzLnN0YXRlLnNlbGVjdGVkID09PSB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazpfLmJpbmQodGhpcy5jaGFuZ2VTZWxlY3RlZCwgdGhpcywgdHlwZSl9LCBcbiAgICAgICAgICAgICAgICAgICAgdG9vbC52ZXJiTmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwidHJhbnNmb3JtZXItdG9vbHMtYmFyXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwic2ltcGxlLWJ1dHRvbi1ncm91cFwifSwgXG4gICAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBSZWFjdC5ET00uYnV0dG9uKFxuICAgICAgICAgICAgICAgICAgICB7Y2xhc3NOYW1lOlwidHJhbnNmb3JtZXItdW5kby1idXR0b24gc2ltcGxlLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOlwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6dGhpcy5wcm9wcy5vblVuZG9DbGlja30sIFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKCB7Y2xhc3NOYW1lOlwiaWNvbi11bmRvXCJ9ICksXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCIgVW5kbyBcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoIHtjbGFzc05hbWU6XCJjbGVhclwifSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgY2hhbmdlU2VsZWN0ZWQ6IGZ1bmN0aW9uKHRvb2wpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5yZW1vdmVUb29sKHRoaXMuc3RhdGUuc2VsZWN0ZWQpO1xuXG4gICAgICAgIGlmICghdG9vbCB8fCB0b29sID09PSB0aGlzLnN0YXRlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmFkZFRvb2wodG9vbCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogdG9vbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIEFkZFRyYW5zZm9ybUJhciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ0FkZFRyYW5zZm9ybUJhcicsXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRvb2xzID0gXy5tYXAoVHJhbnNmb3JtYXRpb25zLCBmdW5jdGlvbih0b29sLCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbmFibGVkW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRvb2xCdXR0b24oXG4gICAgICAgICAgICAgICAgICAgICAgICB7a2V5OnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVkOmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazpfLmJpbmQodGhpcy5jaGFuZ2VTZWxlY3RlZCwgdGhpcywgdHlwZSl9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJpY29uLXBsdXNcIn0gKSxcbiAgICAgICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2wubm91bk5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcInRyYW5zZm9ybWVyLXRvb2xzLWJhclwifSwgXG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5idXR0b24oXG4gICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6XCJ0cmFuc2Zvcm1lci11bmRvLWJ1dHRvbiBzaW1wbGUtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6XCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazp0aGlzLnByb3BzLm9uVW5kb0NsaWNrfSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuRE9NLnNwYW4oIHtjbGFzc05hbWU6XCJpY29uLXVuZG9cIn0gKSxcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIiBVbmRvIFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdigge2NsYXNzTmFtZTpcImNsZWFyXCJ9KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VTZWxlY3RlZDogZnVuY3Rpb24odG9vbCkge1xuICAgICAgICBpZiAodG9vbCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5hZGRUb29sKHRvb2wpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBUcmFuc2Zvcm1lciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogJ1RyYW5zZm9ybWVyJyxcbiAgICAvLyBUT0RPIChqYWNrKTogVGhlc2Ugc2hvdWxkIGJlIHJlZmFjdG9yZWQgaW50byBhIG5pY2Ugb2JqZWN0IGF0IHRoZSB0b3BcbiAgICAvLyBzbyB0aGF0IHdlIGRvbid0IGhhdmUgYWxsIHRoaXMgZHVwbGljYXRpb25cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5kZWZhdWx0cyh7XG4gICAgICAgICAgICBncmFwaDoge30sXG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnM6IFtdXG4gICAgICAgIH0sIGRlZmF1bHRUcmFuc2Zvcm1lclByb3BzKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRmlsbCBpbiBhbnkgbWlzc2luZyB2YWx1ZSBpbiB0aGlzLnByb3BzLmdyYXBoXG4gICAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBiZWNhdXNlIHRoZSBncmFwaCBqc29uIGRvZXNuJ3QgaW5jbHVkZVxuICAgICAgICAvLyBib3gsIGZvciBleGFtcGxlXG4gICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKFxuICAgICAgICAgICAgICAgIGRlZmF1bHRHcmFwaFByb3BzKHRoaXMucHJvcHMuZ3JhcGgsIGRlZmF1bHRCb3hTaXplKSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmdyYXBoXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGludGVyYWN0aXZlVG9vbHNNb2RlID0gdGhpcy5wcm9wcy5ncmFwaE1vZGUgPT09IFwiaW50ZXJhY3RpdmVcIjtcblxuICAgICAgICB2YXIgVG9vbHNCYXJDbGFzcyA9IGludGVyYWN0aXZlVG9vbHNNb2RlID9cbiAgICAgICAgICAgICAgICBUb29sc0JhciA6XG4gICAgICAgICAgICAgICAgQWRkVHJhbnNmb3JtQmFyO1xuXG4gICAgICAgIC8vIFRoaXMgc3R5bGUgaXMgYXBwbGllZCBpbmxpbmUgYmVjYXVzZSBpdCBpcyBkZXBlbmRlbnQgb24gdGhlXG4gICAgICAgIC8vIHNpemUgb2YgdGhlIGdyYXBoIGFzIHNldCBieSB0aGUgZ3JhcGguYm94IHByb3AsIGFuZCB0aGlzIGFsc29cbiAgICAgICAgLy8gbGV0cyB1cyBzcGVjaWZ5IGl0IGluIHRoZSBzYW1lIHBsYWNlIHRoZSBncmFwaCdzIHdpZHRoIGlzXG4gICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgdmFyIHRvb2xzQmFyID0gUmVhY3QuRE9NLmRpdigge3N0eWxlOnt3aWR0aDogZ3JhcGguYm94WzBdfX0sIFxuICAgICAgICAgICAgVG9vbHNCYXJDbGFzcyhcbiAgICAgICAgICAgICAgICB7cmVmOlwidG9vbHNCYXJcIixcbiAgICAgICAgICAgICAgICBlbmFibGVkOnBsdWNrT2JqZWN0KHRoaXMucHJvcHMudG9vbHMsIFwiZW5hYmxlZFwiKSxcbiAgICAgICAgICAgICAgICBhZGRUb29sOnRoaXMuYWRkVG9vbCxcbiAgICAgICAgICAgICAgICByZW1vdmVUb29sOnRoaXMucmVtb3ZlVG9vbCxcbiAgICAgICAgICAgICAgICBvblVuZG9DbGljazp0aGlzLmhhbmRsZVVuZG9DbGlja30gKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KCB7Y2xhc3NOYW1lOlwicGVyc2V1cy13aWRnZXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJwZXJzZXVzLXdpZGdldC10cmFuc2Zvcm1lclwifSwgXG4gICAgICAgICAgICBHcmFwaChcbiAgICAgICAgICAgICAgICB7cmVmOlwiZ3JhcGhcIixcbiAgICAgICAgICAgICAgICBib3g6Z3JhcGguYm94LFxuICAgICAgICAgICAgICAgIHJhbmdlOmdyYXBoLnJhbmdlLFxuICAgICAgICAgICAgICAgIGxhYmVsczpncmFwaC5sYWJlbHMsXG4gICAgICAgICAgICAgICAgc3RlcDpncmFwaC5zdGVwLFxuICAgICAgICAgICAgICAgIGdyaWRTdGVwOmdyYXBoLmdyaWRTdGVwLFxuICAgICAgICAgICAgICAgIG1hcmtpbmdzOmdyYXBoLm1hcmtpbmdzLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTpncmFwaC5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgICAgICAgICAgc2hvd1Byb3RyYWN0b3I6Z3JhcGguc2hvd1Byb3RyYWN0b3IsXG4gICAgICAgICAgICAgICAgb25OZXdHcmFwaGllOnRoaXMuc2V0dXBHcmFwaGllfSApLFxuXG4gICAgICAgICAgICAhaW50ZXJhY3RpdmVUb29sc01vZGUgJiYgKFxuICAgICAgICAgICAgICAgIFwiQWRkIHRyYW5zZm9ybWF0aW9ucyBiZWxvdzpcIlxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgdGhpcy5wcm9wcy5ncmFwaE1vZGUgPT09IFwic3RhdGljXCIgJiYgW1xuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5icigge2tleTpcInN0YXRpYy1iclwifSApLFxuICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5lbSgge2tleTpcInN0YXRpYy1ub21vdmVcIn0sIFxuICAgICAgICAgICAgICAgICAgICBcIiBOb3RlOiBGb3IgdGhpcyBxdWVzdGlvbiwgdGhlIHNoYXBlIHdpbGwgbm90IG1vdmUuIFwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSxcblxuICAgICAgICAgICAgaW50ZXJhY3RpdmVUb29sc01vZGUgJiYgdG9vbHNCYXIsXG5cbiAgICAgICAgICAgIFRyYW5zZm9ybWF0aW9uTGlzdChcbiAgICAgICAgICAgICAgICB7cmVmOlwidHJhbnNmb3JtYXRpb25MaXN0XCIsXG4gICAgICAgICAgICAgICAgbW9kZTp0aGlzLnByb3BzLmxpc3RNb2RlLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uczp0aGlzLnByb3BzLnRyYW5zZm9ybWF0aW9ucyxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnNldFRyYW5zZm9ybWF0aW9uUHJvcHN9ICksXG5cbiAgICAgICAgICAgICFpbnRlcmFjdGl2ZVRvb2xzTW9kZSAmJiB0b29sc0JhclxuXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNldHVwR3JhcGhpZSh0aGlzLnByb3BzLCBwcmV2UHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnMuZ3JhcGgucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVlcEVxKHRoaXMucHJvcHMudHJhbnNmb3JtYXRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1hdGlvbnModGhpcy5wcm9wcy50cmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNob3VsZFNldHVwR3JhcGhpZTogZnVuY3Rpb24obmV4dFByb3BzLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKCFkZWVwRXEocHJldlByb3BzLnN0YXJ0aW5nLCBuZXh0UHJvcHMuc3RhcnRpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2UHJvcHMuZ3JhcGhNb2RlICE9PSBuZXh0UHJvcHMuZ3JhcGhNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2UHJvcHMubGlzdE1vZGUgIT09IG5leHRQcm9wcy5saXN0TW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldlByb3BzLmRyYXdTb2x1dGlvblNoYXBlICE9PVxuICAgICAgICAgICAgICAgIG5leHRQcm9wcy5kcmF3U29sdXRpb25TaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFByb3BzLmRyYXdTb2x1dGlvblNoYXBlICYmICFkZWVwRXEoXG4gICAgICAgICAgICAgICAgcHJldlByb3BzLmNvcnJlY3Quc2hhcGUsIG5leHRQcm9wcy5jb3JyZWN0LnNoYXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcSh0aGlzLnRvb2xzLCBuZXh0UHJvcHMudG9vbHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBncmFwaGllOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5ncmFwaC5ncmFwaGllKCk7XG4gICAgfSxcblxuICAgIHNldHVwR3JhcGhpZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgZ3JhcGhpZSA9IHRoaXMuZ3JhcGhpZSgpO1xuXG4gICAgICAgIC8vIEEgYmFja2dyb3VuZCBpbWFnZSBvZiBvdXIgc29sdXRpb246XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRyYXdTb2x1dGlvblNoYXBlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jb3JyZWN0LnNoYXBlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jb3JyZWN0LnNoYXBlLmNvb3Jkcykge1xuICAgICAgICAgICAgU2hhcGVUeXBlcy5hZGRTaGFwZShncmFwaGllLCB7XG4gICAgICAgICAgICAgICAgZml4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hhcGU6IHNlbGYucHJvcHMuY29ycmVjdC5zaGFwZSxcbiAgICAgICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IEtoYW5VdGlsLkdSQVksXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRUb29sID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZzLnRvb2xzQmFyLmNoYW5nZVNlbGVjdGVkKG51bGwpO1xuICAgICAgICB0aGlzLmFkZFRyYW5zZm9ybWVyU2hhcGUodGhpcy5wcm9wcy5zdGFydGluZy5zaGFwZSxcbiAgICAgICAgICAgICAgICAvKiB0cmFuc2xhdGFibGUgKi8gZmFsc2UpO1xuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybWF0aW9ucyh0aGlzLnByb3BzLnRyYW5zZm9ybWF0aW9ucyk7XG5cbiAgICAgICAgLy8gU2F2ZSBhIGNvcHkgb2Ygb3VyIHRvb2xzIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGZ1dHVyZVxuICAgICAgICAvLyB0aGlzLnByb3BzLnRvb2xzIGNoYW5nZXMgYWdhaW5zdCB0aGVtXG4gICAgICAgIC8vIFRoaXMgc2VlbXMgd2VpcmQsIGJ1dCBnaXZlcyB1cyBhbiBlYXN5IHdheSB0byB0ZWxsIHdoZXRoZXJcbiAgICAgICAgLy8gcHJvcHMgY2hhbmdlcyB3ZXJlIHNlbGYtaW5mbGljdGVkIChmb3Igd2hpY2ggYSBncmFwaGllIHJlc2V0XG4gICAgICAgIC8vIGlzIG5vdCByZXF1aXJlZCwgYW5kIGlzIGluIGZhY3QgYSBiYWQgaWRlYSByaWdodCBub3cgYmVjYXVzZVxuICAgICAgICAvLyBvZiByZXNldHRpbmcgdGhlIHNpemUgb2YgdGhlIGRpbGF0aW9uIHRvb2wpLlxuICAgICAgICAvLyBUT0RPIChqYWNrKTogQSBkZWVwQ2xvbmUgbWV0aG9kIHdvdWxkIGJlIG5pY2UgaGVyZVxuICAgICAgICB0aGlzLnRvb2xzID0ge1xuICAgICAgICAgICAgdHJhbnNsYXRpb246IF8uY2xvbmUodGhpcy5wcm9wcy50b29scy50cmFuc2xhdGlvbiksXG4gICAgICAgICAgICByb3RhdGlvbjogXy5jbG9uZSh0aGlzLnByb3BzLnRvb2xzLnJvdGF0aW9uKSxcbiAgICAgICAgICAgIHJlZmxlY3Rpb246IF8uY2xvbmUodGhpcy5wcm9wcy50b29scy5yZWZsZWN0aW9uKSxcbiAgICAgICAgICAgIGRpbGF0aW9uOiBfLmNsb25lKHRoaXMucHJvcHMudG9vbHMuZGlsYXRpb24pXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qIEFwcGxpZXMgYWxsIHRyYW5zZm9ybWF0aW9ucyBpbiBgdHJhbnNmb3JtYXRpb25zYFxuICAgICAqIHRvIHRoZSBzdGFydGluZyBzaGFwZSwgYW5kIHVwZGF0ZXMgdGhpcy50cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiB0byByZWZsZWN0IHRoaXNcbiAgICAgKlxuICAgICAqIFVzdWFsbHkgY2FsbGVkIHdpdGggdGhpcy5wcm9wcy50cmFuc2Zvcm1hdGlvbnNcbiAgICAgKi9cbiAgICBzZXRUcmFuc2Zvcm1hdGlvbnM6IGZ1bmN0aW9uKHRyYW5zZm9ybWF0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0Q29vcmRzKCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zID0gXy5jbG9uZSh0cmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgICBfLmVhY2godGhpcy50cmFuc2Zvcm1hdGlvbnMsIHRoaXMuYXBwbHlUcmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICAvLyB0aGUgcG9seWdvbiB0aGF0IHdlIHRyYW5zZm9ybVxuICAgIGFkZFRyYW5zZm9ybWVyU2hhcGU6IGZ1bmN0aW9uKHNoYXBlLCB0cmFuc2xhdGFibGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHRoaXMuZ3JhcGhpZSgpO1xuXG4gICAgICAgIHRoaXMuc2hhcGUgPSBTaGFwZVR5cGVzLmFkZE1vdmFibGVTaGFwZShncmFwaGllLCB7XG4gICAgICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93UG9pbnRzOiAodGhpcy5wcm9wcy5ncmFwaE1vZGUgIT09IFwic3RhdGljXCIpLFxuICAgICAgICAgICAgdHJhbnNsYXRhYmxlOiB0cmFuc2xhdGFibGUsXG4gICAgICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIChkWCwgZFkpIHtcbiAgICAgICAgICAgICAgICBkWCA9IEtoYW5VdGlsLnJvdW5kVG9OZWFyZXN0KGdyYXBoaWUuc25hcFswXSwgZFgpO1xuICAgICAgICAgICAgICAgIGRZID0gS2hhblV0aWwucm91bmRUb05lYXJlc3QoZ3JhcGhpZS5zbmFwWzFdLCBkWSk7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRUcmFuc2Zvcm0oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRyYW5zbGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHZlY3RvcjogW2RYLCBkWV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2RYLCBkWV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRTdHlsZToge1xuICAgICAgICAgICAgICAgIGZpbGw6ICh0cmFuc2xhdGFibGUgPyBLaGFuVXRpbC5PUkFOR0UgOiBLaGFuVXRpbC5CTFVFKSxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICh0cmFuc2xhdGFibGUgPyBLaGFuVXRpbC5PUkFOR0UgOiBLaGFuVXRpbC5CTFVFKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYWRkVG9vbDogZnVuY3Rpb24odG9vbElkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5ncmFwaE1vZGUgPT09IFwiaW50ZXJhY3RpdmVcIikge1xuICAgICAgICAgICAgaWYgKHRvb2xJZCA9PT0gXCJ0cmFuc2xhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VG9vbCA9IHRoaXMuYWRkVHJhbnNsYXRpb25Ub29sKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvb2xJZCA9PT0gXCJyb3RhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VG9vbCA9IHRoaXMuYWRkUm90YXRpb25Ub29sKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvb2xJZCA9PT0gXCJyZWZsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUb29sID0gdGhpcy5hZGRSZWZsZWN0aW9uVG9vbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b29sSWQgPT09IFwiZGlsYXRpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRvb2wgPSB0aGlzLmFkZERpbGF0aW9uVG9vbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRvb2wgaWQ6IFwiICsgdG9vbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm07XG4gICAgICAgICAgICBpZiAodG9vbElkID09PSBcInRyYW5zbGF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xJZCxcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yOiBbbnVsbCwgbnVsbF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b29sSWQgPT09IFwicm90YXRpb25cIikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbElkLFxuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFtudWxsLCBudWxsXSxcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVEZWc6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b29sSWQgPT09IFwicmVmbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVmbGVjdGlvbnMgd2l0aCBudWxscyBpbiB0aGVtIHdvbid0IGJlIGFwcGxpZWQgdW50aWxcbiAgICAgICAgICAgICAgICAvLyBmaWxscyBpbiB0aGUgYmxhbmtzXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b29sSWQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IFtbbnVsbCwgbnVsbF0sIFtudWxsLCBudWxsXV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b29sSWQgPT09IFwiZGlsYXRpb25cIikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbElkLFxuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFtudWxsLCBudWxsXSxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRvb2wgaWQ6IFwiICsgdG9vbElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kb1RyYW5zZm9ybSh0cmFuc2Zvcm0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVmcy50cmFuc2Zvcm1hdGlvbkxpc3QuZm9jdXNMYXN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVUb29sOiBmdW5jdGlvbih0b29sSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRvb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRvb2wucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50VG9vbCA9IG51bGw7XG4gICAgfSxcblxuICAgIGFkZFRyYW5zbGF0aW9uVG9vbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zaGFwZS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2Zvcm1lclNoYXBlKHRoaXMuc2hhcGUudG9KU09OKCksXG4gICAgICAgICAgICAgICAgLyogdHJhbnNsYXRhYmxlICovIHRydWUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hhcGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRUcmFuc2Zvcm1lclNoYXBlKHNlbGYuc2hhcGUudG9KU09OKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiB0cmFuc2xhdGFibGUgKi8gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBTbmFwcyBhIGNvb3JkIHRvIHRoaXMuZ3JhcGhpZSgpJ3Mgc25hcFxuICAgIHNuYXBDb29yZDogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgdmFyIGdyYXBoaWUgPSB0aGlzLmdyYXBoaWUoKTtcbiAgICAgICAgcmV0dXJuIF8ubWFwKGNvb3JkLCBmdW5jdGlvbiAodmFsLCBkaW0pIHtcbiAgICAgICAgICAgIHJldHVybiBLaGFuVXRpbC5yb3VuZFRvTmVhcmVzdChncmFwaGllLnNuYXBbZGltXSwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgY29vcmRzIGludG8gc29tZXRoaW5nIHRoYXQgZml0cyB0aGUgbmV3IDQ1IGRlZ3JlZVxuICAgIC8vIHJlZmxlY3Rpb24gbGluZS5cbiAgICBub3JtYWxpemVSZWZsZWN0aW9uQ29vcmRzOiBmdW5jdGlvbihtZXNzeUNvb3Jkcykge1xuICAgICAgICB2YXIgbWlkcG9pbnQgPSB0aGlzLnNuYXBDb29yZChrbGluZS5taWRwb2ludChtZXNzeUNvb3JkcykpO1xuICAgICAgICB2YXIgb3JpZ0RpcmVjdGlvblBvbGFyID0ga3ZlY3Rvci5wb2xhckRlZ0Zyb21DYXJ0KFxuICAgICAgICAgICAga3ZlY3Rvci5zdWJ0cmFjdChtZXNzeUNvb3Jkc1swXSwgbWVzc3lDb29yZHNbMV0pXG4gICAgICAgICk7XG4gICAgICAgIHZhciBkaXJlY3Rpb25Qb2xhciA9IFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBLaGFuVXRpbC5yb3VuZFRvTmVhcmVzdCg0NSwgb3JpZ0RpcmVjdGlvblBvbGFyWzFdKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0ga3ZlY3Rvci5jYXJ0RnJvbVBvbGFyRGVnKGRpcmVjdGlvblBvbGFyKTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IF8ubWFwKFstMSwgMV0sIGZ1bmN0aW9uKGRpcmVjdGlvbkNvZWZmaWNpZW50KSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSBrdmVjdG9yLmFkZChcbiAgICAgICAgICAgICAgICBtaWRwb2ludCxcbiAgICAgICAgICAgICAgICBrdmVjdG9yLnNjYWxlKFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbkNvZWZmaWNpZW50ICpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVUb0N1cnJlbnRSYW5nZShSRUZMRUNUX1JPVEFURV9IQU5ETEVfRElTVClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc25hcENvb3JkKGNvb3JkKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSxcblxuICAgIGFkZFJlZmxlY3Rpb25Ub29sOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLnByb3BzLnRvb2xzLnJlZmxlY3Rpb247XG4gICAgICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHRoaXMucmVmcy5ncmFwaC5ncmFwaGllKCk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVJlZmxlY3Rpb25Ub29sID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNoYW5nZVRvb2woXCJyZWZsZWN0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBjb29yZHM6IF8ucGx1Y2socmVmbGVjdFBvaW50cywgXCJjb29yZFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMubm9ybWFsaXplUmVmbGVjdGlvbkNvb3JkcyhvcHRpb25zLmNvb3Jkcyk7XG5cbiAgICAgICAgLy8gVGhlIHBvaW50cyBkZWZpbmluZyB0aGUgbGluZSBvZiByZWZsZWN0aW9uOyBoaWRkZW4gZnJvbSB0aGVcbiAgICAgICAgLy8gdXNlci5cbiAgICAgICAgdmFyIHJlZmxlY3RQb2ludHMgPSBfLm1hcChjb29yZHMsIGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9pbnQoe1xuICAgICAgICAgICAgICAgIGNvb3JkOiBjb29yZCxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIHRoZSBsaW5lIG9mIHJlZmxlY3Rpb25cbiAgICAgICAgLy8gVE9ETyhqYWNrKTogZ3JhcGhpZS5zdHlsZSBoZXJlIGlzIGEgaGFjayB0byBwcmV2ZW50IHRoZSBkYXNoZWRcbiAgICAgICAgLy8gc3R5bGUgZnJvbSBsZWFraW5nIGludG8gdGhlIHJlc3Qgb2YgdGhlIHNoYXBlcy4gUmVtb3ZlIHdoZW5cbiAgICAgICAgLy8gZ3JhcGhpZS5hZGRNb3ZhYmxlTGluZVNlZ21lbnQgZG9lc24ndCBsZWFrIHN0eWxlcyBhbnltb3JlLlxuICAgICAgICB2YXIgcmVmbGVjdExpbmU7XG4gICAgICAgIGdyYXBoaWUuc3R5bGUoe30sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVmbGVjdExpbmUgPSBncmFwaGllLmFkZE1vdmFibGVMaW5lU2VnbWVudCh7XG4gICAgICAgICAgICAgICAgZml4ZWQ6IG9wdGlvbnMuY29uc3RyYWludHMuZml4ZWQsXG4gICAgICAgICAgICAgICAgY29uc3RyYWludHM6IG9wdGlvbnMuY29uc3RyYWludHMsXG4gICAgICAgICAgICAgICAgcG9pbnRBOiByZWZsZWN0UG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgIHBvaW50WjogcmVmbGVjdFBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICBzbmFwWDogZ3JhcGhpZS5zbmFwWzBdLFxuICAgICAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBub3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVwiOiAob3B0aW9ucy5jb25zdHJhaW50cy5maXhlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS2hhblV0aWwuR1JBWSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS2hhblV0aWwuT1JBTkdFXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDIsXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcIi0gXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IEtoYW5VdGlsLk9SQU5HRSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IFwiLSBcIiAvLyBUT0RPKGphY2spIHNvbGlkIGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgaGVyZSwgYnV0IHdvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuaWNlclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW92ZVBvaW50c1dpdGhMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uTW92ZUVuZDogdXBkYXRlUmVmbGVjdGlvblRvb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGUgXCJidXR0b25cIiBwb2ludCBpbiB0aGUgY2VudGVyIG9mIHRoZSBsaW5lIG9mIHJlZmxlY3Rpb25cbiAgICAgICAgdmFyIHJlZmxlY3RCdXR0b24gPSBncmFwaGllLmFkZFJlZmxlY3RCdXR0b24oe1xuICAgICAgICAgICAgZml4ZWQ6IG9wdGlvbnMuY29uc3RyYWludHMuZml4ZWQsXG4gICAgICAgICAgICBsaW5lOiByZWZsZWN0TGluZSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMuc2NhbGVUb0N1cnJlbnRSYW5nZShSRUZMRUNUX0JVVFRPTl9TSVpFKSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9UcmFuc2Zvcm0oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlZmxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgbGluZTogXy5wbHVjayhyZWZsZWN0UG9pbnRzLCBcImNvb3JkXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZmxlY3RSb3RhdGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxpcCB0aGUgcm90YXRpb24gaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgIHJlZmxlY3RSb3RhdGVIYW5kbGUuc2V0Q29vcmQoa3ZlY3Rvci5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZWN0QnV0dG9uLmNvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAga3ZlY3Rvci5zdWJ0cmFjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZsZWN0QnV0dG9uLmNvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxlY3RSb3RhdGVIYW5kbGUuY29vcmRcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZmxlY3RSb3RhdGVIYW5kbGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBLaGFuVXRpbC5PUkFOR0UsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMixcbiAgICAgICAgICAgICAgICBmaWxsOiBLaGFuVXRpbC5PUkFOR0VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWdobGlnaHRTdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogS2hhblV0aWwuT1JBTkdFLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDMsXG4gICAgICAgICAgICAgICAgZmlsbDogS2hhblV0aWwuT1JBTkdFXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Nb3ZlRW5kOiB1cGRhdGVSZWZsZWN0aW9uVG9vbFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVmbGVjdFJvdGF0ZUhhbmRsZSA9IG51bGw7XG4gICAgICAgIGlmICghb3B0aW9ucy5jb25zdHJhaW50cy5maXhlZCkge1xuICAgICAgICAgICAgLy8gVGhlIHJvdGF0aW9uIGhhbmRsZSBmb3Igcm90YXRpbmcgdGhlIGxpbmUgb2YgcmVmbGVjdGlvblxuICAgICAgICAgICAgdmFyIGluaXRSb3RhdGVIYW5kbGVBbmdsZSA9IGt2ZWN0b3IucG9sYXJEZWdGcm9tQ2FydChcbiAgICAgICAgICAgICAgICBrdmVjdG9yLnN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICByZWZsZWN0UG9pbnRzWzFdLmNvb3JkLFxuICAgICAgICAgICAgICAgICAgICByZWZsZWN0UG9pbnRzWzBdLmNvb3JkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVsxXSArIDkwOyAvLyA5MCBkZWdyZWVzIG9mZiBvZiB0aGUgbGluZVxuICAgICAgICAgICAgcmVmbGVjdFJvdGF0ZUhhbmRsZSA9IGdyYXBoaWUuYWRkUm90YXRlSGFuZGxlKHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IHJlZmxlY3RCdXR0b24sXG4gICAgICAgICAgICAgICAgcmFkaXVzOiB0aGlzLnNjYWxlVG9DdXJyZW50UmFuZ2UoUkVGTEVDVF9ST1RBVEVfSEFORExFX0RJU1QpLFxuICAgICAgICAgICAgICAgIGFuZ2xlRGVnOiBpbml0Um90YXRlSGFuZGxlQW5nbGUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc2NhbGVUb0N1cnJlbnRSYW5nZSgwLjI0KSxcbiAgICAgICAgICAgICAgICBob3ZlcldpZHRoOiB0aGlzLnNjYWxlVG9DdXJyZW50UmFuZ2UoMC40KSxcbiAgICAgICAgICAgICAgICBsZW5ndGhBbmdsZTogMTcsXG4gICAgICAgICAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbihuZXdBbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gS2hhblV0aWwucm91bmRUb05lYXJlc3QoNDUsIG5ld0FuZ2xlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uTW92ZUVuZDogdXBkYXRlUmVmbGVjdGlvblRvb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgcmVmbGVjdEJ1dHRvbiBhbmQgcmVmbGVjdFJvdGF0ZUhhbmRsZSB3aXRoIHRoZSBsaW5lXG4gICAgICAgICQocmVmbGVjdExpbmUpLm9uKFwibW92ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVmbGVjdEJ1dHRvbi51cGRhdGUoKTtcbiAgICAgICAgICAgICQocmVmbGVjdEJ1dHRvbikudHJpZ2dlcihcIm1vdmVcIik7IC8vIHVwZGF0ZSB0aGUgcm90YXRpb24gaGFuZGxlLFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXRjaGVzIGZvciB0aGlzIGluIGtlL3V0aWxzL2ludGVyYWN0aXZlLmpzLlxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGxpbmUgYW5kIHJlZmxlY3QgYnV0dG9uIHdoZW4gdGhlIHJlZmxlY3RSb3RhdGVIYW5kbGUgaXNcbiAgICAgICAgLy8gcm90YXRlZFxuICAgICAgICBpZiAocmVmbGVjdFJvdGF0ZUhhbmRsZSkge1xuICAgICAgICAgICAgJChyZWZsZWN0Um90YXRlSGFuZGxlKS5vbihcIm1vdmVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZUhhbmRsZUFwcHJveCA9IHNlbGYuc25hcENvb3JkKFxuICAgICAgICAgICAgICAgICAgICByZWZsZWN0Um90YXRlSGFuZGxlLmNvb3JkXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVWZWN0b3IgPSBrdmVjdG9yLnN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICByb3RhdGVIYW5kbGVBcHByb3gsXG4gICAgICAgICAgICAgICAgICAgIHJlZmxlY3RCdXR0b24uY29vcmRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZsaXBwZWQgPSByZWZsZWN0QnV0dG9uLmlzRmxpcHBlZCgpID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgcmVmbGVjdFBvaW50c1tmbGlwcGVkXS5zZXRDb29yZChrdmVjdG9yLmFkZChcbiAgICAgICAgICAgICAgICAgICAgcmVmbGVjdEJ1dHRvbi5jb29yZCxcbiAgICAgICAgICAgICAgICAgICAga3ZlY3Rvci5yb3RhdGVEZWcocm90YXRlVmVjdG9yLCA5MClcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICByZWZsZWN0UG9pbnRzWzEgLSBmbGlwcGVkXS5zZXRDb29yZChrdmVjdG9yLmFkZChcbiAgICAgICAgICAgICAgICAgICAgcmVmbGVjdEJ1dHRvbi5jb29yZCxcbiAgICAgICAgICAgICAgICAgICAga3ZlY3Rvci5yb3RhdGVEZWcocm90YXRlVmVjdG9yLCAtOTApXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICByZWZsZWN0TGluZS50cmFuc2Zvcm0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmVmbGVjdEJ1dHRvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdEJ1dHRvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmbGVjdFJvdGF0ZUhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZsZWN0Um90YXRlSGFuZGxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWZsZWN0TGluZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICByZWZsZWN0UG9pbnRzWzBdLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHJlZmxlY3RQb2ludHNbMV0ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qIFNjYWxlcyBhIGRpc3RhbmNlIGZyb20gdGhlIGRlZmF1bHQgcmFuZ2Ugb2ZcbiAgICAgKiBbLTEwLCAxMF0gdG8gdGhlIGN1cnJlbnQgdGhpcy5wcm9wcy5ncmFwaC5yYW5nZVxuICAgICAqXG4gICAgICogVXNlZCBmb3Igc2l6aW5nIHZhcmlvdXMgdHJhbnNmb3JtYXRpb24gdG9vbHNcbiAgICAgKiAocm90YXRpb24gaGFuZGxlLCBkaWxhdGlvbiBjaXJjbGUpXG4gICAgICovXG4gICAgc2NhbGVUb0N1cnJlbnRSYW5nZTogZnVuY3Rpb24oZGlzdCkge1xuICAgICAgICByZXR1cm4gc2NhbGVUb1JhbmdlKGRpc3QsIHRoaXMucmVmcy5ncmFwaC5wcm9wcy5yYW5nZSk7XG4gICAgfSxcblxuICAgIGFkZFJvdGF0aW9uVG9vbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5wcm9wcy50b29scy5yb3RhdGlvbjtcbiAgICAgICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBncmFwaGllID0gdGhpcy5yZWZzLmdyYXBoLmdyYXBoaWUoKTtcblxuICAgICAgICB2YXIgcG9pbnRDb2xvciA9IGNvbG9yRm9yVG9vbChvcHRpb25zKTtcbiAgICAgICAgLy8gVGhlIGNlbnRlciBvZiBvdXIgcm90YXRpb24sIHdoaWNoIGNhbiBiZSBtb3ZlZCB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGNlbnRlciBvZiByb3RhdGlvblxuICAgICAgICB0aGlzLnJvdGF0ZVBvaW50ID0gZ3JhcGhpZS5hZGRNb3ZhYmxlUG9pbnQoe1xuICAgICAgICAgICAgY29uc3RyYWludHM6IG9wdGlvbnMuY29uc3RyYWludHMsXG4gICAgICAgICAgICBjb29yZDogb3B0aW9ucy5jb29yZCxcbiAgICAgICAgICAgIHNuYXBYOiBncmFwaGllLnNuYXBbMF0sXG4gICAgICAgICAgICBzbmFwWTogZ3JhcGhpZS5zbmFwWzFdLFxuICAgICAgICAgICAgbm9ybWFsU3R5bGU6IHsgICAgICAgICAgICAgICAvLyB1Z2gsIHRoaXMgc2VlbXMgdG8gYmUgYSBnbG9iYWwgYW5kXG4gICAgICAgICAgICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IFwiXCIsICAvLyBpcyBzZXQgdG8gZGFzaCBhYm92ZVxuICAgICAgICAgICAgICAgIHN0cm9rZTogcG9pbnRDb2xvcixcbiAgICAgICAgICAgICAgICBmaWxsOiBwb2ludENvbG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlnaGxpZ2h0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJcIixcbiAgICAgICAgICAgICAgICBzdHJva2U6IHBvaW50Q29sb3IsXG4gICAgICAgICAgICAgICAgZmlsbDogcG9pbnRDb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgcG9pbnQgdGhhdCB3ZSBtb3ZlIGFyb3VuZCB0aGUgY2VudGVyIG9mIHJvdGF0aW9uIHRvIGFjdHVhbGx5XG4gICAgICAgIC8vIGNhdXNlIHJvdGF0aW9uc1xuICAgICAgICB0aGlzLnJvdGF0ZUhhbmRsZSA9IGdyYXBoaWUuYWRkUm90YXRlSGFuZGxlKHtcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5yb3RhdGVQb2ludCxcbiAgICAgICAgICAgIHJhZGl1czogdGhpcy5zY2FsZVRvQ3VycmVudFJhbmdlKFJPVEFURV9IQU5ETEVfRElTVCksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5zY2FsZVRvQ3VycmVudFJhbmdlKDAuMjQpLFxuICAgICAgICAgICAgaG92ZXJXaWR0aDogdGhpcy5zY2FsZVRvQ3VycmVudFJhbmdlKDAuNCksXG4gICAgICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uKG5ld0FuZ2xlLCBvbGRBbmdsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBzZWxmLmdldFJvdGF0aW9uVHJhbnNmb3JtRnJvbUFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZVBvaW50LmNvb3JkLFxuICAgICAgICAgICAgICAgICAgICBuZXdBbmdsZSAtIG9sZEFuZ2xlXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSBwb2x5Z29uIHdpdGggcm90YXRlSGFuZGxlXG4gICAgICAgICAgICAgICAgc2VsZi5kb1RyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEFuZ2xlICsgdHJhbnNmb3JtLmFuZ2xlRGVnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgdG9vbHMucm90YXRpb24uY29vcmRcbiAgICAgICAgdGhpcy5yb3RhdGVQb2ludC5vbk1vdmVFbmQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICBzZWxmLmNoYW5nZVRvb2woXCJyb3RhdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgY29vcmQ6IFt4LCB5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZUhhbmRsZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZVBvaW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhZGREaWxhdGlvblRvb2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMucHJvcHMudG9vbHMuZGlsYXRpb247XG4gICAgICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JhcGhpZSA9IHRoaXMucmVmcy5ncmFwaC5ncmFwaGllKCk7XG5cbiAgICAgICAgdmFyIHBvaW50Q29sb3IgPSBjb2xvckZvclRvb2wob3B0aW9ucyk7XG4gICAgICAgIC8vIHRoZSBjaXJjbGUgZm9yIGNhdXNpbmcgZGlsYXRpb24gdHJhbnNmb3Jtc1xuICAgICAgICBzZWxmLmRpbGF0aW9uQ2lyY2xlID0gZ3JhcGhpZS5hZGRDaXJjbGVHcmFwaCh7XG4gICAgICAgICAgICBjZW50ZXJDb25zdHJhaW50czogb3B0aW9ucy5jb25zdHJhaW50cyxcbiAgICAgICAgICAgIGNlbnRlcjogb3B0aW9ucy5jb29yZCxcbiAgICAgICAgICAgIHJhZGl1czogc2VsZi5zY2FsZVRvQ3VycmVudFJhbmdlKDIpLFxuICAgICAgICAgICAgc25hcFg6IGdyYXBoaWUuc25hcFswXSxcbiAgICAgICAgICAgIHNuYXBZOiBncmFwaGllLnNuYXBbMV0sXG4gICAgICAgICAgICBtaW5SYWRpdXM6IHNlbGYuc2NhbGVUb0N1cnJlbnRSYW5nZSgxKSxcbiAgICAgICAgICAgIHNuYXBSYWRpdXM6IHNlbGYuc2NhbGVUb0N1cnJlbnRSYW5nZSgwLjUpLFxuICAgICAgICAgICAgb25SZXNpemU6IGZ1bmN0aW9uKG5ld1JhZGl1cywgb2xkUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb1RyYW5zZm9ybSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGlsYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyOiBzZWxmLmRpbGF0aW9uQ2lyY2xlLmNlbnRlclBvaW50LmNvb3JkLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogbmV3UmFkaXVzL29sZFJhZGl1c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNpcmNsZU5vcm1hbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VcIjogS2hhblV0aWwuT1JBTkdFLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IFwiLSBcIixcbiAgICAgICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2lyY2xlSGlnaGxpZ2h0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBcInN0cm9rZVwiOiBLaGFuVXRpbC5PUkFOR0UsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMixcbiAgICAgICAgICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImZpbGxcIjogS2hhblV0aWwuT1JBTkdFLFxuICAgICAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAuMDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZW50ZXJOb3JtYWxTdHlsZToge1xuICAgICAgICAgICAgICAgIFwic3Ryb2tlXCI6IHBvaW50Q29sb3IsXG4gICAgICAgICAgICAgICAgXCJmaWxsXCI6IHBvaW50Q29sb3IsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMixcbiAgICAgICAgICAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNlbnRlckhpZ2hsaWdodFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCJzdHJva2VcIjogcG9pbnRDb2xvcixcbiAgICAgICAgICAgICAgICBcImZpbGxcIjogcG9pbnRDb2xvcixcbiAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAyLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcIlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvcmlnT25Nb3ZlRW5kID0gdGhpcy5kaWxhdGlvbkNpcmNsZS5jZW50ZXJQb2ludC5vbk1vdmVFbmQ7XG4gICAgICAgIHRoaXMuZGlsYXRpb25DaXJjbGUuY2VudGVyUG9pbnQub25Nb3ZlRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAob3JpZ09uTW92ZUVuZCkge1xuICAgICAgICAgICAgICAgIG9yaWdPbk1vdmVFbmQuYXBwbHkodGhpcywgXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jaGFuZ2VUb29sKFwiZGlsYXRpb25cIiwge1xuICAgICAgICAgICAgICAgIGNvb3JkOiBzZWxmLmRpbGF0aW9uQ2lyY2xlLmNlbnRlclBvaW50LmNvb3JkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRpbGF0aW9uQ2lyY2xlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm5zIGEgdHJhbnNmb3JtYXRpb24gb2JqZWN0IHJlcHJlc2VudGluZyBhIHJvdGF0aW9uXG4gICAgLy8gcm91bmRzIHRoZSBhbmdsZSB0byB0aGUgbmVhcmVzdCAxNSBkZWdyZWVzXG4gICAgZ2V0Um90YXRpb25UcmFuc2Zvcm1Gcm9tQW5nbGU6IGZ1bmN0aW9uKGNlbnRlciwgYW5nbGVDaGFuZ2VkKSB7XG4gICAgICAgIGFuZ2xlQ2hhbmdlZCA9IChhbmdsZUNoYW5nZWQgKyAzNjApICUgMzYwO1xuICAgICAgICBpZiAoYW5nbGVDaGFuZ2VkID4gMTgwKSB7XG4gICAgICAgICAgICBhbmdsZUNoYW5nZWQgLT0gMzYwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3VuZGVkQW5nbGUgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgIGFuZ2xlQ2hhbmdlZCAvIFJPVEFURV9TTkFQX0RFR1JFRVNcbiAgICAgICAgICAgICkgKiBST1RBVEVfU05BUF9ERUdSRUVTO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJvdGF0aW9uXCIsXG4gICAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICAgIGFuZ2xlRGVnOiByb3VuZGVkQW5nbGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gYXBwbHkgYW5kIHNhdmUgYSB0cmFuc2Zvcm1cbiAgICBkb1RyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtKHRyYW5zZm9ybSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvLyBhcHBseSBhIHRyYW5zZm9ybSB0byBvdXIgcG9seWdvbiAod2l0aG91dCBtb2RpZnlpbmcgb3VyIHRyYW5zZm9ybWF0aW9uXG4gICAgLy8gbGlzdClcbiAgICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmdyYXBoTW9kZSAhPT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBUcmFuc2Zvcm1PcHMuYXBwbHkodHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlDb29yZFRyYW5zZm9ybWF0aW9uKHRyYW5zZm9ybUZ1bmMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHRyYW5zZm9ybSBvdXIgcG9seWdvbiBieSB0cmFuc2Zvcm1pbmcgZWFjaCBwb2ludCB1c2luZyBhIGdpdmVuIGZ1bmN0aW9uXG4gICAgYXBwbHlDb29yZFRyYW5zZm9ybWF0aW9uOiBmdW5jdGlvbihwb2ludFRyYW5zZm9ybSkge1xuICAgICAgICBfLmVhY2godGhpcy5zaGFwZS5wb2ludHMsIGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgbmV3Q29vcmQgPSBwb2ludFRyYW5zZm9ybShwb2ludC5jb29yZCk7XG4gICAgICAgICAgICBwb2ludC5zZXRDb29yZChuZXdDb29yZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNoYXBlLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICByZXNldENvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydENvb3JkcyA9IHRoaXMucHJvcHMuc3RhcnRpbmcuc2hhcGUuY29vcmRzO1xuICAgICAgICBfLmVhY2godGhpcy5zaGFwZS5wb2ludHMsIGZ1bmN0aW9uKHBvaW50LCBpKSB7XG4gICAgICAgICAgICBwb2ludC5zZXRDb29yZChzdGFydENvb3Jkc1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNoYXBlLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdHJhbnNmcm9tYXRpb25cbiAgICBoYW5kbGVVbmRvQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnMudG9vbHNCYXIuY2hhbmdlU2VsZWN0ZWQobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnRyYW5zZm9ybWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uczogXy5pbml0aWFsKHRoaXMucHJvcHMudHJhbnNmb3JtYXRpb25zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0VHJhbnNmb3JtYXRpb25Qcm9wczogZnVuY3Rpb24obmV3VHJhbnNmb21hdGlvbkxpc3QpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnM6IG5ld1RyYW5zZm9tYXRpb25MaXN0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBhZGQgYSB0cmFuc2Zvcm1hdGlvbiB0byBvdXIgcHJvcHMgbGlzdCBvZiB0cmFuc2Zvcm1hdGlvblxuICAgIGFkZFRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWF0aW9ucyA9IFRyYW5zZm9ybU9wcy5hcHBlbmQoXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbnMsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zOiBfLmNsb25lKHRoaXMudHJhbnNmb3JtYXRpb25zKVxuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIGNoYW5nZVRvb2w6IGZ1bmN0aW9uKHRvb2wsIGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG5ld1Rvb2xzID0gXy5jbG9uZSh0aGlzLnByb3BzLnRvb2xzKTtcbiAgICAgICAgbmV3VG9vbHNbdG9vbF0gPSBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy50b29sc1t0b29sXSwgY2hhbmdlcyk7XG4gICAgICAgIHRoaXMudG9vbHNbdG9vbF0gPSBfLmNsb25lKG5ld1Rvb2xzW3Rvb2xdKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICB0b29sczogbmV3VG9vbHMsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzaW1wbGVWYWxpZGF0ZTogZnVuY3Rpb24ocnVicmljKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1lci52YWxpZGF0ZSh0aGlzLnRvSlNPTigpLCBydWJyaWMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgd2hlcmUgdGhlIGNvb3JkaW5hdGVzIHdvdWxkIGJlIGlmIHRoZXkgd2VyZVxuICAgICAqIG1vdmVkLCBldmVuIGlmIHdlJ3JlIGluIGZvcm1hbCBtb2RlIHdpdGggbm8gbW92ZW1lbnRcbiAgICAgKiAoYW5kIHRodXMgdGhlIGFjdHVhbCBtb3ZhYmxlcG9pbnRzIG1heSBub3QgaGF2ZSBtb3ZlZFxuICAgICAqL1xuICAgIGdldENvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydENvb3JkcyA9IHRoaXMucHJvcHMuc3RhcnRpbmcuc2hhcGUuY29vcmRzO1xuICAgICAgICB2YXIgdHJhbnNmb3JtcyA9IHRoaXMucHJvcHMudHJhbnNmb3JtYXRpb25zO1xuICAgICAgICByZXR1cm4gXy5yZWR1Y2UodHJhbnNmb3JtcywgZnVuY3Rpb24gKGNvb3JkcywgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAoY29vcmRzLCBUcmFuc2Zvcm1PcHMuYXBwbHkodHJhbnNmb3JtKSk7XG4gICAgICAgIH0sIHN0YXJ0Q29vcmRzKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGpzb24gPSBfLnBpY2sodGhpcy5wcm9wcywgXCJncmFkaW5nXCIsIFwic3RhcnRpbmdcIiwgXCJncmFwaE1vZGVcIixcbiAgICAgICAgICAgICAgICBcImxpc3RNb2RlXCIsIFwidG9vbHNcIiwgXCJkcmF3U29sdXRpb25TaGFwZVwiLCBcImdyYWRlRW1wdHlcIik7XG4gICAgICAgIGpzb24uZ3JhcGggPSB0aGlzLnJlZnMuZ3JhcGgudG9KU09OKCk7XG4gICAgICAgIGpzb24uYW5zd2VyID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zOiB0aGlzLnByb3BzLnRyYW5zZm9ybWF0aW9ucyxcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lc24ndCBjYWxsIHRoaXMuc2hhcGUudG9KU09OKCkgYmVjYXVzZSB0aGF0IGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGhhbmRsZSBjb29yZGluYXRlcyBpbiBmb3JtYWwgbW9kZSB3aXRob3V0IG1vdmVtZW50LCBzaW5jZVxuICAgICAgICAgICAgLy8gdGhlIG1vdmFibGVwb2ludHMgbmV2ZXIgbW92ZVxuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnNoYXBlLnR5cGUsXG4gICAgICAgICAgICAgICAgY29vcmRzOiB0aGlzLmdldENvb3JkcygpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuc2hhcGUuZ2V0T3B0aW9ucygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGpzb24udmVyc2lvbiA9IDEuMjsgLy8gR2l2ZSB1cyBzb21lIHNhZmV0eSB0byBjaGFuZ2UgdGhlIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVhbGl6ZSB0aGF0IEkgd3JvdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhvcnJpYmxlIGpzb24gc3BlYyBmb3IgdGhpcyB3aWRnZXRcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufSk7XG5cbl8uZXh0ZW5kKFRyYW5zZm9ybWVyLCB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChndWVzcywgcnVicmljKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbnkgcmVxdWlyZWQgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gVHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAocnVicmljLnRvb2xzW3R5cGVdLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVXNlZCA9IF8uYW55KF8ubWFwKGd1ZXNzLmFuc3dlci50cmFuc2Zvcm1hdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVxdWlyZWQgdHJhbnNmb3JtYXRpb25zIG11c3QgYXBwZWFyIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbiBsaXN0LCBhbmQgbXVzdCBub3QgYmUgbm8tb3BzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHJhbnNmb3JtLnR5cGUgPT09IHR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhVHJhbnNmb3JtT3BzLmlzRW1wdHkodHJhbnNmb3JtKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIVRyYW5zZm9ybU9wcy5pc05vT3AodHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzVXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIllvdXIgdHJhbnNmb3JtYXRpb24gbXVzdCB1c2UgYSBcIiArIHR5cGUgKyBcIi5cIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgc2hhcGVzXG4gICAgICAgIGlmIChTaGFwZVR5cGVzLmVxdWFsKGd1ZXNzLmFuc3dlci5zaGFwZSxcbiAgICAgICAgICAgICAgICBydWJyaWMuY29ycmVjdC5zaGFwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludHNcIixcbiAgICAgICAgICAgICAgICBlYXJuZWQ6IDEsXG4gICAgICAgICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghcnVicmljLmdyYWRlRW1wdHkgJiYgZGVlcEVxKFxuICAgICAgICAgICAgICAgICAgICBndWVzcy5hbnN3ZXIuc2hhcGUuY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICBydWJyaWMuc3RhcnRpbmcuc2hhcGUuY29vcmRzXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlVzZSB0aGUgaW50ZXJhY3RpdmUgZ3JhcGggdG8gZGVmaW5lIGEgY29ycmVjdCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidHJhbnNmb3JtYXRpb24uXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicG9pbnRzXCIsXG4gICAgICAgICAgICAgICAgZWFybmVkOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsOiAxLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFRyYW5zZm9ybWVyRWRpdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnVHJhbnNmb3JtZXJFZGl0b3InLFxuICAgIC8vIFRPRE8gKGphY2spOiBUaGVzZSBzaG91bGQgYmUgcmVmYWN0b3JlZCBpbnRvIGEgbmljZSBvYmplY3QgYXQgdGhlIHRvcFxuICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbGwgdGhpcyBkdXBsaWNhdGlvblxuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLmRlZmF1bHRzKHtcbiAgICAgICAgICAgIGdyYXBoOiBkZWZhdWx0R3JhcGhQcm9wcyh0aGlzLnByb3BzLmdyYXBoLCAzNDApXG4gICAgICAgIH0sIGRlZmF1bHRUcmFuc2Zvcm1lclByb3BzKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRmlsbCBpbiBhbnkgbWlzc2luZyB2YWx1ZSBpbiB0aGlzLnByb3BzLmdyYXBoXG4gICAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBiZWNhdXNlIHRoZSBncmFwaCBqc29uIGRvZXNuJ3QgaW5jbHVkZVxuICAgICAgICAvLyBib3gsIGZvciBleGFtcGxlXG4gICAgICAgIHZhciBncmFwaCA9IF8uZXh0ZW5kKFxuICAgICAgICAgICAgICAgIGRlZmF1bHRHcmFwaFByb3BzKHRoaXMucHJvcHMuZ3JhcGgsIDM0MCksXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5ncmFwaFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5ET00uZGl2KG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgICAgICAgICAgICBQcm9wQ2hlY2tCb3goXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbDpcIkdyYWRlIGVtcHR5IGFuc3dlcnMgYXMgd3Jvbmc6XCIsXG4gICAgICAgICAgICAgICAgICAgIGdyYWRlRW1wdHk6dGhpcy5wcm9wcy5ncmFkZUVtcHR5LFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApLFxuICAgICAgICAgICAgICAgIEluZm9UaXAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgV2UgZ2VuZXJhbGx5IGRvbid0IGdyYWRlIGVtcHR5IGFuc3dlcnMuIFRoaXMgdXN1YWxseSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid29ya3Mgd2VsbCwgYnV0IHNvbWV0aW1lcyBjYW4gcmVzdWx0IGluIGdpdmluZyBhd2F5IFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJ0IG9mIGFuIGFuc3dlciBpbiBhIG11bHRpLXBhcnQgcXVlc3Rpb24uIFwiXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LkRPTS5wKG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgSWYgdGhpcyBpcyBhIG11bHRpLXBhcnQgcXVlc3Rpb24gKHRoZXJlIGlzIGFub3RoZXIgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZGdldCksIHlvdSBwcm9iYWJseSB3YW50IHRvIGVuYWJsZSB0aGlzIG9wdGlvbi4gXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk90aGVyd2lzZSwgeW91IHNob3VsZCBsZWF2ZSBpdCBkaXNhYmxlZC4gXCJcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuRE9NLnAobnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBDb25mdXNlZD8gVGFsayB0byBFbGl6YWJldGguIFwiXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcIkdyYXBoIHNldHRpbmdzOlwiKSxcbiAgICAgICAgICAgIEdyYXBoU2V0dGluZ3MoXG4gICAgICAgICAgICAgICAge2JveDpncmFwaC5ib3gsXG4gICAgICAgICAgICAgICAgbGFiZWxzOmdyYXBoLmxhYmVscyxcbiAgICAgICAgICAgICAgICByYW5nZTpncmFwaC5yYW5nZSxcbiAgICAgICAgICAgICAgICBzdGVwOmdyYXBoLnN0ZXAsXG4gICAgICAgICAgICAgICAgZ3JpZFN0ZXA6Z3JhcGguZ3JpZFN0ZXAsXG4gICAgICAgICAgICAgICAgdmFsaWQ6Z3JhcGgudmFsaWQsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOmdyYXBoLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICAgICAgICBtYXJraW5nczpncmFwaC5tYXJraW5ncyxcbiAgICAgICAgICAgICAgICBzaG93UHJvdHJhY3RvcjpncmFwaC5zaG93UHJvdHJhY3RvcixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLmNoYW5nZUdyYXBofSApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcIlRyYW5zZm9ybWF0aW9uIHNldHRpbmdzOlwiKSxcbiAgICAgICAgICAgIFRyYW5zZm9ybWF0aW9uRXhwbG9yZXJTZXR0aW5ncyhcbiAgICAgICAgICAgICAgICB7cmVmOlwidHJhbnNmb3JtYXRpb25TZXR0aW5nc1wiLFxuICAgICAgICAgICAgICAgIGdyYXBoTW9kZTp0aGlzLnByb3BzLmdyYXBoTW9kZSxcbiAgICAgICAgICAgICAgICBsaXN0TW9kZTp0aGlzLnByb3BzLmxpc3RNb2RlLFxuICAgICAgICAgICAgICAgIHRvb2xzOnRoaXMucHJvcHMudG9vbHMsXG4gICAgICAgICAgICAgICAgZHJhd1NvbHV0aW9uU2hhcGU6dGhpcy5wcm9wcy5kcmF3U29sdXRpb25TaGFwZSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTp0aGlzLnByb3BzLm9uQ2hhbmdlfSApLFxuICAgICAgICAgICAgUmVhY3QuRE9NLmRpdihudWxsLCBcIlN0YXJ0aW5nIGxvY2F0aW9uOlwiKSxcbiAgICAgICAgICAgIFRyYW5zZm9ybWF0aW9uc1NoYXBlRWRpdG9yKFxuICAgICAgICAgICAgICAgIHtyZWY6XCJzaGFwZUVkaXRvclwiLFxuICAgICAgICAgICAgICAgIGdyYXBoOmdyYXBoLFxuICAgICAgICAgICAgICAgIHNoYXBlOnRoaXMucHJvcHMuc3RhcnRpbmcuc2hhcGUsXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6dGhpcy5jaGFuZ2VTdGFydGluZ30gKSxcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXCJTb2x1dGlvbiB0cmFuc2Zvcm1hdGlvbnM6XCIpLFxuICAgICAgICAgICAgVHJhbnNmb3JtZXIoXG4gICAgICAgICAgICAgICAge3JlZjpcImV4cGxvcmVyXCIsXG4gICAgICAgICAgICAgICAgZ3JhcGg6Z3JhcGgsXG4gICAgICAgICAgICAgICAgZ3JhcGhNb2RlOnRoaXMucHJvcHMuZ3JhcGhNb2RlLFxuICAgICAgICAgICAgICAgIGxpc3RNb2RlOnRoaXMucHJvcHMubGlzdE1vZGUsXG4gICAgICAgICAgICAgICAgZ3JhZGVFbXB0eTp0aGlzLnByb3BzLmdyYWRlRW1wdHksXG4gICAgICAgICAgICAgICAgdG9vbHM6dGhpcy5wcm9wcy50b29scyxcbiAgICAgICAgICAgICAgICBkcmF3U29sdXRpb25TaGFwZTp0aGlzLnByb3BzLmRyYXdTb2x1dGlvblNoYXBlLFxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nOnRoaXMucHJvcHMuc3RhcnRpbmcsXG4gICAgICAgICAgICAgICAgY29ycmVjdDp0aGlzLnByb3BzLnN0YXJ0aW5nLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uczp0aGlzLnByb3BzLmNvcnJlY3QudHJhbnNmb3JtYXRpb25zLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOnRoaXMuY2hhbmdlVHJhbnNmb3JtZXJ9IClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gcHJvcGFnYXRlIGEgcHJvcHMgY2hhbmdlIG9uIG91ciBncmFwaCBzZXR0aW5ncyB0b1xuICAgIC8vIHRoaXMucHJvcHMuZ3JhcGhcbiAgICBjaGFuZ2VHcmFwaDogZnVuY3Rpb24oZ3JhcGhDaGFuZ2VzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbmV3R3JhcGggPSBfLmV4dGVuZCh7fSwgdGhpcy5wcm9wcy5ncmFwaCwgZ3JhcGhDaGFuZ2VzKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICAgICAgICBncmFwaDogbmV3R3JhcGhcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvLyBwcm9wYWdhdGUgYSBwcm9wcyBjaGFuZ2Ugb24gb3VyIHN0YXJ0aW5nIGdyYXBoIHRvXG4gICAgLy8gdGhpcy5wcm9wcy5zdGFydGluZ1xuICAgIGNoYW5nZVN0YXJ0aW5nOiBmdW5jdGlvbihzdGFydGluZ0NoYW5nZXMpIHtcbiAgICAgICAgdmFyIG5ld1N0YXJ0aW5nID0gXy5leHRlbmQoe30sIHRoaXMucHJvcHMuc3RhcnRpbmcsIHN0YXJ0aW5nQ2hhbmdlcyk7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgICAgICAgc3RhcnRpbmc6IG5ld1N0YXJ0aW5nXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBwcm9wYWdhdGUgYSB0cmFuc2Zvcm1hdGlvbnMgY2hhbmdlIG9udG8gY29ycmVjdC50cmFuc2Zvcm1hdGlvbnNcbiAgICBjaGFuZ2VUcmFuc2Zvcm1lcjogZnVuY3Rpb24oY2hhbmdlcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNoYW5nZXMudHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLmNvcnJlY3QgPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zOiBjaGFuZ2VzLnRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VzLnRyYW5zZm9ybWF0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGNoYW5nZXMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGpzb24gPSB0aGlzLnJlZnMuZXhwbG9yZXIudG9KU09OKCk7XG4gICAgICAgIGpzb24uY29ycmVjdCA9IGpzb24uYW5zd2VyO1xuICAgICAgICBkZWxldGUganNvbi5hbnN3ZXI7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbn0pO1xuXG5cbldpZGdldHMucmVnaXN0ZXIoXCJ0cmFuc2Zvcm1lclwiLCBUcmFuc2Zvcm1lcik7XG5XaWRnZXRzLnJlZ2lzdGVyKFwidHJhbnNmb3JtZXItZWRpdG9yXCIsIFRyYW5zZm9ybWVyRWRpdG9yKTtcblxufSkoUGVyc2V1cyk7XG4iXX0=
;